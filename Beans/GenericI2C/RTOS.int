<?xml version="1.0" encoding="UTF-8"?>
<Interface>
  <Name>RTOS</Name>
  <Description>Interface "GenericI2C\RTOS" for component GenericI2C, generated by Component Wizard</Description>
  <Author>Erich Styger</Author>
  <Version>01.002</Version>
  <FileVersion>2</FileVersion>
  <MethodList>
    <Method>
      <TMthdItem>
        <Name>xSemaphoreCreateRecursiveMutex</Name>
        <Symbol>xSemaphoreCreateRecursiveMutex</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro that implements a recursive mutex by using the existing queue mechanism.\n
Mutexes created using this macro can be accessed using the xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros.  The  xSemaphoreTake() and xSemaphoreGive() macros should not be used.\n
A mutex used recursively can be 'taken' repeatedly by the owner. The mutex doesn't become available again until the owner has called xSemaphoreGiveRecursive() for each successful 'take' request.  For example, if a task successfully 'takes' the same mutex 5 times then the mutex will not be available to any other task until it has also  'given' the mutex back exactly five times.\n
This type of semaphore uses a priority inheritance mechanism so a task 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the semaphore it is no longer required. Mutex type semaphores cannot be used from within interrupt service routines.\n
See vSemaphoreCreateBinary() for an alternative implementation that can be used for pure synchronisation (where one task or interrupt always 'gives' the semaphore and another always 'takes' the semaphore) and from within interrupt service routines.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>xSemaphoreHandle</ReturnType>
        <RetHint>Handle to the created mutex semaphore.  Should be of type  xSemaphoreHandle.</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>xSemaphoreHandle #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xSemaphoreTakeRecursive</Name>
        <Symbol>xSemaphoreTakeRecursive</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro to recursively obtain, or 'take', a mutex type semaphore. The mutex must have previously been created using a call to xSemaphoreCreateRecursiveMutex();\n
This macro must not be used on mutexes created using xSemaphoreCreateMutex(). A mutex used recursively can be 'taken' repeatedly by the owner. The mutex doesn't become available again until the owner has called xSemaphoreGiveRecursive() for each successful 'take' request.  For example, if a task successfully 'takes' the same mutex 5 times then the mutex will not be available to any other task until it has also  'given' the mutex back exactly five times.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>Boolean</ReturnType>
        <RetHint>Returns pdTRUE if the semaphore was obtained.  pdFALSE if xBlockTime expired without the semaphore becoming available.</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>xMutex</ParName>
          <ParType>xSemaphoreHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A handle to the mutex being obtained.  This is the handle returned by xSemaphoreCreateRecursiveMutex();</ParHint>
        </Parameter>
        <Parameter>
          <ParName>xBlockTime</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The time in ticks to wait for the semaphore to become available.  The macro portTICK_RATE_MS can be used to convert this to a real time.  A block time of zero can be used to poll the semaphore.  If the task already owns the semaphore then xSemaphoreTakeRecursive() will return immediately no matter what the value of xBlockTime.</ParHint>
          <ParUserDeclaration>portTickType xBlockTime</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>bool #M#_#C#(xSemaphoreHandle xMutex, portTickType xBlockTime)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xSemaphoreGiveRecursive</Name>
        <Symbol>xSemaphoreGiveRecursive</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro to recursively release, or 'give', a mutex type semaphore. The mutex must have previously been created using a call to xSemaphoreCreateRecursiveMutex();\n
This macro must not be used on mutexes created using xSemaphoreCreateMutex(). A mutex used recursively can be 'taken' repeatedly by the owner. The mutex doesn't become available again until the owner has called xSemaphoreGiveRecursive() for each successful 'take' request.  For example, if a task successfully 'takes' the same mutex 5 times then the mutex will not be available to any other task until it has also  'given' the mutex back exactly five times.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>Boolean</ReturnType>
        <RetHint>Returns pdTRUE if the semaphore was given.</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xMutex</ParName>
          <ParType>xSemaphoreHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A handle to the mutex being released, or 'given'.  This is the handle returned by xSemaphoreCreateMutex();</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>bool #M#_#C#(xSemaphoreHandle xMutex)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vSemaphoreDelete</Name>
        <Symbol>vSemaphoreDelete</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Delete a semaphore.  This function must be used with care.  For example, do not delete a mutex type semaphore if the mutex is held by a task.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>void</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xSemaphore</ParName>
          <ParType>xSemaphoreHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A handle to the semaphore to be deleted.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(xSemaphoreHandle xSemaphore)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
  </MethodList>
  <EventList>
    <EmptySection_DummyValue/>
  </EventList>
  <Registration>
    <Template>FreeRTOS</Template>
  </Registration>
  <UserTypes>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>xTaskHandle</Name>
      <Hint/>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>\n
</PreparedHint>
      <Type/>
      <HWTestType/>
    </Type>
    <Type>
      <UsrType>TRetypeType</UsrType>
      <Name>portBASE_TYPE</Name>
      <Hint/>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>  typedef int16_t portBASE_TYPE ;\n
</PreparedHint>
      <Type>16bit signed</Type>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>unsigned_portBASE_TYPE</Name>
      <Hint/>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>typedef unsigned_portBASE_TYPE unsigned portBASE_TYPE;\n
</PreparedHint>
      <Type>typedef unsigned_portBASE_TYPE unsigned portBASE_TYPE;</Type>
      <HWTestType/>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>xSemaphoreHandle</Name>
      <Hint/>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>\n
</PreparedHint>
      <Type/>
      <HWTestType/>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>signed_portBASE_TYPE</Name>
      <Hint/>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>typedef unsigned_portBASE_TYPE unsigned portBASE_TYPE;\n
</PreparedHint>
      <Type>typedef unsigned_portBASE_TYPE unsigned portBASE_TYPE;</Type>
      <HWTestType/>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>pVoid</Name>
      <Hint>pointer to void</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>typedef void* pVoid; /* pointer to void */\n
</PreparedHint>
      <Type>typedef void* pVoid;</Type>
      <HWTestType/>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>portTickType</Name>
      <Hint/>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>\n
</PreparedHint>
      <Type/>
      <HWTestType/>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>Tsize_t</Name>
      <Hint>Alias to size_t standard type</Hint>
      <Generate>yes</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>typedef size_t Tsize_t; /* Alias to size_t standard type */\n
</PreparedHint>
      <Type>typedef size_t Tsize_t;</Type>
      <HWTestType/>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>xQueueHandle</Name>
      <Hint/>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>\n
</PreparedHint>
      <Type/>
      <HWTestType/>
    </Type>
  </UserTypes>
</Interface>

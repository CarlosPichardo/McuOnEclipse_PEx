<?xml version="1.0" encoding="UTF-8"?>
<Interface>
  <Name>LDD_I2C</Name>
  <Description>Interface "RTC_Maxim\LDD_I2C" for component RTC_Maxim, generated by Component Wizard</Description>
  <Author>Erich Styger</Author>
  <Version>01.007</Version>
  <FileVersion>2</FileVersion>
  <MethodList>
    <Method>
      <TMthdItem>
        <Name>Init</Name>
        <Symbol>Init</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Initializes the device. Allocates memory for the device data structure, allocates interrupt vectors and sets interrupt priority, sets pin routing, sets timing, etc.\n
If the "Enable in init. code" is set to "yes" value then the device is also enabled(see the description of the Enable() method). In this case the Enable() method is not necessary and needn't to be generated. \n
This method can be called only once. Before the second call of Init() the Deinit() must be called first.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <ReadOnly>true</ReadOnly>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>LDD_TDeviceData*</ReturnType>
        <RetHint>Pointer to the device data structure. </RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>UserDataPtr</ParName>
          <ParType>LDD_TUserData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to the user or RTOS specific data. This pointer will be passed as an event or callback parameter.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>LDD_TDeviceData* #M#_#C#(LDD_TUserData *UserDataPtr)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>Deinit</Name>
        <Symbol>Deinit</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Deinitializes the device. Switches off the device, frees the device data structure memory, interrupts vectors, etc.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint/>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>DeviceDataPtr</ParName>
          <ParType>LDD_TDeviceData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Device data structure pointer returned by &lt;a href="#Init"&gt;Init&lt;/a&gt; method.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(LDD_TDeviceData *DeviceDataPtr)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>MasterSendBlock</Name>
        <Symbol>MasterSendBlock</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>This method writes one (7-bit addressing) or two (10-bit addressing) slave address bytes inclusive of R/W bit = 0 to the I2C bus and then writes the block of characters to the bus. The slave address must be specified before, by the "SelectSlaveDevice" method or in component initialization section, "Target slave address init" property. If the method returns ERR_OK, it doesn't mean that transmission was successful. The state of transmission is detectable by means of events (OnMasterSendComplete or OnError). Data to be sent are not copied to an internal buffer and remains in the original location. Therefore the content of the buffer should not be changed until the transmission is complete. Event "OnMasterBlockSent"can be used to detect the end of the transmission. This method is available only for the MASTER or MASTER - SLAVE mode.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>LDD_TError</ReturnType>
        <RetHint>Error code, possible codes:\n ERR_OK - OK\n ERR_DISABLED -  Device is disabled\n ERR_SPEED - This device does not work in the active clock configuration\n ERR_BUSY - The I2C device is now running\n </RetHint>
        <ParamCount>4</ParamCount>
        <Parameter>
          <ParName>DeviceDataPtr</ParName>
          <ParType>LDD_TDeviceData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Device data structure pointer returned by &lt;a href="#Init"&gt;Init&lt;/a&gt; method.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>BufferPtr</ParName>
          <ParType>LDD_TData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to the block of data to send.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>Size</ParName>
          <ParType>LDD_I2C_TSize</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Size of the data block.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>SendStop</ParName>
          <ParType>LDD_I2C_TSendStop</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Parameter for generating I2C Stop condition\n  LDD_I2C_SEND_STOP - Stop condition is generated on end transmission.\n  LDD_I2C_NO_SEND_STOP - Stop condition isn't generated on end transmission.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>LDD_TError #M#_#C#(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, LDD_I2C_TSize Size, LDD_I2C_TSendStop SendStop)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>MasterReceiveBlock</Name>
        <Symbol>MasterReceiveBlock</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>This method writes one (7-bit addressing) or two (10-bit addressing) slave address bytes inclusive of R/W bit = 1 to the I2C bus and then receives the block of characters from the bus. The slave address must be specified before, by the "SelectSlaveDevice" method or in component initialization section, "Target slave address init" property. If the method returns ERR_OK, it doesn't mean that reception was successful. The state of reception is detectable by means of events (OnMasterSendComplete  or OnError). Data to be received are not copied to an internal buffer and remains in the original location. Therefore the content of the buffer should not be changed until the transmission is complete. Event "OnMasterBlockReceived"can be used to detect the end of the reception. This method is available only for the MASTER or MASTER - SLAVE mode.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>LDD_TError</ReturnType>
        <RetHint>Error code, possible codes:\n ERR_OK - OK\n ERR_DISABLED -  Device is disabled\n ERR_SPEED - This device does not work in the active clock configuration\n ERR_BUSY - The master device is busy\n ERR_NOTAVAIL - It is not possible to receive data if general call address is set.\n ERR_PARAM_MODE -  Stop condition isn't possible generated on end transmission.</RetHint>
        <ParamCount>4</ParamCount>
        <Parameter>
          <ParName>DeviceDataPtr</ParName>
          <ParType>LDD_TDeviceData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Device data structure pointer returned by &lt;a href="#Init"&gt;Init&lt;/a&gt; method.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>BufferPtr</ParName>
          <ParType>LDD_TData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to a buffer where received characters will be stored.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>Size</ParName>
          <ParType>LDD_I2C_TSize</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The size of the block.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>SendStop</ParName>
          <ParType>LDD_I2C_TSendStop</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Parameter for generating I2C Stop condition\n  LDD_I2C_SEND_STOP - Stop condition is generated on end transmission.\n  LDD_I2C_NO_SEND_STOP - Stop condition isn't generated on end transmission.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>LDD_TError #M#_#C#(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, LDD_I2C_TSize Size, LDD_I2C_TSendStop SendStop)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SelectSlaveDevice</Name>
        <Symbol>SelectSlaveDevice</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>This method selects a new slave for communication by its 7-bit slave, 10-bit address or general call value. Any send or receive method directs to or from selected device, until a new slave device is selected by this method. This method is available for the MASTER mode.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>LDD_TError</ReturnType>
        <RetHint>Error code, possible codes:\n ERR_OK - OK\n ERR_BUSY - The device is busy, wait until the current operation is finished.\n ERR_DISABLED -  The device is disabled.\n ERR_SPEED - This device does not work in the active clock configuration\n ERR_PARAM_ADDRESS_TYPE -  Invalid address type.\n ERR_PARAM_ADDRESS -  Invalid address value.</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>DeviceDataPtr</ParName>
          <ParType>LDD_TDeviceData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Device data structure pointer returned by &lt;a href="#Init"&gt;Init&lt;/a&gt; method.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>AddrType</ParName>
          <ParType>LDD_I2C_TAddrType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Specify type of slave address (7bit, 10bit or general call address), e.g. LDD_I2C_ADDRTYPE_7BITS.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>Addr</ParName>
          <ParType>LDD_I2C_TAddr</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>7bit or 10bit slave address value.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>LDD_TError #M#_#C#(LDD_TDeviceData *DeviceDataPtr, LDD_I2C_TAddrType AddrType, LDD_I2C_TAddr Addr)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
  </MethodList>
  <EventList>
    <Event>
      <TEvntItem>
        <Name>OnMasterBlockSent</Name>
        <Symbol>OnMasterBlockSent</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>This event is called when I2C in master mode finishes the transmission of the data successfully. This event is not available for the SLAVE mode and if MasterSendBlock is disabled. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>generate code</Description>
        <Expanded>Yes</Expanded>
        <DefaultValue>true</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <IsAssembler>false</IsAssembler>
        <Mode>mei?SameAsOwner</Mode>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>UserDataPtr</ParName>
          <ParType>LDD_TUserData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to the user or RTOS specific data. This pointer is passed as the parameter of Init method.</ParHint>
        </Parameter>
        <Scope>OVERRIDE</Scope>
        <Declarations>
          <ANSIC>void #C#(LDD_TUserData *UserDataPtr)</ANSIC>
        </Declarations>
        <Children>
          <GrupItem>
            <TEvntName>
              <Name>Event procedure name</Name>
              <Symbol>Name</Symbol>
              <Hint>OnMasterBlockSent procedure name</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue/>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
              <ErrorIfNotSet>true</ErrorIfNotSet>
              <IdentType>EVNT</IdentType>
            </TEvntName>
          </GrupItem>
        </Children>
      </TEvntItem>
    </Event>
    <Event>
      <TEvntItem>
        <Name>OnMasterBlockReceived</Name>
        <Symbol>OnMasterBlockReceived</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>This event is called when I2C is in master mode and finishes the reception of the data successfully. This event is not available for the SLAVE mode and if MasterReceiveBlock is disabled.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>generate code</Description>
        <Expanded>Yes</Expanded>
        <DefaultValue>true</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <IsAssembler>false</IsAssembler>
        <Mode>mei?SameAsOwner</Mode>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>UserDataPtr</ParName>
          <ParType>LDD_TUserData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to the user or RTOS specific data. This pointer is passed as the parameter of Init method.</ParHint>
        </Parameter>
        <Scope>OVERRIDE</Scope>
        <Declarations>
          <ANSIC>void #C#(LDD_TUserData *UserDataPtr)</ANSIC>
        </Declarations>
        <Children>
          <GrupItem>
            <TEvntName>
              <Name>Event procedure name</Name>
              <Symbol>Name</Symbol>
              <Hint>OnMasterBlockReceived procedure name</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue/>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
              <ErrorIfNotSet>true</ErrorIfNotSet>
              <IdentType>EVNT</IdentType>
            </TEvntName>
          </GrupItem>
        </Children>
      </TEvntItem>
    </Event>
  </EventList>
  <Registration>
    <Template>I2C_LDD</Template>
  </Registration>
  <UserTypes>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TError</Name>
      <Hint>Error identifier type</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint> /* Error identifier type */\n
</PreparedHint>
      <Type/>
      <HWTestType>16bit unsigned</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TEventMask</Name>
      <Hint>Event mask type.</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint> /* Event mask type. */\n
</PreparedHint>
      <Type/>
      <HWTestType>uint32_t</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_I2C_TAddr</Name>
      <Hint>Slave address value.</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint> /* Slave address value. */\n
</PreparedHint>
      <Type/>
      <HWTestType>uint16_t</HWTestType>
    </Type>
    <Type>
      <UsrType>TRecordType</UsrType>
      <Name>LDD_I2C_TStats</Name>
      <Hint>Device receive/transmit statistics.</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>  typedef struct { /* Device receive/transmit statistics. */\n
    uint32_t MasterSentChars; /* Number of master transmitted characters. */\n
    uint32_t MasterReceivedChars; /* Number of master received characters. */\n
    uint32_t MasterNacks; /* Number of no acknowledges. */\n
    uint32_t ArbitLost; /* Number of lost the bus arbitration. */\n
    uint32_t SlaveSentChars; /* Number of slave transmitted characters. */\n
    uint32_t SlaveReceivedChars; /* Number of slave received characters. */\n
    uint32_t SlaveTxUnderrun; /* Number of slave underrun. */\n
    uint32_t SlaveRxOverrun; /* Number of slave overrun. */\n
    uint32_t SlaveGeneralCallAddr; /* Number of a general call address. */\n
    uint32_t SlaveSMBusCallAddr; /* Number of a SMBus call address. */\n
    uint32_t SlaveSMBusAlertResponse; /* Number of slave SMBus alert response received. */\n
    uint32_t SCLLowTimeout; /* Number of SCL low timeout occur. */\n
    uint32_t SDALowTimeout; /* Number of SCL Hi and SDA low timeout occur. */\n
  } LDD_I2C_TStats;\n
</PreparedHint>
      <RecordItem>
        <ItemName>MasterSentChars</ItemName>
        <ItemType>uint32_t</ItemType>
        <ItemHint>Number of master transmitted characters.</ItemHint>
        <ItemPointer>no</ItemPointer>
      </RecordItem>
      <RecordItem>
        <ItemName>MasterReceivedChars</ItemName>
        <ItemType>uint32_t</ItemType>
        <ItemHint>Number of master received characters.</ItemHint>
        <ItemPointer>no</ItemPointer>
      </RecordItem>
      <RecordItem>
        <ItemName>MasterNacks</ItemName>
        <ItemType>uint32_t</ItemType>
        <ItemHint>Number of no acknowledges.</ItemHint>
        <ItemPointer>no</ItemPointer>
      </RecordItem>
      <RecordItem>
        <ItemName>ArbitLost</ItemName>
        <ItemType>uint32_t</ItemType>
        <ItemHint>Number of lost the bus arbitration.</ItemHint>
        <ItemPointer>no</ItemPointer>
      </RecordItem>
      <RecordItem>
        <ItemName>SlaveSentChars</ItemName>
        <ItemType>uint32_t</ItemType>
        <ItemHint>Number of slave transmitted characters.</ItemHint>
        <ItemPointer>no</ItemPointer>
      </RecordItem>
      <RecordItem>
        <ItemName>SlaveReceivedChars</ItemName>
        <ItemType>uint32_t</ItemType>
        <ItemHint>Number of slave received characters.</ItemHint>
        <ItemPointer>no</ItemPointer>
      </RecordItem>
      <RecordItem>
        <ItemName>SlaveTxUnderrun</ItemName>
        <ItemType>uint32_t</ItemType>
        <ItemHint>Number of slave underrun.</ItemHint>
        <ItemPointer>no</ItemPointer>
      </RecordItem>
      <RecordItem>
        <ItemName>SlaveRxOverrun</ItemName>
        <ItemType>uint32_t</ItemType>
        <ItemHint>Number of slave overrun.</ItemHint>
        <ItemPointer>no</ItemPointer>
      </RecordItem>
      <RecordItem>
        <ItemName>SlaveGeneralCallAddr</ItemName>
        <ItemType>uint32_t</ItemType>
        <ItemHint>Number of a general call address.</ItemHint>
        <ItemPointer>no</ItemPointer>
      </RecordItem>
      <RecordItem>
        <ItemName>SlaveSMBusCallAddr</ItemName>
        <ItemType>uint32_t</ItemType>
        <ItemHint>Number of a SMBus call address.</ItemHint>
        <ItemPointer>no</ItemPointer>
      </RecordItem>
      <RecordItem>
        <ItemName>SlaveSMBusAlertResponse</ItemName>
        <ItemType>uint32_t</ItemType>
        <ItemHint>Number of slave SMBus alert response received.</ItemHint>
        <ItemPointer>no</ItemPointer>
      </RecordItem>
      <RecordItem>
        <ItemName>SCLLowTimeout</ItemName>
        <ItemType>uint32_t</ItemType>
        <ItemHint>Number of SCL low timeout occur.</ItemHint>
        <ItemPointer>no</ItemPointer>
      </RecordItem>
      <RecordItem>
        <ItemName>SDALowTimeout</ItemName>
        <ItemType>uint32_t</ItemType>
        <ItemHint>Number of SCL Hi and SDA low timeout occur.</ItemHint>
        <ItemPointer>no</ItemPointer>
      </RecordItem>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TPinMask</Name>
      <Hint>Bit mask of pins that need to be connected</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint> /* Bit mask of pins that need to be connected */\n
</PreparedHint>
      <Type/>
      <HWTestType>8bit unsigned</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>uint8_t</Name>
      <Hint/>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>\n
</PreparedHint>
      <Type/>
      <HWTestType>8bit unsigned</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>uint16_t</Name>
      <Hint/>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>\n
</PreparedHint>
      <Type/>
      <HWTestType>16bit unsigned</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>uint32_t</Name>
      <Hint/>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>\n
</PreparedHint>
      <Type/>
      <HWTestType>32bit unsigned</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TDataPtr</Name>
      <Hint>General pointer to data.</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint> /* General pointer to data. */\n
</PreparedHint>
      <Type/>
      <HWTestType>pointer</HWTestType>
    </Type>
    <Type>
      <UsrType>TEnumType</UsrType>
      <Name>LDD_I2C_TSendStop</Name>
      <Hint>Parameter for generating I2C Stop condition.</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>  typedef enum { /* Parameter for generating I2C Stop condition. */\n
    LDD_I2C_NO_SEND_STOP,\n
    LDD_I2C_SEND_STOP\n
  } LDD_I2C_TSendStop;\n
</PreparedHint>
      <EnumCount>2</EnumCount>
      <Enum>LDD_I2C_NO_SEND_STOP</Enum>
      <Enum>LDD_I2C_SEND_STOP</Enum>
    </Type>
    <Type>
      <UsrType>TEnumType</UsrType>
      <Name>LDD_I2C_TAddrType</Name>
      <Hint>Type specifying the I2C address type.</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>  typedef enum { /* Type specifying the I2C address type. */\n
    LDD_I2C_ADDRTYPE_7BITS,\n
    LDD_I2C_ADDRTYPE_10BITS,\n
    LDD_I2C_ADDRTYPE_GENERAL_CALL\n
  } LDD_I2C_TAddrType;\n
</PreparedHint>
      <EnumCount>3</EnumCount>
      <Enum>LDD_I2C_ADDRTYPE_7BITS</Enum>
      <Enum>LDD_I2C_ADDRTYPE_10BITS</Enum>
      <Enum>LDD_I2C_ADDRTYPE_GENERAL_CALL</Enum>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TUserData</Name>
      <Hint>Pointer to this type specifying the user or RTOS specific data will be passed as an event or callback parameter. LDD global type (not specific for component and component instance).</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint> /* Pointer to this type specifying the user or RTOS specific data will be passed as an event or callback parameter. LDD global type (not specific for component and component instance). */\n
</PreparedHint>
      <Type/>
      <HWTestType>pointer</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TDeviceData</Name>
      <Hint>Pointer to this type, specifying the private component state information and data, has to be passed as a parameter to every component's method. LDD global type (not specific for component and component instance).</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint> /* Pointer to this type, specifying the private component state information and data, has to be passed as a parameter to every component's method. LDD global type (not specific for component and component instance). */\n
</PreparedHint>
      <Type/>
      <HWTestType>pointer</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TDeviceData*</Name>
      <Hint>Pointer to this type, specifying the private component state information and data, has to be passed as a parameter to every component's method. LDD global type (not specific for component and component instance).</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint> /* Pointer to this type, specifying the private component state information and data, has to be passed as a parameter to every component's method. LDD global type (not specific for component and component instance). */\n
</PreparedHint>
      <Type/>
      <HWTestType>pointer</HWTestType>
    </Type>
    <Type>
      <UsrType>TEnumType</UsrType>
      <Name>LDD_I2C_TBusState</Name>
      <Hint>Type specifying the I2C state of BUS.</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>  typedef enum { /* Type specifying the I2C state of BUS. */\n
    LDD_I2C_BUSY,\n
    LDD_I2C_IDLE\n
  } LDD_I2C_TBusState;\n
</PreparedHint>
      <EnumCount>2</EnumCount>
      <Enum>LDD_I2C_BUSY</Enum>
      <Enum>LDD_I2C_IDLE</Enum>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_I2C_TSize</Name>
      <Hint>Buffer size or data length</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint> /* Buffer size or data length */\n
</PreparedHint>
      <Type/>
      <HWTestType>16bit unsigned</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TData</Name>
      <Hint/>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>\n
</PreparedHint>
      <Type/>
      <HWTestType>16bit signed</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_I2C_TErrorMask</Name>
      <Hint>Error mask type.</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint> /* Error mask type. */\n
</PreparedHint>
      <Type/>
      <HWTestType>16bit unsigned</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TClockConfiguration</Name>
      <Hint>CPU clock configuration type. Index of the pre-configured clock configuration in the CPU component.</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint> /* CPU clock configuration type. Index of the pre-configured clock configuration in the CPU component. */\n
</PreparedHint>
      <Type/>
      <HWTestType>8bit unsigned</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TDriverOperationMode</Name>
      <Hint>Driver operation mode type.</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint> /* Driver operation mode type. */\n
</PreparedHint>
      <Type/>
      <HWTestType>8bit unsigned</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TCallback</Name>
      <Hint>Callback type used for definition of callback functions. </Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint> /* Callback type used for definition of callback functions.  */\n
</PreparedHint>
      <Type/>
      <HWTestType>pointer</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TDriverState</Name>
      <Hint>Driver state type.  </Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint> /* Driver state type.   */\n
</PreparedHint>
      <Type/>
      <HWTestType>16bit unsigned</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TCallbackParam</Name>
      <Hint>Callback parameter type used for callback functions.</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint> /* Callback parameter type used for callback functions. */\n
</PreparedHint>
      <Type/>
      <HWTestType>pointer</HWTestType>
    </Type>
    <Type>
      <UsrType>TEnumType</UsrType>
      <Name>LDD_I2C_TAckMode</Name>
      <Hint>Type specifying the I2C acknowledge mode.</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>  typedef enum { /* Type specifying the I2C acknowledge mode. */\n
    LDD_I2C_TYPICAL_ACK_MODE,\n
    LDD_I2C_SMBUS_ACK_MODE\n
  } LDD_I2C_TAckMode;\n
</PreparedHint>
      <EnumCount>2</EnumCount>
      <Enum>LDD_I2C_TYPICAL_ACK_MODE</Enum>
      <Enum>LDD_I2C_SMBUS_ACK_MODE</Enum>
    </Type>
    <Type>
      <UsrType>TEnumType</UsrType>
      <Name>LDD_I2C_TAckType</Name>
      <Hint>Type specifying the I2C byte acknowledge response.</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>  typedef enum { /* Type specifying the I2C byte acknowledge response. */\n
    LDD_I2C_ACK_BYTE,\n
    LDD_I2C_NACK_BYTE\n
  } LDD_I2C_TAckType;\n
</PreparedHint>
      <EnumCount>2</EnumCount>
      <Enum>LDD_I2C_ACK_BYTE</Enum>
      <Enum>LDD_I2C_NACK_BYTE</Enum>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_I2C_TMode</Name>
      <Hint>Actual operating mode.</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>bool /* Actual operating mode. */\n
</PreparedHint>
      <Type>bool</Type>
      <HWTestType>Boolean</HWTestType>
    </Type>
  </UserTypes>
</Interface>

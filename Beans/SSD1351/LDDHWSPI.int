<?xml version="1.0" encoding="UTF-8"?>
<Interface>
  <Name>LDDHWSPI</Name>
  <Description>Interface "SSD1351\LDDHWSPI" for component SSD1351, generated by Component Wizard</Description>
  <Author>Author</Author>
  <Version>01.000</Version>
  <FileVersion>2</FileVersion>
  <MethodList>
    <Method>
      <TMthdItem>
        <Name>Init</Name>
        <Symbol>Init</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Initializes the device. Allocates memory for the device data structure, allocates interrupt vectors and sets interrupt priority, sets pin routing, sets timing, etc.\n
If the "Enable in init. code" is set to "yes" value then the device is also enabled(see the description of the Enable() method). In this case the Enable() method is not necessary and needn't to be generated. \n
This method can be called only once. Before the second call of Init() the Deinit() must be called first.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <ReadOnly>true</ReadOnly>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>LDD_TDeviceData*</ReturnType>
        <RetHint>Device data structure pointer.</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>UserDataPtr</ParName>
          <ParType>LDD_TUserData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to the user or RTOS specific data. This pointer will be passed as an event or callback parameter.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>LDD_TDeviceData* #M#_#C#(LDD_TUserData *UserDataPtr)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>Deinit</Name>
        <Symbol>Deinit</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>This method deinitializes the device. It switches off the device, frees the device data structure memory, interrupts vectors, etc.</Hint>
        <ItemLevel>ADVANCED</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint/>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>DeviceDataPtr</ParName>
          <ParType>LDD_TDeviceData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Device data structure pointer returned by &lt;a href="#Init"&gt;Init&lt;/a&gt; method.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(LDD_TDeviceData *DeviceDataPtr)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>Enable</Name>
        <Symbol>Enable</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>This method enables SPI device. This method is intended to be used together with &lt;a href="#Disable"&gt;Disable()&lt;/a&gt; method to temporary switch On/Off the device after the device is initialized. \n
This method is required if the &lt;a href="SPIMaster_LDDProperties.html#InitEnable"&gt;Enabled in init. code&lt;/a&gt; property is set to "no" value.</Hint>
        <ItemLevel>ADVANCED</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>true</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>LDD_TError</ReturnType>
        <RetHint>Error code, possible codes:\n  ERR_OK - OK\n  ERR_SPEED - The device doesn't work in the active clock configuration</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>DeviceDataPtr</ParName>
          <ParType>LDD_TDeviceData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Device data structure pointer returned by &lt;a href="#Init"&gt;Init&lt;/a&gt; method.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>LDD_TError #M#_#C#(LDD_TDeviceData *DeviceDataPtr)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>Disable</Name>
        <Symbol>Disable</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Disables the SPI device. When the device is disabled, some component methods should not be called. If so, error ERR_DISABLED may be reported.\n
This method is intended to be used together with &lt;a href="#Enable"&gt;Enable()&lt;/a&gt; method to temporary switch on/off the device after the device is initialized. \n
This method is not required. The &lt;a href="#Deinit"&gt;Deinit()&lt;/a&gt; method can be used to switch off and uninstall the device.</Hint>
        <ItemLevel>ADVANCED</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>true</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>LDD_TError</ReturnType>
        <RetHint>Error code, possible codes:\n  ERR_OK - OK\n  ERR_SPEED - The device doesn't work in the active clock configuration</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>DeviceDataPtr</ParName>
          <ParType>LDD_TDeviceData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Device data structure pointer returned by &lt;a href="#Init"&gt;Init&lt;/a&gt; method.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>LDD_TError #M#_#C#(LDD_TDeviceData *DeviceDataPtr)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SetEventMask</Name>
        <Symbol>SetEventMask</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Enables/disables event(s). The events contained within the mask are enabled. Events not contained within the mask are disabled. \n
The component event masks are defined in the PE_Types.h file. \n
Note: Event that are not generated (See the "Method" tab in the Component inspector) are not handled by this method. In this case the method returns ERR_PARAM_MASK error code.\n
See also method &lt;a href="#GetEventMask"&gt;GetEventMask&lt;/a&gt;.</Hint>
        <ItemLevel>ADVANCED</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>true</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>LDD_TError</ReturnType>
        <RetHint>Error code, possible codes:\n     ERR_OK - OK\n     ERR_SPEED - The component does not work in the active clock configuration.\n     ERR_DISABLED - The component or device is disabled.\n     ERR_PARAM_MASK - Invalid event mask.</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>DeviceDataPtr</ParName>
          <ParType>LDD_TDeviceData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Device data structure pointer returned by &lt;a href="#Init"&gt;Init&lt;/a&gt; method.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>EventMask</ParName>
          <ParType>LDD_TEventMask</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Current EventMask. The component event masks are defined in the PE_Types.h file.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>LDD_TError #M#_#C#(LDD_TDeviceData *DeviceDataPtr, LDD_TEventMask EventMask)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>GetEventMask</Name>
        <Symbol>GetEventMask</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Returns current events mask. \n
Note: Event that are not generated (See the "Method" tab in the Component inspector) are not handled by this method.\n
See also method &lt;a href="#SetEventMask"&gt;SetEventMask&lt;/a&gt;.</Hint>
        <ItemLevel>ADVANCED</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>true</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>LDD_TEventMask</ReturnType>
        <RetHint>Current EventMask. The component event masks are defined in the PE_Types.h file.</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>DeviceDataPtr</ParName>
          <ParType>LDD_TDeviceData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Device data structure pointer returned by &lt;a href="#Init"&gt;Init&lt;/a&gt; method.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>LDD_TEventMask #M#_#C#(LDD_TDeviceData *DeviceDataPtr)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendBlock</Name>
        <Symbol>SendBlock</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sends a block of characters. The method returns ERR_BUSY when the previous block transmission is not completed. The method &lt;a href="#CancelBlockTransmission"&gt;CancelBlockTransmission&lt;/a&gt; can be used to cancel a transmit operation. This method finishes immediately after calling it - it doesn't wait the end of data transmission. Use event &lt;a href="#OnBlockSent"&gt;OnBlockSent&lt;/a&gt; to check the end of data transmission or method GetSentDataNum to check the state of sending.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>true</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>LDD_TError</ReturnType>
        <RetHint>Error code, possible codes:\n     ERR_OK - OK\n     ERR_SPEED - This device does not work in the active clock configuration\n     ERR_DISABLED - Component is disabled\n     ERR_BUSY - The previous transmit request is pending</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>DeviceDataPtr</ParName>
          <ParType>LDD_TDeviceData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Device data structure pointer returned by &lt;a href="#Init"&gt;Init&lt;/a&gt; method.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>BufferPtr</ParName>
          <ParType>LDD_TData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to the block of data to send.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>Size</ParName>
          <ParType>uint16_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Number of characters in the buffer.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>LDD_TError #M#_#C#(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, uint16_t Size)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>ReceiveBlock</Name>
        <Symbol>ReceiveBlock</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>This method specifies the number of data to receive. The method returns ERR_BUSY until the specified number of characters is received. The method &lt;a href="#CancelBlockReception"&gt;CancelBlockReception&lt;/a&gt; can be used to cancel a running receive operation. If a receive operation is not in progress (the method was not called or a previous operation has already finished) all received characters will be lost without any notification. To prevent the loss of data call the method immediately after the last receive operation has finished (e.g. from the &lt;a href="#OnBlockReceived"&gt;OnBlockReceived&lt;/a&gt; event). This method finishes immediately after calling it - it doesn't wait the end of data reception. Use event &lt;a href="#OnBlockReceived"&gt;OnBlockReceived&lt;/a&gt; to check the end of data reception or method GetReceivedDataNum to check the state of receiving.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>true</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>LDD_TError</ReturnType>
        <RetHint>Error code, possible codes:\n     ERR_OK - OK\n     ERR_SPEED - This device does not work in the active clock configuration\n     ERR_DISABLED - Component is disabled\n     ERR_BUSY - The previous receive request is pending</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>DeviceDataPtr</ParName>
          <ParType>LDD_TDeviceData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Device data structure pointer returned by &lt;a href="#Init"&gt;Init&lt;/a&gt; method.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>BufferPtr</ParName>
          <ParType>LDD_TData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to A buffer where received characters will be stored.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>Size</ParName>
          <ParType>uint16_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Size of the block</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>LDD_TError #M#_#C#(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, uint16_t Size)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>GetSentDataNum</Name>
        <Symbol>GetSentDataNum</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Returns the number of sent characters. This method is available only if method SendBlock is enabled.</Hint>
        <ItemLevel>ADVANCED</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>true</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>uint16_t</ReturnType>
        <RetHint>The number of characters in the output buffer.</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>DeviceDataPtr</ParName>
          <ParType>LDD_TDeviceData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Device data structure pointer returned by &lt;a href="#Init"&gt;Init&lt;/a&gt; method.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>uint16_t #M#_#C#(LDD_TDeviceData *DeviceDataPtr)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>GetReceivedDataNum</Name>
        <Symbol>GetReceivedDataNum</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Returns the number of received characters in the receive buffer. This method is available only if the ReceiveBlock method is enabled.</Hint>
        <ItemLevel>ADVANCED</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>true</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>uint16_t</ReturnType>
        <RetHint>The number of characters in the input buffer.</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>DeviceDataPtr</ParName>
          <ParType>LDD_TDeviceData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Device data structure pointer returned by &lt;a href="#Init"&gt;Init&lt;/a&gt; method.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>uint16_t #M#_#C#(LDD_TDeviceData *DeviceDataPtr)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>GetBlockSentStatus</Name>
        <Symbol>GetBlockSentStatus</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>This method returns whether the transmitter is finished transmitting all data block. The status flag is accumulated, after calling this method the status is returned and cleared (set to "false" state). This method is available only if method SendBlock is enabled.</Hint>
        <ItemLevel>ADVANCED</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>Boolean</ReturnType>
        <RetHint>Return value:\n     true - Data block is completely transmitted\n     false - Data block isn't completely transmitted.</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>DeviceDataPtr</ParName>
          <ParType>LDD_TDeviceData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Device data structure pointer returned by &lt;a href="#Init"&gt;Init&lt;/a&gt; method.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>bool #M#_#C#(LDD_TDeviceData *DeviceDataPtr)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>GetBlockReceivedStatus</Name>
        <Symbol>GetBlockReceivedStatus</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>This method returns whether the receiver is finished reception of all data block. The status flag is accumulated, after calling this method the status is returned and cleared (set to "false" state). This method is available only if method ReceiveBlock is enabled.</Hint>
        <ItemLevel>ADVANCED</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>Boolean</ReturnType>
        <RetHint>Return value:\n     true - Data block is completely received\n     false - Data block isn't completely received</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>DeviceDataPtr</ParName>
          <ParType>LDD_TDeviceData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Device data structure pointer returned by &lt;a href="#Init"&gt;Init&lt;/a&gt; method.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>bool #M#_#C#(LDD_TDeviceData *DeviceDataPtr)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>CancelBlockTransmission</Name>
        <Symbol>CancelBlockTransmission</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Immediately cancels running transmit process. Unsent data will never been sent. This method is available only if the SendBlock method is enabled.</Hint>
        <ItemLevel>ADVANCED</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>LDD_TError</ReturnType>
        <RetHint>Error code, possible codes:\n     ERR_OK - OK\n     ERR_SPEED - This device does not work in the active clock configuration\n     ERR_DISABLED - Component is disabled</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>DeviceDataPtr</ParName>
          <ParType>LDD_TDeviceData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Device data structure pointer returned by &lt;a href="#Init"&gt;Init&lt;/a&gt; method.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>LDD_TError #M#_#C#(LDD_TDeviceData *DeviceDataPtr)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>CancelBlockReception</Name>
        <Symbol>CancelBlockReception</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Immediately cancels the running receive process started by the ReceiveBlock method. Characters already stored in the HW buffer will be lost. This method is available only if the ReceiveBlock method is enabled.</Hint>
        <ItemLevel>ADVANCED</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>LDD_TError</ReturnType>
        <RetHint>Error code, possible codes:\n     ERR_OK - OK\n     ERR_SPEED - This device does not work in the active clock configuration\n     ERR_DISABLED - Component is disabled</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>DeviceDataPtr</ParName>
          <ParType>LDD_TDeviceData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Device data structure pointer returned by &lt;a href="#Init"&gt;Init&lt;/a&gt; method.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>LDD_TError #M#_#C#(LDD_TDeviceData *DeviceDataPtr)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>GetError</Name>
        <Symbol>GetError</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>This method returns a set of asserted flags. The flags are accumulated in the set. After calling this method the set is returned and cleared. This method is enabled when SPI device support error detect.</Hint>
        <ItemLevel>ADVANCED</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>true</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>LDD_TError</ReturnType>
        <RetHint>Error code (if GetError did not succeed), possible codes:\n     ERR_OK - OK\n     ERR_SPEED - This device does not work in the active clock configuration\n     ERR_DISABLED - Component is disabled</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>DeviceDataPtr</ParName>
          <ParType>LDD_TDeviceData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Device data structure pointer returned by &lt;a href="#Init"&gt;Init&lt;/a&gt; method.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>ErrorPtr</ParName>
          <ParType>LDD_SPIMASTER_TError</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>A pointer to the returned set of error flags:\n     LDD_SPIMASTER_RX_OVERFLOW - Receiver overflow\n     LDD_SPIMASTER_PARITY_ERROR - Parity error (only if HW supports parity feature)</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>LDD_TError #M#_#C#(LDD_TDeviceData *DeviceDataPtr, LDD_SPIMASTER_TError *ErrorPtr)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>GetDMAError</Name>
        <Symbol>GetDMAError</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Returns the selected DMA transfer error flags. After calling this method the set is returned and cleared. This method is enabled if the SPI device supports DMA.</Hint>
        <ItemLevel>ADVANCED</ItemLevel>
        <Visible>false</Visible>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>true</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>LDD_TError</ReturnType>
        <RetHint>Error code (if GetError did not succeed), possible values:\n     ERR_OK - OK\n     ERR_SPEED - This device does not work in the active clock configuration\n     ERR_DISABLED - Component is disabled</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>DeviceDataPtr</ParName>
          <ParType>LDD_TDeviceData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Device data structure pointer returned by &lt;a href="#Init"&gt;Init&lt;/a&gt; method.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>DMATransferId</ParName>
          <ParType>TDMATransferId</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Identifier of the DMA transfer channel, whose error flags are requested.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>ErrorFlagsPtr</ParName>
          <ParType>LDD_DMA_TErrorFlags</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to a variable, where to store the DMA channel transfer error flags.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>LDD_TError #M#_#C#(LDD_TDeviceData *DeviceDataPtr, TDMATransferId DMATransferId, LDD_DMA_TErrorFlags *ErrorFlagsPtr)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SelectConfiguration</Name>
        <Symbol>SelectConfiguration</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>This method selects attributes of communication from the &lt;a href="SPIMaster_LDDProperties.html#AttributeSetList"&gt;Attribute set list&lt;/a&gt; and select a chip select from the &lt;a href="SPIMaster_LDDProperties.html#ChipSelectList"&gt;Chip select list&lt;/a&gt;. Once any configuration is selected, a transmission can be started multiple times. This method is available if number of chip selects or number of attribute set is greater than 1. If the device doesn't support chip select functionality the ChipSelect parameter is ignored.</Hint>
        <ItemLevel>ADVANCED</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>LDD_TError</ReturnType>
        <RetHint>Error code, possible codes:\n     ERR_OK - OK\n     ERR_SPEED - This device does not work in the active clock configuration\n     ERR_DISABLED - Component is disabled\n     ERR_PARAM_CHIP_SELECT - Chip select index is out of range\n     ERR_PARAM_ATTRIBUTE_SET - Attribute set index is out of range\n     ERR_BUSY - Transmission is in progress</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>DeviceDataPtr</ParName>
          <ParType>LDD_TDeviceData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Device data structure pointer returned by &lt;a href="#Init"&gt;Init&lt;/a&gt; method.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>ChipSelect</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Chip select index from the &lt;a href="SPIMaster_LDDProperties.html#ChipSelectList"&gt;Chip select list&lt;/a&gt;.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>AttributeSet</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Communication attribute index from the &lt;a href="SPIMaster_LDDProperties.html#AttributeSetList"&gt;Attribute set list&lt;/a&gt;</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>LDD_TError #M#_#C#(LDD_TDeviceData *DeviceDataPtr, uint8_t ChipSelect, uint8_t AttributeSet)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SetConfiguration</Name>
        <Symbol>SetConfiguration</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>This method sets attributes of communication and select a chip select from the &lt;a href="SPIMaster_LDDProperties.html#ChipSelectList"&gt;chip select list&lt;/a&gt;. It is possible used predefined set of attributes. Once any configuration is selected, a transmission can be started multiple times.</Hint>
        <ItemLevel>ADVANCED</ItemLevel>
        <Visible>false</Visible>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>LDD_TError</ReturnType>
        <RetHint>Error code, possible codes:\n     ERR_OK - OK\n     ERR_VALUE - ChipSelect or AttributeSet variable value is out of range\n     ERR_DISABLED - Component is disabled\n     ERR_BUSY - Transmission is in progress </RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>DeviceDataPtr</ParName>
          <ParType>LDD_TDeviceData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Device data structure pointer returned by &lt;a href="#Init"&gt;Init&lt;/a&gt; method.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>Configuration</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to configuration.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>LDD_TError #M#_#C#(LDD_TDeviceData *DeviceDataPtr, uint8_t *Configuration)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>Main</Name>
        <Symbol>Main</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>This method is available only in the polling mode (Interrupt service/event = 'no'). If interrupt service is disabled this method replaces the interrupt handler. This method should be called if Receive/SendBlock was invoked before in order to run the reception/transmission. The end of the receiving/transmitting is indicated by OnBlockSent or OnBlockReceived event. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint/>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>DeviceDataPtr</ParName>
          <ParType>LDD_TDeviceData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Device data structure pointer returned by &lt;a href="#Init"&gt;Init&lt;/a&gt; method.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(LDD_TDeviceData *DeviceDataPtr)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>ForceReceiver</Name>
        <Symbol>ForceReceiver</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Copy chars from the receiver FIFO to user buffer defined by method ReceiveBlock. This method is possible use for flush Rx FIFO, when size of user Rx buffer defined by method ReceiveBlock isn't multiple of Rx FIFO watermark value. This method is available only when ReceiveBlock method is enabled and value of Rx watermark is greater than 1.</Hint>
        <ItemLevel>ADVANCED</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint/>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>DeviceDataPtr</ParName>
          <ParType>LDD_TDeviceData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Device data structure pointer returned by &lt;a href="#Init"&gt;Init&lt;/a&gt; method.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(LDD_TDeviceData *DeviceDataPtr)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>GetStats</Name>
        <Symbol>GetStats</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Returns communication statistics (e.g. sent character count, parity error count).</Hint>
        <ItemLevel>ADVANCED</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>LDD_SPIMASTER_TStats</ReturnType>
        <RetHint>The actual communication statistics.</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>DeviceDataPtr</ParName>
          <ParType>LDD_TDeviceData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Device data structure pointer returned by &lt;a href="#Init"&gt;Init&lt;/a&gt; method. </ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>LDD_SPIMASTER_TStats #M#_#C#(LDD_TDeviceData *DeviceDataPtr)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>ClearStats</Name>
        <Symbol>ClearStats</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Clears the communication statistics. This method is available only if the GetStats method is enabled.</Hint>
        <ItemLevel>ADVANCED</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint/>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>DeviceDataPtr</ParName>
          <ParType>LDD_TDeviceData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Device data structure pointer returned by &lt;a href="#Init"&gt;Init&lt;/a&gt; method. </ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(LDD_TDeviceData *DeviceDataPtr)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SetOperationMode</Name>
        <Symbol>SetOperationMode</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>This method requests to change the component's operation mode. Upon a request to change the operation mode, the component will finish a pending job first and then notify a caller that an operation mode has been changed. When no job is pending (ERR_OK), the component changes an operation mode immediately and notify a caller about this change. </Hint>
        <ItemLevel>EXPERT</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>LDD_TError</ReturnType>
        <RetHint>Error code, possible codes:\n     ERR_OK - The change operation mode request has been accepted, callback will notify an application as soon as the mode is changed.\n     ERR_SPEED - The component does not work in the active clock configuration.\n     ERR_DISABLED - This component is disabled by user.\n     ERR_PARAM_MODE - Invalid operation mode.\n     ERR_BUSY - Job is running and the driver can't detect job end by itself. The approximate end of the job can be detected by method GetDriverState. The actual transmission/reception finishes later. It depends on component settings (data width, timing, size of HW buffer, etc.).</RetHint>
        <ParamCount>4</ParamCount>
        <Parameter>
          <ParName>DeviceDataPtr</ParName>
          <ParType>LDD_TDeviceData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Device data structure pointer returned by &lt;a href="#Init"&gt;Init&lt;/a&gt; method. </ParHint>
        </Parameter>
        <Parameter>
          <ParName>OperationMode</ParName>
          <ParType>LDD_TDriverOperationMode</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Requested driver operation mode.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>ModeChangeCallback</ParName>
          <ParType>LDD_TCallback</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Callback to notify the upper layer once a mode has been changed.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>ModeChangeCallbackParamPtr</ParName>
          <ParType>LDD_TCallbackParam</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to callback parameter to notify the upper layer once a mode has been changed.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>LDD_TError #M#_#C#(LDD_TDeviceData *DeviceDataPtr, LDD_TDriverOperationMode OperationMode, LDD_TCallback ModeChangeCallback, LDD_TCallbackParam *ModeChangeCallbackParamPtr)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>GetDriverState</Name>
        <Symbol>GetDriverState</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>This method returns the current driver status.</Hint>
        <ItemLevel>EXPERT</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>LDD_TDriverState</ReturnType>
        <RetHint>The current driver status mask.\n\nFollowing status masks defined in PE_Types.h can be used to check the current driver status.\n   PE_LDD_DRIVER_DISABLED_IN_CLOCK_CONFIGURATION - 1 - Driver is disabled in the current mode; 0 - Driver is enabled in the current mode.  \n   PE_LDD_DRIVER_DISABLED_BY_USER - 1 - Driver is disabled by the user; 0 - Driver is enabled by the user.        \n   PE_LDD_DRIVER_BUSY - 1 - Driver is the BUSY state; 0 - Driver is in the IDLE state.         </RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>DeviceDataPtr</ParName>
          <ParType>LDD_TDeviceData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Device data structure pointer returned by &lt;a href="#Init"&gt;Init&lt;/a&gt; method. </ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>LDD_TDriverState #M#_#C#(LDD_TDeviceData *DeviceDataPtr)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>ConnectPin</Name>
        <Symbol>ConnectPin</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>This method reconnects the requested pin associated with the selected peripheral in this component. This method is only available for CPU derivatives and peripherals that support the runtime pin sharing with other internal on-chip peripherals.</Hint>
        <ItemLevel>EXPERT</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>LDD_TError</ReturnType>
        <RetHint>Error code, possible values:\n     ERR_OK - OK\n     ERR_SPEED - The device doesn't work in the active clock configuration\n     ERR_PARAM_MASK - Invalid pin mask</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>DeviceDataPtr</ParName>
          <ParType>LDD_TDeviceData</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Device data structure pointer returned by &lt;a href="#Init"&gt;Init&lt;/a&gt; method.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>PinMask</ParName>
          <ParType>LDD_TPinMask</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Mask for the requested pins. The peripheral pins are reconnected according to this mask.\nPossible parameters:\n     LDD_SPIMASTER_INPUT_PIN - Input pin\n     LDD_SPIMASTER_OUTPUT_PIN - Output pin\n     LDD_SPIMASTER_CLK_PIN - Clock pin\n     LDD_SPIMASTER_CS_X_PIN - Chip select pin\n     LDD_SPIMASTER_CSS_PIN - Chip select strobe pin (only if supported by hardware)</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>LDD_TError #M#_#C#(LDD_TDeviceData *DeviceDataPtr, LDD_TPinMask PinMask)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
  </MethodList>
  <EventList>
    <EmptySection_DummyValue/>
  </EventList>
  <Registration>
    <Template>SPIMaster_LDD</Template>
  </Registration>
  <UserTypes>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>uint8_t</Name>
      <Hint/>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>\n
</PreparedHint>
      <Type/>
      <HWTestType>8bit unsigned</HWTestType>
    </Type>
    <Type>
      <UsrType>TRetypeType</UsrType>
      <Name>uint16_t</Name>
      <Hint/>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>  typedef word uint16_t ;\n
</PreparedHint>
      <Type>16bit unsigned</Type>
    </Type>
    <Type>
      <UsrType>TRetypeType</UsrType>
      <Name>uint32_t</Name>
      <Hint/>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>  typedef dword uint32_t ;\n
</PreparedHint>
      <Type>32bit unsigned</Type>
    </Type>
    <Type>
      <UsrType>TRetypeType</UsrType>
      <Name>LDD_SPIMASTER_TError</Name>
      <Hint>Error flags.</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>  typedef uint32_t LDD_SPIMASTER_TError ;/* Error flags. */\n
</PreparedHint>
      <Type>uint32_t</Type>
    </Type>
    <Type>
      <UsrType>TRetypeType</UsrType>
      <Name>LDD_DMA_TErrorFlags</Name>
      <Hint>DMA channel transfer error flags. (For further information see the DMAChannel_LDD component documentation.)</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>  typedef uint32_t LDD_DMA_TErrorFlags ;/* DMA channel transfer error flags. (For further information see the DMAChannel_LDD component documentation.) */\n
</PreparedHint>
      <Type>uint32_t</Type>
    </Type>
    <Type>
      <UsrType>TRetypeType</UsrType>
      <Name>LDD_SPIMASTER_TDataWidth</Name>
      <Hint>Bit length</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>  typedef word LDD_SPIMASTER_TDataWidth ;/* Bit length */\n
</PreparedHint>
      <Type>16bit unsigned</Type>
    </Type>
    <Type>
      <UsrType>TEnumType</UsrType>
      <Name>LDD_SPIMASTER_TParity</Name>
      <Hint>Parity type&lt;br/&gt;&lt;dl&gt;&lt;dt&gt;PARITY_NONE&lt;/dt&gt;&lt;dd&gt;No parity&lt;/dd&gt;&lt;dt&gt;PARITY_ODD&lt;/dt&gt;&lt;dd&gt;Odd parity&lt;/dd&gt;&lt;dt&gt;PARITY_EVEN&lt;/dt&gt;&lt;dd&gt;Even parity&lt;/dd&gt;&lt;/dl&gt;</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>  typedef enum { /* Parity type&lt;br/&gt;&lt;dl&gt;&lt;dt&gt;PARITY_NONE&lt;/dt&gt;&lt;dd&gt;No parity&lt;/dd&gt;&lt;dt&gt;PARITY_ODD&lt;/dt&gt;&lt;dd&gt;Odd parity&lt;/dd&gt;&lt;dt&gt;PARITY_EVEN&lt;/dt&gt;&lt;dd&gt;Even parity&lt;/dd&gt;&lt;/dl&gt; */\n
    PARITY_NONE,\n
    PARITY_ODD,\n
    PARITY_EVEN\n
  } LDD_SPIMASTER_TParity;\n
</PreparedHint>
      <EnumCount>3</EnumCount>
      <Enum>PARITY_NONE</Enum>
      <Enum>PARITY_ODD</Enum>
      <Enum>PARITY_EVEN</Enum>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>TComData</Name>
      <Hint>User type for communication. Size of this type depends on the communication data width. See &lt;a href="SyncMaster_LDD.html"&gt;General Info&lt;/a&gt;.</Hint>
      <Generate>no</Generate>
      <Unique>yes</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint> /* User type for communication. Size of this type depends on the communication data width. See &lt;a href="SyncMaster_LDD.html"&gt;General Info&lt;/a&gt;. */\n
</PreparedHint>
      <Type/>
      <HWTestType>16bit unsigned</HWTestType>
    </Type>
    <Type>
      <UsrType>TEnumType</UsrType>
      <Name>TDMATransferId</Name>
      <Hint>DMA transfer identification</Hint>
      <Generate>no</Generate>
      <Unique>yes</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>  typedef enum { /* DMA transfer identification */\n
    enum\n
  } &lt;i&gt;ComponentName_&lt;/i&gt;TDMATransferId;\n
</PreparedHint>
      <EnumCount>1</EnumCount>
      <Enum>enum</Enum>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TUserDataPtr</Name>
      <Hint>Pointer to the RTOS device structure. This pointer will be passed to all events as parameter.</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint> /* Pointer to the RTOS device structure. This pointer will be passed to all events as parameter. */\n
</PreparedHint>
      <Type/>
      <HWTestType>16bit signed</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TDeviceDataPtr</Name>
      <Hint/>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>\n
</PreparedHint>
      <Type/>
      <HWTestType>16bit signed</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TError</Name>
      <Hint/>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>\n
</PreparedHint>
      <Type/>
      <HWTestType>16bit unsigned</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TEventMask</Name>
      <Hint>Event mask type.</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint> /* Event mask type. */\n
</PreparedHint>
      <Type/>
      <HWTestType>32bit unsigned</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TData</Name>
      <Hint/>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>void\n
</PreparedHint>
      <Type>void</Type>
      <HWTestType>pointer</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TDeviceData</Name>
      <Hint>Pointer to this type, specifying the private component state information and data, has to be passed as a parameter to every component's method. LDD global type (not specific for component and component instance).</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>void /* Pointer to this type, specifying the private component state information and data, has to be passed as a parameter to every component's method. LDD global type (not specific for component and component instance). */\n
</PreparedHint>
      <Type>void</Type>
      <HWTestType>pointer</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TUserData</Name>
      <Hint>Pointer to this type specifying the user or RTOS specific data will be passed as an event or callback parameter. LDD global type (not specific for component and component instance).</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>void /* Pointer to this type specifying the user or RTOS specific data will be passed as an event or callback parameter. LDD global type (not specific for component and component instance). */\n
</PreparedHint>
      <Type>void</Type>
      <HWTestType>pointer</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TDeviceData*</Name>
      <Hint>Pointer to this type, specifying the private component state information and data, has to be passed as a parameter to every component's method. LDD global type (not specific for component and component instance).</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>void* /* Pointer to this type, specifying the private component state information and data, has to be passed as a parameter to every component's method. LDD global type (not specific for component and component instance). */\n
</PreparedHint>
      <Type>void*</Type>
      <HWTestType>pointer</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TPinMask</Name>
      <Hint>Bit mask of pins that need to be connected</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint> /* Bit mask of pins that need to be connected */\n
</PreparedHint>
      <Type/>
      <HWTestType>32bit unsigned</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TClockConfiguration</Name>
      <Hint>CPU clock configuration type. Index of the pre-configured clock configuration in the CPU component.</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint> /* CPU clock configuration type. Index of the pre-configured clock configuration in the CPU component. */\n
</PreparedHint>
      <Type/>
      <HWTestType>8bit unsigned</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TDriverOperationMode</Name>
      <Hint>Driver operation mode type.</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint> /* Driver operation mode type. */\n
</PreparedHint>
      <Type/>
      <HWTestType>8bit unsigned</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TCallback</Name>
      <Hint>Callback type used for definition of callback functions. </Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint> /* Callback type used for definition of callback functions.  */\n
</PreparedHint>
      <Type/>
      <HWTestType>pointer</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TDriverState</Name>
      <Hint>Driver state type.  </Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint> /* Driver state type.   */\n
</PreparedHint>
      <Type/>
      <HWTestType>16bit unsigned</HWTestType>
    </Type>
    <Type>
      <UsrType>TRecordType</UsrType>
      <Name>LDD_SPIMASTER_TStats</Name>
      <Hint>Communication statistics</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>  typedef struct { /* Communication statistics */\n
    uint32_t RxChars; /* Number of received characters */\n
    uint32_t TxChars; /* Number of transmitted characters */\n
    uint32_t RxParityErrors; /* Number of receiver parity errors, which have occured */\n
    uint32_t RxOverruns; /* Number of receiver overruns, which have occured */\n
  } LDD_SPIMASTER_TStats;\n
</PreparedHint>
      <RecordItem>
        <ItemName>RxChars</ItemName>
        <ItemType>uint32_t</ItemType>
        <ItemHint>Number of received characters</ItemHint>
        <ItemPointer>no</ItemPointer>
      </RecordItem>
      <RecordItem>
        <ItemName>TxChars</ItemName>
        <ItemType>uint32_t</ItemType>
        <ItemHint>Number of transmitted characters</ItemHint>
        <ItemPointer>no</ItemPointer>
      </RecordItem>
      <RecordItem>
        <ItemName>RxParityErrors</ItemName>
        <ItemType>uint32_t</ItemType>
        <ItemHint>Number of receiver parity errors, which have occured</ItemHint>
        <ItemPointer>no</ItemPointer>
      </RecordItem>
      <RecordItem>
        <ItemName>RxOverruns</ItemName>
        <ItemType>uint32_t</ItemType>
        <ItemHint>Number of receiver overruns, which have occured</ItemHint>
        <ItemPointer>no</ItemPointer>
      </RecordItem>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>LDD_TCallbackParam</Name>
      <Hint>Callback parameter type used for callback functions.</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint> /* Callback parameter type used for callback functions. */\n
</PreparedHint>
      <Type/>
      <HWTestType>pointer</HWTestType>
    </Type>
  </UserTypes>
</Interface>

<?xml version="1.0" encoding="UTF-8"?>
<Interface>
  <Name>HWSPI</Name>
  <Description>Interface S65Sharp\HWSPI for bean S65Sharp, generated by Bean Wizard</Description>
  <Author>Erich Styger</Author>
  <Version>01.001</Version>
  <FileVersion>2</FileVersion>
  <MethodList>
    <Method>
      <TMthdItem>
        <Name>SendChar</Name>
        <Symbol>SendChar</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sends one character to the channel.\n
&lt;!---VER_SPEC ~56800~ ^^ || DON'T CHANGE THIS LINE--&gt;\n
&lt;div class="versionspec"&gt;\n
&lt;B CLASS="VSP"&gt;\n
Version specific information for Freescale 56800 derivatives\n
&lt;/B&gt;\n
&lt;br/&gt;\n
DMA mode:&lt;BR /&gt;\n
If DMA controller is available on the selected CPU and the transmitter is configured to use DMA controller then this method only sets the selected DMA channel. The status of the DMA transfer can then be checked using GetCharsInTxBuf method. See the typical usage for details about communication using DMA.\n
&lt;/div&gt;\n
&lt;!---VER_SPEC_END  DON'T CHANGE THIS LINE--&gt;</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>true</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code, possible codes:\n     ERR_OK - OK\n     ERR_SPEED - This device does not work in the active speed mode\n     ERR_DISABLED - Device is disabled (only if output DMA is supported and enabled)\n     ERR_TXFULL - Transmitter is full</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>Chr</ParName>
          <ParType>TComData</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Character to send</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(%'ModuleName'_TComData Chr)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
  </MethodList>
  <EventList>
    <EmptySection_DummyValue/>
  </EventList>
  <Registration>
    <Template>HWSPI</Template>
  </Registration>
  <UserTypes>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>TError</Name>
      <Hint>Error flags. For languages which don't support bit access is byte access only to error flags possible. </Hint>
      <Generate>yes</Generate>
      <Unique>yes</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>typedef union {n  byte err;n  struct {n    bool OverRun  : 1;   /* OverRun error flag - the data overflow on the input has been detected. Both hardware detection (if supported) and software detection (when the value of Input buffer size property is 0) is used. */n    bool RxBufOvf : 1;   /* Rx buffer full error flag - the input circular buffer defined by the Input buffer size property has overrun. */n    bool FaultErr : 1;   /* Fault mode error flag - only if supported by hardware */n  }errName;n} %'ModuleName'_TError; /* Error flags. For languages which don't support bit access is byte access only to error flags possible.  */\n
</PreparedHint>
      <Type>typedef union {n  byte err;n  struct {n    bool OverRun  : 1;   /* OverRun error flag - the data overflow on the input has been detected. Both hardware detection (if supported) and software detection (when the value of Input buffer size property is 0) is used. */n    bool RxBufOvf : 1;   /* Rx buffer full error flag - the input circular buffer defined by the Input buffer size property has overrun. */n    bool FaultErr : 1;   /* Fault mode error flag - only if supported by hardware */n  }errName;n} %'ModuleName'_TError;</Type>
      <HWTestType>pointer</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>TComData</Name>
      <Hint>User type for communication. Size of this type depends on the communication data width. See &lt;a href="SynchroMaster.html"&gt;General Info&lt;/a&gt;.</Hint>
      <Generate>no</Generate>
      <Unique>yes</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint> /* User type for communication. Size of this type depends on the communication data width. See &lt;a href="SynchroMaster.html"&gt;General Info&lt;/a&gt;. */\n
</PreparedHint>
      <Type/>
      <HWTestType>pointer</HWTestType>
    </Type>
  </UserTypes>
</Interface>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1250">
<title>
Component  documentation - Methods
</title>
<STYLE type="text/css">
body{
  background-color: white;
  margin:0px;
  font: 13px Helvetica Neue, Helvetica, Arial, sans-serif;
}
A:visited {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:link {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:active {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:hover {
	COLOR: #2D8AA7; TEXT-DECORATION: underline
}
.VSP {
	COLOR: #2D8AA7; FONT: bold italic 14px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.reflink {
	FONT: 11px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
 	COLOR: #2D8AA7;
}
.user_text {
	FONT: 12px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
	COLOR: #000000;
}
.bluetext {
  COLOR: #695F52;
}
.versionspec {
  padding:5px; 
  background-color: RGB(243, 242, 230);
  margin-top:5px;
  margin-bottom:5px;  
}
.versionspecdetail {
  padding:5px; 
  background-color: RGB(243, 242, 230);
  margin-top:5px;
  margin-bottom:5px;  
}
.versionspeclabel {
  font-style: italic;
}
LI.DEF {
  list-style-image: url(DefaultLI.gif) ;
}
LI.BAS {
	list-style-image: url(BasicLI.gif) ;
}
LI.ADV {
	list-style-image: url(AdvancedLI.gif) ;
}
LI.EXP {
	list-style-image: url(ExpertLI.gif) ;
}
.titlebox {  
  font: bold 18px Helvetica Neue, Helvetica, Arial, sans-serif;
  color: #51626F;
  margin-bottom: 10px;
}
.lefttitlebox {
  background-color:#C3CFD1;  
}
.lefttitle {
  color:#51626F;
  font: bold 11px Helvetica Neue, Helvetica, Arial, sans-serif;   
}
.beanname {
  font: bold 14px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
  padding-top:6px;
  padding-bottom:5px;
  margin-bottom: 5px;
  border-bottom-style: dotted;
  border-bottom-width: 1;  
}
.descrtext {
  font-style: italic;
  font: 14px/18px Helvetica Neue, Helvetica, Arial, sans-serif;  
  padding-bottom:9px;
}
.footer {
  color: #b0b0b0; 
  font: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
  text-align: center;
  border-top-style: solid;
  border-top-color: #BOBOBO;
  border-top-width: 1px;  
  padding-top: 5px;
  margin-top: 20px;
}
.info_name {
  font: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
  padding: 0px;
  color: black;
}
.info_text {
  font: 11px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.text_title {
  COLOR: #000000; 
  FONT: bold 14px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.descr_line {
  COLOR: gray; 
  FONT: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.code {
  background-color: RGB(243, 242, 230);
  padding: 10px;
  white-space: pre;
  font-family: Courier New, Monospace;
}
</STYLE>

</head>

<body>

<table border="0"  cellspacing="0" cellpadding="0">
  <tr>
    <td valign="top" width="150" >
      <table  width="150" height="160" cellpadding="3" cellspacing="0" border="0">
        <tbody>
        <tr class="lefttitlebox">
          <td width="4"></td>
          <td align="center" valign="middle" height="30" width="128">
            <span class="lefttitle">
<b>PercepioTrace</b>
            </span>
          </td>
        </tr>
        <tr height="700">
          <td width="4"></td>
          <td width="128" valign="top">
            &nbsp;<br />
            <div class="reflink">
<!---HTMLLISTBEG_SHORT DON'T CHANGE THIS LINE-->
<a href="PercepioTrace.html">General Info</a><br />
<a href="PercepioTraceProperties.html">Properties</a><br />
<i>Methods</i><br />
<a href="PercepioTraceEvents.html">Events</a><br />
<!---HTMLLISTEND DON'T CHANGE THIS LINE-->
<br /><br /><br />
<a href="../../DOCs/PredefSymbols.html">Types &amp; definitions</a><br/>
<a href="../../DOCs/BEANindex.html">Component Index</a><br/>
<a href="../../DOCs/CPUindex.html">CPU Component Index</a><br/>
<a href="../../DOCs/EmbeddedBeans.html">Embedded Components</a><br/>
<a href="../../DOCs/BeanCategories.html">Components Categories</a><br/>

<br /><br /><br />
<center>
<img src="PercepioTrace_b.gif" alt="Component icon"/>


</center>
            </div>
          </td>
        </tr>
        </tbody>
      </table>
    </td>
    <td width="1" class="lefttitlebox" valign="top">
      <table class="lefttitlebox" width="1" cellpadding="0" cellspacing="0" height="100%" border="0">
        <tr class="lefttitlebox"><td width="1"></td></tr>
      </table>
    </td>
    <td style="padding-left:15px;padding-right:10px;" valign="top" align="left" width="100%" >

         <div class="titlebox">
            <div class="beanname">
              Component
              
              
              PercepioTrace
            </div>
            <div class="descrtext">Percepio FreeRTOS Trace</div>
            <div class="info_name">Component Level: <span class="info_text"><a href="../../DOCs/BeanCategoriesInfo.html#LevelAbstraction">High</a></span></div>
            <div class="info_name">Category: 
              <span class="info_text">
              <a href="../../DOCs/BeanCategoriesInfo.html">Operating Systems</a>
              
              </span>
            </div>
          </div>

         <div class="text_title">
              Methods:
    		 </div>		 
    		 <div class="descr_line">                  
              (Methods are user-callable functions/subroutines intended for
               the component functions control. Please see the <a href="../../DOCs/EmbeddedBeans.html#Methods">Embedded Components page</a> for more information.)                   
         </div>
                  
         <div class="user_text">
            <ul>
<!---USERBEG DON'T CHANGE THIS LINE-->

<!---USEREND DON'T CHANGE THIS LINE-->
<li><a name="vTraceEnable">
<b>vTraceEnable</b></a>
 - no hint
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vTraceEnable(int startOption)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>startoption:byte</i> - * TRC_START: Starts the tracing directly. In snapshot mode this allows for <br />* starting the trace at any point in your code, assuming vTraceEnable(TRC_INIT)<br />* has been called in the startup.<br />* Can also be used for streaming without Tracealyzer control, e.g. to a local<br />* flash file system (assuming such a &quot;stream port&quot;, see trcStreamingPort.h).<br />* <br />* TRC_START_AWAIT_HOST: For streaming mode only. Initializes the trace recorder<br />* if necessary and waits for a Start command from Tracealyzer (&quot;Start Recording&quot;<br />* button). This call is intentionally blocking! By calling vTraceEnable with<br />* this option from the startup code, you start tracing at this point and capture<br />* the early events.<br />*<br />* TRC_INIT: Initializes the trace recorder, but does not start the tracing.<br />* In snapshot mode, this must be followed by a vTraceEnable(TRC_START) sometime<br />* later.</li>
</ul><br />
</li>
<li><a name="uiTraceStart">
<b>uiTraceStart</b></a>
 - Starts the trace.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> dword uiTraceStart(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Return value:dword</i> - returns 1 if trace has been started, 0 otherwise.
</li>
</ul><br />
</li>
<li><a name="vTraceStop">
<b>vTraceStop</b></a>
 - Stops the trace.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vTraceStop(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
</ul><br />
</li>
<li><a name="vTraceClear">
<b>vTraceClear</b></a>
 - Clears the trace.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vTraceClear(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
</ul><br />
</li>
<li><a name="uiTraceGetTraceBufferSize">
<b>uiTraceGetTraceBufferSize</b></a>
 - Gets the size of the recorder data structure. For use together with vTraceGetTraceBuffer if you wish to implement an own store/upload solution, e.g., in case a debugger connection is not available for uploading the data.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> dword uiTraceGetTraceBufferSize(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Return value:dword</i> - Size of the trace buffer
</li>
</ul><br />
</li>
<li><a name="xTraceGetTraceBuffer">
<b>xTraceGetTraceBuffer</b></a>
 - Return a pointer to the recorder data structure. Use this together with uiTraceGetTraceBufferSize if you wish to implement an own store/upload solution, e.g., in case a debugger connection is not available for uploading the data.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void* xTraceGetTraceBuffer(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Return value:void*</i> - Pointer to the trace buffer
</li>
</ul><br />
</li>
<li><a name="xTraceRegisterString">
<b>xTraceRegisterString</b></a>
 - Register strings in the recorder, e.g. for names of user event channels.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> traceString xTraceRegisterString(const char* name)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>name: Pointer to char</i> - Pointer to label</li>
<li><i>Return value:traceString</i> - trace label to be used with vTracePrintF
</li>
</ul><br />
</li>
<li><a name="vTracePrint">
<b>vTracePrint</b></a>
 - Generates a User Event with a text label. The label is created/looked up in the symbol table using xTraceRegisterString.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vTracePrint(traceString chn, const char* str)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>chn:traceString</i> - trace label for the user event</li>
<li><i>str: Pointer to char</i> - Pointer to string</li>
</ul><br />
</li>
<li><a name="vTracePrintF">
<b>vTracePrintF</b></a>
 - Advanced user event - like printf (but limited formatting support - will improve)
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vTracePrintF(traceLabel eventLabel, char *formatStr, ...)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>eventLabel:traceLabel</i> - trace label</li>
<li><i>formatStr: Pointer to char</i> - Pointer to format string</li>
<li><i>Variable_1:byte</i> - open parameter list</li>
</ul><br />
</li>
<li><a name="vTraceSetQueueName">
<b>vTraceSetQueueName</b></a>
 - Assigns a name to a FreeRTOS Queue, Semaphore or Mutex. This function should  be called right after creation of the queue/mutex/semaphore. If not using this function, the queues/mutexes/semaphores will be presented by their numeric handle only.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vTraceSetQueueName(void *queue, char *name)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>queue: Pointer to byte</i> - Pointer to the queue</li>
<li><i>name: Pointer to char</i> - Pointer to name</li>
</ul><br />
</li>
<li><a name="vTraceSetSemaphoreName">
<b>vTraceSetSemaphoreName</b></a>
 - Assigns a name to a FreeRTOS Queue, Semaphore or Mutex. This function should  be called right after creation of the queue/mutex/semaphore. If not using this function, the queues/mutexes/semaphores will be presented by their numeric handle only.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vTraceSetSemaphoreName(void *semaphore, char *name)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>queue: Pointer to byte</i> - Pointer to the semaphore</li>
<li><i>name: Pointer to char</i> - Pointer to name</li>
</ul><br />
</li>
<li><a name="vTraceSetMutexName">
<b>vTraceSetMutexName</b></a>
 - Assigns a name to a FreeRTOS Queue, Semaphore or Mutex. This function should  be called right after creation of the queue/mutex/semaphore. If not using this function, the queues/mutexes/semaphores will be presented by their numeric handle only.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vTraceSetMutexName(void *mutex, char *name)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>queue: Pointer to byte</i> - Pointer to the mutex</li>
<li><i>name: Pointer to char</i> - Pointer to name</li>
</ul><br />
</li>
<li><a name="xTraceSetISRProperties">
<b>xTraceSetISRProperties</b></a>
 - Registers an Interrupt Service Routine in the recorder library, This must be called before using vTraceStoreISRBegin to store ISR events. This is typically called in the startup of the system, before the scheduler is started. Method is always enabled if 'Include ISR tracing' is set to 'yes' in the properties.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> traceHandle xTraceSetISRProperties(char *name, char prioritiy)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>name: Pointer to char</i> - Pointer to name</li>
<li><i>prioritiy:char</i> - priority</li>
<li><i>Return value:traceHandle</i> - trace handle to be used for vTaceStoreISRBegin()
</li>
</ul><br />
</li>
<li><a name="vTraceStoreISRBegin">
<b>vTraceStoreISRBegin</b></a>
 - Registers the beginning of an Interrupt Service Routine. This must not be interrupted by another ISR containing recorder library calls, so if allowing nested ISRs this must be called with interrupts disabled.  Method is always enabled if 'Include ISR tracing' is set to 'yes' in the properties.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vTraceStoreISRBegin(traceHandle handle)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>handle:traceHandle</i> - trace handle</li>
</ul><br />
</li>
<li><a name="vTraceStoreISREnd">
<b>vTraceStoreISREnd</b></a>
 - Registers the end of an Interrupt Service Routine. This must not be interrupted by another ISR containing recorder library calls, so if allowing nested ISRs this must be called with interrupts disabled.  Method is always enabled if 'Include ISR tracing' is set to 'yes' in the properties.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vTraceStoreISREnd(int isTaskSwitchRequired)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>isTaskSwitchRequired:byte</i> - The parameter pendingISR indicates if the interrupt has requested a task-switch (= 1) or if the interrupt returns to the earlier context (= 0)</li>
</ul><br />
</li>
<li><a name="vGetGDBDumpCommand">
<b>vGetGDBDumpCommand</b></a>
 - Gets the gdb command to dump the trace data to a file. Useful for copy-pasting it to the gdb console.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vGetGDBDumpCommand(uint8_t *buf, uint16_t bufSize, uint8_t *fileName)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>buf: Pointer to uint8_t</i> - Pointer to buffer for the command. Make it large enoug (about 64 bytes)</li>
<li><i>bufSize:uint16_t</i> - size of the buffer</li>
<li><i>fileName: Pointer to uint8_t</i> - Pointer to the file name string, e.g. &quot;C:\tmp\trace.dump&quot;</li>
</ul><br />
</li>
<li><a name="vTraceSetStopHook">
<b>vTraceSetStopHook</b></a>
 - Sets a function to be called when the recorder is stopped.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vTraceSetStopHook(TRACE_STOP_HOOK stopHookFunction)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>stopHookFunction:byte</i> - no hint</li>
</ul><br />
</li>
<li><a name="xTraceGetLastError">
<b>xTraceGetLastError</b></a>
 - Gives the last error message, if any. NULL if no error message is stored. Any error message is also presented when opening a trace file.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> char* xTraceGetLastError(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Return value:char*</i> - Error message
</li>
</ul><br />
</li>
<li><a name="vTraceClearError">
<b>vTraceClearError</b></a>
 - Removes any previous error message generated by recorder calling vTraceError. By calling this function, it may be possible to start/restart the trace despite errors in the recorder, but there is no guarantee that the trace recorder will work correctly in that case, depending on the type of error.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> byte vTraceClearError(int resetErrorMessage)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>resetErrorMessage:byte</i> - parameter is not used</li>
<li><i>Return value:byte</i> - Error code
</li>
</ul><br />
</li>
<li><a name="Startup">
<b>Startup</b></a>
 - Routine called during startup. Depending on the mode and settings, it starts tracing and might block!
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void Startup(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
</ul><br />
</li>

           </ul>
<!---USERBEG DON'T CHANGE THIS LINE-->

<!---USEREND DON'T CHANGE THIS LINE-->
<p>
<br />
Note: Some methods can be implemented as macros.
</p>
          </div>
          <p class="footer">
            PROCESSOR EXPERT is trademark of Freescale Semiconductor, Inc.
            <br />
            
          </p>
    </td>
  </tr>

</table>

</body>
</html>

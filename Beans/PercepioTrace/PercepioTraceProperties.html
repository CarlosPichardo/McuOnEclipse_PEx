<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1250">
<title>
Component  documentation - Properties
</title>
<STYLE type="text/css">
body{
  background-color: white;
  margin:0px;
  font: 13px Helvetica Neue, Helvetica, Arial, sans-serif;
}
A:visited {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:link {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:active {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:hover {
	COLOR: #2D8AA7; TEXT-DECORATION: underline
}
.VSP {
	COLOR: #2D8AA7; FONT: bold italic 14px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.reflink {
	FONT: 11px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
 	COLOR: #2D8AA7;
}
.user_text {
	FONT: 12px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
	COLOR: #000000;
}
.bluetext {
  COLOR: #695F52;
}
.versionspec {
  padding:5px; 
  background-color: RGB(243, 242, 230);
  margin-top:5px;
  margin-bottom:5px;  
}
.versionspecdetail {
  padding:5px; 
  background-color: RGB(243, 242, 230);
  margin-top:5px;
  margin-bottom:5px;  
}
.versionspeclabel {
  font-style: italic;
}
LI.DEF {
  list-style-image: url(DefaultLI.gif) ;
}
LI.BAS {
	list-style-image: url(BasicLI.gif) ;
}
LI.ADV {
	list-style-image: url(AdvancedLI.gif) ;
}
LI.EXP {
	list-style-image: url(ExpertLI.gif) ;
}
.titlebox {  
  font: bold 18px Helvetica Neue, Helvetica, Arial, sans-serif;
  color: #51626F;
  margin-bottom: 10px;
}
.lefttitlebox {
  background-color:#C3CFD1;  
}
.lefttitle {
  color:#51626F;
  font: bold 11px Helvetica Neue, Helvetica, Arial, sans-serif;   
}
.beanname {
  font: bold 14px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
  padding-top:6px;
  padding-bottom:5px;
  margin-bottom: 5px;
  border-bottom-style: dotted;
  border-bottom-width: 1;  
}
.descrtext {
  font-style: italic;
  font: 14px/18px Helvetica Neue, Helvetica, Arial, sans-serif;  
  padding-bottom:9px;
}
.footer {
  color: #b0b0b0; 
  font: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
  text-align: center;
  border-top-style: solid;
  border-top-color: #BOBOBO;
  border-top-width: 1px;  
  padding-top: 5px;
  margin-top: 20px;
}
.info_name {
  font: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
  padding: 0px;
  color: black;
}
.info_text {
  font: 11px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.text_title {
  COLOR: #000000; 
  FONT: bold 14px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.descr_line {
  COLOR: gray; 
  FONT: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.code {
  background-color: RGB(243, 242, 230);
  padding: 10px;
  white-space: pre;
  font-family: Courier New, Monospace;
}
</STYLE>

</head>

<body>

<table border="0"  cellspacing="0" cellpadding="0">
  <tr>
    <td valign="top" width="150" >
      <table  width="150" height="160" cellpadding="3" cellspacing="0" border="0">
        <tbody>
        <tr class="lefttitlebox">
          <td width="4"></td>
          <td align="center" valign="middle" height="30" width="128">
            <span class="lefttitle">
<b>PercepioTrace</b>
            </span>
          </td>
        </tr>
        <tr height="700">
          <td width="4"></td>
          <td width="128" valign="top">
            &nbsp;<br />
            <div class="reflink">
<!---HTMLLISTBEG_SHORT DON'T CHANGE THIS LINE-->
<a href="PercepioTrace.html">General Info</a><br />
<i>Properties</i><br />
<a href="PercepioTraceMethods.html">Methods</a><br />
<a href="PercepioTraceEvents.html">Events</a><br />
<!---HTMLLISTEND DON'T CHANGE THIS LINE-->
<br /><br /><br />
<a href="../../DOCs/PredefSymbols.html">Types &amp; definitions</a><br/>
<a href="../../DOCs/BEANindex.html">Component Index</a><br/>
<a href="../../DOCs/CPUindex.html">CPU Component Index</a><br/>
<a href="../../DOCs/EmbeddedBeans.html">Embedded Components</a><br/>
<a href="../../DOCs/BeanCategories.html">Components Categories</a><br/>

<br /><br /><br />
<center>
<img src="PercepioTrace_b.gif" alt="Component icon"/>


</center>
            </div>
          </td>
        </tr>
        </tbody>
      </table>
    </td>
    <td width="1" class="lefttitlebox" valign="top">
      <table class="lefttitlebox" width="1" cellpadding="0" cellspacing="0" height="100%" border="0">
        <tr class="lefttitlebox"><td width="1"></td></tr>
      </table>
    </td>
    <td style="padding-left:15px;padding-right:10px;" valign="top" align="left" width="100%">

<!--      <table border="0" cellPadding="0" cellSpacing="0" width="100%">
        <tbody>
        <tr>
          <td class="titlebox">-->
          
           <div class="titlebox">
              <div class="beanname">
                Component
                
                
                PercepioTrace
              </div>
              <div class="descrtext">Percepio FreeRTOS Trace</div>
              <div class="info_name">Component Level: <span class="info_text"><a href="../../DOCs/BeanCategoriesInfo.html#LevelAbstraction">High</a></span></div>
              <div class="info_name">Category: 
                <span class="info_text">
                <a href="../../DOCs/BeanCategoriesInfo.html">Operating Systems</a>
                
                </span>
              </div>
            </div>
                      
<!--
            </td>
        </tr>

        <tr>        
-->  
            
<!--            <td align="left"> -->
<!--                   <br /> -->                  
     <div class="text_title">
          Properties:
		 </div>		 
		 <div class="descr_line">                  
                  (Properties are parameters of the component. Please see the <a href="../../DOCs/EmbeddedBeans.html">Embedded Components page</a> for more information.)                   
     </div>
                  
<div class="user_text">
<ul>
<li>
<a name="DeviceName">
<b>Component name</b></a> - Name of the component.
</li>
<li>
<a name="RTOSplusTraceVersion">
<b>RTOS+Trace Version</b></a> - Identifies the RTOS+Trace version used from Percepio AB
</li>
<li>
<a name="TraceRecorderMode">
<b>Recorder Mode</b></a> - Configrue TRC_CFG_RECORDER_MODE to TRC_RECORDER_MODE_SNAPSHOT or TRC_RECORDER_MODE_STREAMING<br /><br />
There are 2 options:<br />
<ul>
  <li><u>Snapshot</u>: Does snapshot trace into local RAM buffer for later uploade.</li>
  <li><u>Streaming</u>: Does continuous trace to the host PC.</li>
</ul><br />

</li>
<li>
<a name="RecorderBufferAllocation">
<b>Recorder Buffer Allocation</b></a> - Configure the macro TRC_CFG_RECORDER_BUFFER_ALLOCATION to TRC_RECORDER_BUFFER_ALLOCATION_STATIC, TRC_RECORDER_BUFFER_ALLOCATION_DYNAMIC or TRC_RECORDER_BUFFER_ALLOCATION_CUSTOM. Note that CUSTOM is only supported in snapshot mode.<br /><br />
There are 3 options:<br />
<ul>
  <li><u>static</u>: Static allocation</li>
  <li><u>dynamic</u>: Allocated in vTraceEnable</li>
  <li><u>custom</u>: Use vTraceSetRecorderDataBuffer</li>
</ul><br />

</li>
<li>
<a name="TraceMaxISRNesting">
<b>Max ISR Nesting</b></a> - Defines the maxium level of ISR nesting
</li>
<li>
<a name="EventsCreationGroup">
<b>Events Creation</b></a> - Configures which events are created
<ul>
  <li>
  <a name="IncludeOSTickEvents">
  <b>Include OS Tick events</b></a> - This sets TRC_CFG_INCLUDE_OSTICK_EVENTS. 
  </li>
  <li>
  <a name="IncludeReadyEvents">
  <b>Include ready events</b></a> - This sets INCLUDE_READY_EVENTS in trcConfig.h<br />
If this is set to 'no', the code for recording Ready events is excluded. Note, this will make it impossible to calculate the correct response times.
  </li>
  <li>
  <a name="IncludeMemManageEvents">
  <b>Include memory manager events</b></a> - This sets TRC_CFG_INCLUDE_MEMMANG_EVENTS in trcConfig.h<br />
This must be enabled (1) if memory allocation and deallocatinon have to be traced.
  </li>
  <li>
  <a name="IncludeISRTracing">
  <b>Include ISR tracing</b></a> - This sets INCLUDE_ISR_TRACING in trcConfig.h<br />
If this is zero (0), the code for recording Interrupt Service Routines is excluded to reduce code size. Note, recording ISRs require that you insert calls to vTraceStoreISRBegin and vTraceStoreISREnd in your interrupt handlers. There is no automatic recording of ISRs like for task scheduling, since FreeRTOS does not have a central interrupt dispatcher.
  </li>
  <li>
  <a name="IncludeObjectDelete">
  <b>Include object delete events</b></a> - This sets INCLUDE_OBJECT_DELETE in trcConfig.h<br />
This must be enabled (1) if tasks, queues or other traced kernel objects are deleted at runtime, e.g., using vTaskDelete or vQueueDelete. If no deletes are made, this can be set to 0 in order to exclude the delete-handling code. 
  </li>
  <li>
  <a name="IncludeUserEvents">
  <b>Include user events</b></a> - This sets TRC_CFG_INCLUDE_USER_EVENTS.<br />
If this is zero (0) the code for creating User Events is excluded to reduce code size. User Events are application-generated events, like &quot;printf&quot; but for the trace log instead of console output. User Events are much faster than a printf and can therefore be used in timing critical code. See vTraceUserEvent() and vTracePrintF() in trcUser.h.
  </li>
  <li>
  <a name="IncludePendFuncCallEvents">
  <b>Include pend function call events</b></a> - This sets TRC_CFG_INCLUDE_PEND_FUNC_CALL_EVENTS.<br />
If this is zero (0), the trace will exclude any &quot;pending function call&quot; events, such as xTimerPendFunctionCall().
  </li>
  <li>
  <a name="IncludeEventGroupEvents">
  <b>Include event group events</b></a> - This sets TRC_CFG_INCLUDE_EVENT_GROUP_EVENTS.<br />
If this is zero (0), the trace will exclude any &quot;event group&quot; events.
  </li>
</ul>
</li>
<li>
<a name="SnapshotModeGroup">
<b>Snapshot Mode</b></a> - Settings for Snapshot mode, stored in trcSnapshotConfig.h
<ul>
  <li>
  <a name="trcStartupEnableMethodSnapshot">
  <b>Snapshot trace enable method</b></a> - Chooses which trace init and startup method shall be used while the trace Startup() function gets called during application startup.<br />     Snapshot Mode:<br />        TRC_INIT: Initializes trace module. Application needs to start tracing later with vTraceEnable(TRC_START);<br />        TRC_START: Initializes and starts tracing<br />     Streaming Mode:<br />        TRC_INIT: Initializes trace module. Application needs to start tracing later with vTraceEnable(TRC_START);<br />        TRC_START_AWAIT_HOST: initialies trace module and blocks (waits for data to be retrieved */<br /><br />
There are 2 options:<br />
<ul>
  <li><u>TRC_INIT</u>: Initializes the trace recorder, but does not start the tracing. In snapshot mode, this must be followed by a vTraceEnable(TRC_START) sometime later.</li>
  <li><u>TRC_START</u>: Starts the tracing directly. In snapshot mode this allows for starting the trace at any point in your code, assuming vTraceEnable(TRC_INIT) has been called in the startup.</li>
</ul><br />

  </li>
  <li>
  <a name="RecorderStoreMode">
  <b>Recorder store mode</b></a> - This sets TRC_CFG_SNAPSHOT_MODE.<br /><br />
There are 2 options:<br />
<ul>
  <li><u>Ring Buffer</u>: Using ring buffer</li>
  <li><u>Stop when full</u>: Stops recording when buffer is ful</li>
</ul><br />

  </li>
  <li>
  <a name="TraceSchedulingOnly">
  <b>Scheduling only</b></a> - This defines TRACE_SCHEDULING_ONLY in trcConfig.h<br />
When defined (set to 'yes', disables all events except scheduling. Useful for Free Edition users.
  </li>
  <li>
  <a name="TraceDescriptionString">
  <b>Description string</b></a> - This sets TRACE_DESCRIPTION in trcConfig.h<br />
This string is stored in the trace and displayed in FreeRTOS+Trace. Can be used to store, e.g., system version or build date.
  </li>
  <li>
  <a name="TraceDescriptionMaxLength">
  <b>Description max length</b></a> - Sets the TRACE_DESCRIPTION_MAX_LENGTH macro. Generic system information string, presented in the tool. Note that this is also used for storing any internal error messages from the recorder, so do not make TRACE_DESCRIPTION_MAX_LENGTH too small. 80 is recommended.
  </li>
  <li>
  <a name="EventBufferSize">
  <b>Event buffer size</b></a> - This sets TRC_CFG_EVENT_BUFFER_SIZE.<br />
Macro which should be defined as an integer value.<br />
This defines the capacity of the event buffer, i.e., the number of records it may store. An event typically use one record (4 byte), but there are exceptions:<br />
In some cases, an XTS event is added if the time since the last event is longer that allowed by the current event's timestamp field. Such events thus use two records. vTracePrintF use a variable number of data records following the event, holding the data arguments. <br />
If RECORDER_STORE_MODE is STORE_MODE_RING_BUFFER, the recorder will wrap around to index 0 when reached EVENT_BUFFER_SIZE. If RECORDER_STORE_MODE is STORE_MODE_STOP_WHEN_FULL, the recorder is instead stopped (see RECORDER_STORE_MODE).
  </li>
  <li>
  <a name="SymbolTableSize">
  <b>Symbol table size</b></a> - This sets SYMBOL_TABLE_SIZE in trcConfig.h<br />
Macro which should be defined as an integer value.<br />
This defines the capacity of the symbol table, in bytes. This symbol table stores User Events labels and names of deleted tasks, queues, or other kernel objects. Note that the names of active objects not stored here but in the Object Table. Thus, if you don't use User Events or delete any kernel objects you set this to zero (0) to minimize RAM usage.
  </li>
  <li>
  <a name="traceConfigUseAssert">
  <b>Use Trace Assert</b></a> - Configures TRC_CFG_USE_TRACE_ASSERT. If set to yes, <br />
the TRACE_ASSERT macro (used at various locations in the <br />
trace recorder) will verify that a relevant condition is true. <br />
If the condition is false, prvTraceError() will be called, which stops the<br />
recording and stores an error message that is displayed when opening the<br />
trace in Tracealyzer.<br />
This is used on several places in the recorder code for sanity checks on<br />
parameters. Can be switched off to reduce the footprint of the tracing, but<br />
we recommend to have it enabled initially.
  </li>
  <li>
  <a name="traceConfigISRTailchainingThreshold">
  <b>ISR Tailchaining Threshold</b></a> - Configures TRC_CFG_ISR_TAILCHAINING_THRESHOLD.<br />
If tracing multiple ISRs, this setting allows for accurate display of the <br />
context-switching also in cases when the ISRs execute in direct sequence.
  </li>
  <li>
  <a name="traceConfigUseSeprateUserEventBuffer">
  <b>Separate User Event Buffer</b></a> - Configures TRC_CFG_USE_SEPARATE_USER_EVENT_BUFFER.<br />If set to yes, it enables a separate user event buffer (UB).<br />In this mode, user events are stored separately from other events, <br />e.g., RTOS events. Thereby you can get a much longer history of <br />user events as they don't need to share the buffer space with more <br />frequent events. <br />
The following items are available only if the group is enabled (the value is "Enabled"):<br />

  <ul>
    <li>
    <a name="Symbol0">
    <b>traceConfigSeparateUserEventBufferSize</b></a> - Defines TRC_CFG_SEPARATE_USER_EVENT_BUFFER_SIZE, the capacity of teh user event buffer
    </li>
    <li>
    <a name="traceConfigUserEventBufferChannels">
    <b>User Event Buffer Channels</b></a> - Configures TRC_CFG_UB_CHANNELS. <br />
This defines the number of User Event Buffer Channels (UB channels).<br />
These are used to structure the events when using the separate user<br />
event buffer, and contains both a User Event Channel (the name) and<br />
a default format string for the channel.
    </li>
  </ul>
  </li>
  <li>
  <a name="ObjectsGroup">
  <b>Objects</b></a> - Configures the size of objects in the object property table
  <ul>
    <li>
    <a name="NTask">
    <b>Number of tasks</b></a> - This sets TRC_CFG_NTASK:<br />
A group of Macros which should be defined as an integer value of zero (0) or larger.<br />
This defines the capacity of the Object Table, in number of objects, of each object class. The Object Table holds information about the currently active kernel objects (i.e., the ones that have been created but not terminated), such as name and Tracelayzer ID, for Tasks, Queues, Semaphores, Mutexes and user-registered ISRs.<br />
This does not limit the total amount of objects created, if objects are deleted during runtime. The object table size however limits the number of objects active at any given time, since the slots in the Object Table are reused when objects are deleted.
    </li>
    <li>
    <a name="NameLenTaskStr">
    <b>Name length for task</b></a> - TRC_CFG_NAME_LEN_TASK:<br />
Macros that specify the maximum lengths (number of characters) for names of<br />
kernel objects, such as tasks and queues. If longer names are used, they will<br />
be truncated when stored in the recorder.
    </li>
    <li>
    <a name="NISR">
    <b>Number of ISR</b></a> - This sets TRC_CFG_NISR.<br />
A group of Macros which should be defined as an integer value of zero (0) or larger.<br />
This defines the capacity of the Object Table, in number of objects, of each object class. The Object Table holds information about the currently active kernel objects (i.e., the ones that have been created but not terminated), such as name and Tracelayzer ID, for Tasks, Queues, Semaphores, Mutexes and user-registered ISRs.<br />
This does not limit the total amount of objects created, if objects are deleted during runtime. The object table size however limits the number of objects active at any given time, since the slots in the Object Table are reused when objects are deleted.
    </li>
    <li>
    <a name="NQueue">
    <b>Number of queue</b></a> - This sets TRC_CFG_NQUEUE.<br />
A group of Macros which should be defined as an integer value of zero (0) or larger.<br />
This defines the capacity of the Object Table, in number of objects, of each object class. The Object Table holds information about the currently active kernel objects (i.e., the ones that have been created but not terminated), such as name and Tracelayzer ID, for Tasks, Queues, Semaphores, Mutexes and user-registered ISRs.<br />
This does not limit the total amount of objects created, if objects are deleted during runtime. The object table size however limits the number of objects active at any given time, since the slots in the Object Table are reused when objects are deleted.
    </li>
    <li>
    <a name="NSemaphore">
    <b>Number of semaphore</b></a> - This sets TRC_CFG_NSEMAPHORE.<br />
A group of Macros which should be defined as an integer value of zero (0) or larger.<br />
This defines the capacity of the Object Table, in number of objects, of each object class. The Object Table holds information about the currently active kernel objects (i.e., the ones that have been created but not terminated), such as name and Tracelayzer ID, for Tasks, Queues, Semaphores, Mutexes and user-registered ISRs.<br />
This does not limit the total amount of objects created, if objects are deleted during runtime. The object table size however limits the number of objects active at any given time, since the slots in the Object Table are reused when objects are deleted.
    </li>
    <li>
    <a name="NMutex">
    <b>Number of mutex</b></a> - This sets TRC_CFG_NMUTEX.<br />
A group of Macros which should be defined as an integer value of zero (0) or larger.<br />
This defines the capacity of the Object Table, in number of objects, of each object class. The Object Table holds information about the currently active kernel objects (i.e., the ones that have been created but not terminated), such as name and Tracelayzer ID, for Tasks, Queues, Semaphores, Mutexes and user-registered ISRs.<br />
This does not limit the total amount of objects created, if objects are deleted during runtime. The object table size however limits the number of objects active at any given time, since the slots in the Object Table are reused when objects are deleted.
    </li>
    <li>
    <a name="NTimer">
    <b>Number of timer</b></a> - This sets the TRC_CFG_NTIMER define.
    </li>
    <li>
    <a name="NEventGroup">
    <b>Number of event groups</b></a> - This sets the TRC_CFG_NEVENTGROUP macro.
    </li>
    <li>
    <a name="NStreamBuffers">
    <b>Number of stream buffers</b></a> - This sets the TRC_CFG_NSTREAMBUFFER macro.
    </li>
    <li>
    <a name="NMessageBuffers">
    <b>Number of message buffers</b></a> - This sets the TRC_CFG_NSTREAMBUFFER macro.
    </li>
    <li>
    <a name="NameLenISR">
    <b>Name length for ISR</b></a> - TRC_CFG_NAME_LEN_ISR:<br />
Macros that specify the maximum lengths (number of characters) for names of<br />
kernel objects, such as tasks and queues. If longer names are used, they will<br />
be truncated when stored in the recorder.
    </li>
    <li>
    <a name="NameLenQueue">
    <b>Name length for queue</b></a> - TRC_CFG_NAME_LEN_QUEUE:<br />
Macros that specify the maximum lengths (number of characters) for names of<br />
kernel objects, such as tasks and queues. If longer names are used, they will<br />
be truncated when stored in the recorder.
    </li>
    <li>
    <a name="NameLenSemaphore">
    <b>Name length for semaphore</b></a> - TRC_CFG_NAME_LEN_SEMAPHORE:<br />
Macros that specify the maximum lengths (number of characters) for names of<br />
kernel objects, such as tasks and queues. If longer names are used, they will<br />
be truncated when stored in the recorder.
    </li>
    <li>
    <a name="NameLenMutex">
    <b>Name length for mutex</b></a> - TRC_CFG_NAME_LEN_MUTEX:<br />
Macros that specify the maximum lengths (number of characters) for names of<br />
kernel objects, such as tasks and queues. If longer names are used, they will<br />
be truncated when stored in the recorder.
    </li>
    <li>
    <a name="NameLenTimer">
    <b>Name length for timer</b></a> - TRC_CFG_NAME_LEN_TIMER:<br />
Macros that specify the maximum lengths (number of characters) for names of<br />
kernel objects, such as tasks and queues. If longer names are used, they will<br />
be truncated when stored in the recorder.
    </li>
    <li>
    <a name="NameLenEventGroup">
    <b>Name length for event group</b></a> - TRC_CFG_NAME_LEN_EVENTGROUP:<br />
Macros that specify the maximum lengths (number of characters) for names of<br />
kernel objects, such as tasks and queues. If longer names are used, they will<br />
be truncated when stored in the recorder.
    </li>
    <li>
    <a name="NameLenStreamBuffer">
    <b>Name length for stream buffer</b></a> - TRC_CFG_NAME_LEN_STREAMBUFFER:<br />
Macros that specify the maximum lengths (number of characters) for names of<br />
kernel objects, such as tasks and queues. If longer names are used, they will<br />
be truncated when stored in the recorder.
    </li>
    <li>
    <a name="NameLenMessageBuffer">
    <b>Name length for message buffer</b></a> - TRC_CFG_NAME_LEN_MESSAGEBUFFER:<br />
Macros that specify the maximum lengths (number of characters) for names of<br />
kernel objects, such as tasks and queues. If longer names are used, they will<br />
be truncated when stored in the recorder.
    </li>
  </ul>
  </li>
  <li>
  <a name="HeapSizeBelow16M">
  <b>Heap Size below 16M</b></a> - This sets TRC_CFG_HEAP_SIZE_BELOW_16M:<br />
An integer constant that can be used to reduce the buffer usage of memory<br />
allocation events (malloc/free). This value should be 1 if the heap size is <br />
below 16 MB (2^24 byte), and you can live with addresses truncated to the <br />
lower 24 bit. Otherwise set it to 0 to get the full 32-bit addresses.
  </li>
  <li>
  <a name="floatingPointForvTracePrintF">
  <b>Float support</b></a> - If floating point is supported for vTracePrintF()
  </li>
  <li>
  <a name="UseImplicitIFErules">
  <b>Use implicit IFE rules</b></a> - This sets USE_IMPLICIT_IFE_RULES in trcConfig.h<br />
### Instance Finish Events (IFE) ###<br />
<br />
For tasks with &quot;infinite&quot; main loops (non-terminating tasks), the concept of a task instance has no clear definition, it is an application-specific thing. FreeRTOS+Trace allows you to define Instance Finish Events (IFEs), which marks the point when a task instance ends. The IFE is a blocking kernel call, typically in the main loop of a task which typically reads a message queue, waits for a semaphore or performs an explicit delay.<br />
<br />
If USE_IMPLICIT_IFE_RULES is one (1), the following FreeRTOS kernel calls are considered by default to be IFEs (Implicit IFEs):<br />
 - vTaskDelay<br />
 - vTaskDelayUntil<br />
 - vTaskSuspend<br />
 - xQueueReceive<br />
 - xSemaphoreTake<br />
<br />
However, Implicit IFEs only applies to blocking kernel calls. If an xQueueReceive reads a message without blocking, it does not create a new instance since no blocking occurred.<br />
<br />
Moreover, the actual IFE might sometimes be another blocking call such as xQueueSend or xSemaphoreGive. We therefore allow for user-defined explicit IFEs by calling<br />
       vTraceTaskInstanceIsFinished()<br />
right before the kernel call considered as IFE. This does not create an additional event but instead stores the service code and object handle of the IFE call as properties of the task.<br />
<br />
If using Explicit IFEs and the task also calls an Implicit IFE like vTaskDelay, this may result in additional incorrect task instances. This is solved by disabling the Implicit IFEs for the task, by adding a call to<br />
       vTraceTaskSkipDefaultInstanceFinishedEvents()<br />
in the very beginning of that task. This allows you to combine Explicit IFEs for some tasks with Implicit IFEs for the rest of the tasks, if USE_IMPLICIT_IFE_RULES is 1.<br />
<br />
By setting USE_IMPLICIT_IFE_RULES to zero (0), the implicit IFEs are disabled for all tasks. Tasks will then be considered to have a single instance only, covering all execution fragments, unless you define an explicit IFE in the task.
  </li>
  <li>
  <a name="Use16bitObjectHandles">
  <b>Use 16bit Object Handles</b></a> - This sets USE_16BIT_OBJECT_HANDLES in trcConfig.h<br />
 * Macro which should be defined as either zero (0) or one (1).<br />
 * Default is 0.<br />
 *<br />
 * If set to 0 (zero), the recorder uses 8-bit handles to identify kernel <br />
 * objects such as tasks and queues. This limits the supported number of<br />
 * concurrently active objects to 255 of each type (object class).<br />
 *<br />
 * If set to 1 (one), the recorder uses 16-bit handles to identify kernel <br />
 * objects such as tasks and queues. This limits the supported number of<br />
 * concurrent objects to 65535 of each type (object class). However, since the<br />
 * object property table is limited to 64 KB, the practical limit is about<br />
 * 3000 objects in total. <br />
 * <br />
 * NOTE: An object with a high ID (&gt; 255) will generate an extra event <br />
 * (= 4 byte) in the event buffer. <br />
 * <br />
 * NOTE: Some internal tables in the recorder gets larger when using 16-bit <br />
 * handles. The additional RAM usage is 5-10 byte plus 1 byte per kernel object<br />
 *, i.e., task, queue, semaphore, mutex, etc.
  </li>
</ul>
</li>
<li>
<a name="StreamingModeGroup">
<b>Streaming Mode</b></a> - Settings for streaming mode. For streaming mode the Segger RTT needs to be enabled.
<ul>
  <li>
  <a name="StreamingTraceWithRTT">
  <b>Segger RTT</b></a> - Streaming trace data over Segger RTT. Enable if using Segger RTT for streaming<br />
The following items are available only if the group is enabled (the value is "Enabled"):<br />

  <ul>
    <li>
    <a name="SeggerRTT">
    <b>Segger RTT</b></a> - Interface to Segger RTT
    </li>
  </ul>
  </li>
  <li>
  <a name="trcStartupEnableMethodStreaming">
  <b>Streaming trace enable method</b></a> - Chooses which trace init and startup method shall be used while the trace Startup() function gets called during application startup.<br />     Snapshot Mode:<br />        TRC_INIT: Initializes trace module. Application needs to start tracing later with vTraceEnable(TRC_START);<br />        TRC_START: Initializes and starts tracing<br />     Streaming Mode:<br />        TRC_INIT: Initializes trace module. Application needs to start tracing later with vTraceEnable(TRC_START);<br />        TRC_START_AWAIT_HOST: initialies trace module and blocks (waits for data to be retrieved */<br /><br />
There are 3 options:<br />
<ul>
  <li><u>TRC_INIT</u>: Initializes the trace recorder, but does not start the tracing. In snapshot mode, this must be followed by a vTraceEnable(TRC_START) sometime later.</li>
  <li><u>TRC_START</u>: Starts the tracing directly. In snapshot mode this allows for starting the trace at any point in your code, assuming vTraceEnable(TRC_INIT) has been called in the startup.</li>
  <li><u>TRC_START_AWAIT_HOST</u>: TRC_START_AWAIT_HOST: For streaming mode only. Initializes the trace recorder if necessary and waits for a Start command from Tracealyzer (&quot;Start Recording&quot; button). This call is intentionally blocking! By calling vTraceEnable with this option from the startup code, you start tracing at this point and capture the early events.</li>
</ul><br />

  </li>
  <li>
  <a name="RTTUpBufferIndex">
  <b>Up Buffer Index</b></a> - RTT_UP_BUFFER_INDEX: Defines the RTT buffer to use for writing the trace data. Make sure that the PC application has the same setting (File-&gt;Settings).
  </li>
  <li>
  <a name="TraceRTTUpBufferSize">
  <b>Up Buffer Size</b></a> - Up Buffer Size (default 1024), only applicable for buffer index &gt; 0
  </li>
  <li>
  <a name="RTTDownBufferIndex">
  <b>Down Buffer Index</b></a> - RTT_DOWN_BUFFER_INDEX: Defines the RTT buffer to use for reading the trace data. Make sure that the PC application has the same setting (File-&gt;Settings).
  </li>
  <li>
  <a name="TraceRTTDownBufferSize">
  <b>Down Buffer Size</b></a> - Down Buffer Size (default 32), only applicable for buffer index &gt; 0
  </li>
  <li>
  <a name="SymbolTableSlots">
  <b>Symbol Table Slots</b></a> - SYMBOL_TABLE_SLOTS: The maximum number of symbols names that can be stored. This includes task names, named ISR's, named kernel objects and user event channels.
  </li>
  <li>
  <a name="SymbolMaxLength">
  <b>Symbol Max Length</b></a> - SYMBOL_MAX_LENGTH: The maximum length of symbol names.
  </li>
  <li>
  <a name="ObjectDataSlots">
  <b>Object Data Slots</b></a> - OBJECT_DATA_SLOTS: The maximum number of object data entries (used for task priorities) that can be stored at the same time. Must be sufficient for all tasks, otherwise there will be warnings (as User Events) from TzCtrl task, that monitors this.
  </li>
  <li>
  <a name="CtrlTaskPrioStr">
  <b>Ctrl Task Priority</b></a> - Configures TRC_CFG_CTRL_TASK_PRIORITY, the priority of the Ctrl task which streams the data. Priority can be rather low, except if your system load is very high, then use (configMAX_PRIORITIES-1)
  </li>
  <li>
  <a name="CtrlTaskStackSize">
  <b>Ctrl Task Stack Size</b></a> - CTRL_TASK_STACK_SIZE: The stack size of the Ctrl task, that receive commands.
  </li>
  <li>
  <a name="CtrlTaskDelay">
  <b>Ctrl Task Delay</b></a> - Configures TRC_CFG_CTRL_TASK_DELAY, the delay between every loop of the TzCtrl task. A high delay will reduce the CPU load, but may cause missed events if the TzCtrl task is performing the trace transfer.
  </li>
</ul>
</li>
<li>
<a name="SourceFolderGroup">
<b>Source Folders</b></a> - Settings to configure into which folders the sources shall be generated.<br />
The following items are available only if the group is enabled (the value is "Enabled"):<br />

<ul>
  <li>
  <a name="TraceRecorderFolderName">
  <b>Recorder</b></a> - Main folder of the trace recorder
  </li>
  <li>
  <a name="TraceRecorderConfigFolderName">
  <b>Config</b></a> - Folder for the configuration files
  </li>
  <li>
  <a name="TraceRecorderIncludeFolderName">
  <b>Include</b></a> - Folder for the include files
  </li>
  <li>
  <a name="TraceRecorderRTTIncludeFolderName">
  <b>RTT Include</b></a> - Folder for the RTT include files
  </li>
</ul>
</li>
<li>
<a name="SystemGroup">
<b>System</b></a> - Link to system interfaces
<ul>
  <li>
  <a name="sdk">
  <b>SDK</b></a> - Link to SDK
  </li>
  <li>
  <a name="Utility">
  <b>Utility</b></a> - Interface to utility functions
  </li>
</ul>
</li>

     </ul>
<!---USERBEG DON'T CHANGE THIS LINE-->

<!---USEREND DON'T CHANGE THIS LINE-->
</div>
           <p class="footer">
            PROCESSOR EXPERT is trademark of Freescale Semiconductor, Inc.
            <br />
            
           </p>
    </td>
  </tr>

</table>

</body>
</html>

<?xml version="1.0" encoding="UTF-8"?>
<Interface>
  <Name>HWI2C</Name>
  <Description>Interface "FreeRTOSTrace\HWI2C" for component FreeRTOSTrace, generated by Component Wizard</Description>
  <Author>Author</Author>
  <Version>01.009</Version>
  <FileVersion>2</FileVersion>
  <MethodList>
    <Method>
      <TMthdItem>
        <Name>SendChar</Name>
        <Symbol>SendChar</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>When working as a MASTER, this method writes one (7-bit addressing) or two (10-bit addressing) slave address bytes inclusive of R/W bit = 0 to the I2C bus and then writes one character (byte) to the bus. The slave address must be specified before, by the "SelectSlave" or "SelectSlave10" method or in the component initialization section, "Target slave address init" property. If interrupt service is enabled and the method returns ERR_OK, it doesn't mean that transmission was successful. The state of transmission is obtainable from (OnTransmitData, OnError or OnArbitLost) events.\n
&lt;br/&gt;When working as a SLAVE, this method writes a character to the internal output slave buffer and, after the master starts the communication, to the I2C bus. If no character is ready for a transmission (internal output slave buffer is empty), the Empty character will be sent (see "Empty character" property).</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code, possible codes:\n     ERR_OK - OK\n     ERR_SPEED - This device does not work in the active speed mode\n     ERR_DISABLED -  Device is disabled\n     ERR_BUSY - The slave device is busy, it does not respond by an acknowledge (only in master mode and when interrupt service is disabled)\n     ERR_BUSOFF - Clock timeout elapsed or device cannot transmit data\n\n     ERR_TXFULL - Transmitter is full (slave mode only)\n     ERR_ARBITR - Arbitration lost (only when interrupt service is disabled and in master mode)</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>Chr</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Character to send.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(byte Chr)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>RecvChar</Name>
        <Symbol>RecvChar</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>When working as a MASTER, this method writes one (7-bit addressing) or two (10-bit addressing) slave address bytes inclusive of R/W bit = 1 to the I2C bus, then reads one character (byte) from the bus and then sends the stop condition. The slave address must be specified before, by the "SelectSlave" or "SelectSlave10" method or in component initialization section, property "Target slave address init". If interrupt service is enabled and the method returns ERR_OK, it doesn't mean that transmission was finished successfully. The state of transmission must be tested by means of events (OnReceiveData, OnError or OnArbitLost). In case of successful transmission, received data is ready after OnReceiveData event is called.\n
&lt;br/&gt;When working as a SLAVE, this method reads a character from the input slave buffer.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code, possible codes:\n     ERR_OK - OK\n     ERR_SPEED - This device does not work in the active speed mode\n     ERR_DISABLED -  Device is disabled\n     ERR_BUSY - The slave device is busy, it does not respond by the acknowledge (only in master mode and when interrupt service is disabled)\n     ERR_BUSOFF - Clock timeout elapsed or device cannot receive data\n     ERR_RXEMPTY - No data in receiver (slave mode only)\n     ERR_OVERRUN - Overrun error was detected from the last character or block received (slave mode only)\n     ERR_ARBITR - Arbitration lost (only when interrupt service is disabled and in master mode)\n     ERR_NOTAVAIL - Method is not available in current mode - see the comment in the generated code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>Chr</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Received character.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(byte *Chr)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendBlock</Name>
        <Symbol>SendBlock</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>When working as a MASTER, this method writes one (7-bit addressing) or two (10-bit addressing) slave address bytes inclusive of R/W bit = 0 to the I2C bus and then writes the block of characters to the bus. The slave address must be specified before, by the "SelectSlave" or "SlaveSelect10" method or in component initialization section, "Target slave address init" property. If interrupt service is enabled and the method returns ERR_OK, it doesn't mean that transmission was successful. The state of transmission is detectable by means of events (OnTransmitData, OnError or OnArbitLost). Data to be send is not copied to an internal buffer and remains in the original location. Therefore the content of the buffer should not be changed until the transmission is complete. Event OnTransmitData can be used to detect the end of the transmission.&lt;br/&gt;\n
When working as a SLAVE, this method writes a block of characters to the internal output slave buffer and then, after the master starts the communication, to the I2C bus. If no character is ready for a transmission (internal output slave buffer is empty), the "Empty character" will be sent (see "Empty character" property). In SLAVE mode the data are copied to an internal buffer, if specified by "Output buffer size" property.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code, possible codes:\n     ERR_OK - OK\n     ERR_SPEED - This device does not work in the active speed mode\n     ERR_DISABLED -  Device is disabled\n     ERR_BUSY - The slave device is busy, it does not respond by the acknowledge (only in master mode and when interrupt service is disabled)\n     ERR_BUSOFF - Clock timeout elapsed or device cannot transmit data\n     ERR_TXFULL - Transmitter is full. Some data has not been sent. (slave mode only)\n     ERR_ARBITR - Arbitration lost (only when interrupt service is disabled and in master mode)</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>Ptr</ParName>
          <ParType>pointer</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to the block of data to send.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>Siz</ParName>
          <ParType>16bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Size of the block.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>Snt</ParName>
          <ParType>16bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Amount of data sent (moved to a buffer). In master mode, if interrupt support is enabled, the parameter always returns the same value as the parameter 'Siz' of this method.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(void* Ptr, word Siz, word *Snt)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>RecvBlock</Name>
        <Symbol>RecvBlock</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>When working as a MASTER, this method writes one (7-bit addressing) or two (10-bit addressing) slave address bytes inclusive of R/W bit = 1 to the I2C bus, then reads the block of characters from the bus and then sends the stop condition. The slave address must be specified before, by the "SelectSlave" or "SelectSlave10" method or in component initialization section, "Target slave address init" property. If interrupt service is enabled and the method returns ERR_OK, it doesn't mean that transmission was finished successfully. The state of transmission must be tested by means of events (OnReceiveData, OnError or OnArbitLost). In case of successful transmission, received data is ready after OnReceiveData event is called.\n
&lt;br/&gt;When working as a SLAVE, this method reads a block of characters from the input slave buffer.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code, possible codes:\n     ERR_OK - OK\n     ERR_SPEED - This device does not work in the active speed mode\n     ERR_DISABLED -  Device is disabled\n     ERR_BUSY - The slave device is busy, it does not respond by an acknowledge (only in master mode and when interrupt service is disabled)\n     ERR_BUSOFF - Clock timeout elapsed or device cannot receive data\n     ERR_RXEMPTY - The receive buffer didn't contain the requested number of data. Only available data (or no data) has been returned  (slave mode only).\n     ERR_OVERRUN - Overrun error was detected from last character or block receiving (slave mode only)\n     ERR_ARBITR - Arbitration lost (only when interrupt service is disabled and in master mode)\n     ERR_NOTAVAIL - Method is not available in current mode - see the comment in the generated code.</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>Ptr</ParName>
          <ParType>pointer</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A pointer to the block space for received data.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>Siz</ParName>
          <ParType>16bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The size of the block.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>Rcv</ParName>
          <ParType>16bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Amount of received data. In master mode, if interrupt support is enabled, the parameter always returns the same value as the parameter 'Siz' of this method.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(void* Ptr, word Siz, word *Rcv)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SelectSlave</Name>
        <Symbol>SelectSlave</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>This method selects a new slave for communication by its 7-bit slave address value. Any send or receive method directs to or from selected device, until a new slave device is selected by this method. This method is not available for the SLAVE mode.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code, possible codes:\n     ERR_OK - OK\n     ERR_BUSY - The device is busy, wait until the current operation is finished.\n     ERR_SPEED - This device does not work in the active speed mode\n     ERR_DISABLED -  The device is disabled</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>Slv</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>7-bit slave address value.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(byte Slv)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SelectSlave10</Name>
        <Symbol>SelectSlave10</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>This method selects a new slave for communication by its 10-bit slave address value. Any send or receive method directs to or from selected device, until a new slave device is selected by this method. This method is not available for the SLAVE mode.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_?Exist</Mode>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code, possible codes:\n     ERR_OK - OK\n     ERR_BUSY - The device is busy, wait until the current operation is finished.\n     ERR_SPEED - This device does not work in the active speed mode\n     ERR_DISABLED -  The device is disabled</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>Slv</ParName>
          <ParType>16bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>10-bit slave address value.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(word Slv)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SelectSpecialCommand</Name>
        <Symbol>SelectSpecialCommand</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>This method selects a special command. Any send or receive method directs to or from selected device, until a new slave device is selected by this method. This method is not available for the SLAVE mode. Certain commands may not be supported on a specific derivative, if IIC module does not have the capability.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_?Exist</Mode>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code, possible codes:\n     ERR_OK - OK\n     ERR_BUSY - The device is busy, wait until the current operation is finished.\n     ERR_SPEED - This device does not work in the active speed mode\n     ERR_DISABLED -  The device is disabled\n     ERR_RANGE -  Requested command is not supported.</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>Cmd</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Special command. Possible values:\n     0 - General call address\n     1 - Start byte</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(byte Cmd)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>GetSelected</Name>
        <Symbol>GetSelected</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>This method returns 7-bit slave address value of the slave, which is currently selected for communication with the master. This method is not available for the SLAVE mode.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code, possible codes:\n     ERR_OK - OK\n     ERR_SPEED - This device does not work in the active speed mode</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>Slv</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Current selected slave address value.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(byte *Slv)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>GetSelected10</Name>
        <Symbol>GetSelected10</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>This method returns 10-bit slave address value of the slave, which is currently selected for communication with the master. This method is not available for the SLAVE mode.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_?Exist</Mode>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code, possible codes:\n     ERR_OK - OK\n     ERR_SPEED - This device does not work in the active speed mode</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>Slv</ParName>
          <ParType>16bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Current selected slave address value (16. bit value).</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(word *Slv)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
  </MethodList>
  <EventList>
    <EmptySection_DummyValue/>
  </EventList>
  <Registration>
    <Template>HWI2C</Template>
  </Registration>
  <UserTypes>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>TTxAbortStatus</Name>
      <Hint>Status flags. For languages which don't support bit access is byte or word (depend on CPU) access only to status flags possible.</Hint>
      <Generate>yes</Generate>
      <Unique>yes</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>typedef union {\n
  word status;\n
  struct {\n
    bool Address7NACK    : 1;   /* Abort 7B address No Acknowledge */\n
    bool Address1NACK    : 1;   /* Abort 10B address1 No Acknowledge */\n
    bool Address2NACK    : 1;   /* Abort 10B address2 No Acknowledge */\n
    bool TxDataNACK      : 1;   /* Abort transmit data No Acknowledge */\n
    bool GeneralCallNACK : 1;   /* Abort General call No Acknowledge */\n
    bool GeneralCallRead : 1;   /* Abort General call read */\n
    bool                 : 1;\n
    bool StartByteACK    : 1;   /* Abort Start byte Acknowledge detect */\n
    bool                 : 1;\n
    bool StartByteNoRST  : 1;   /* Abort Start byte no repeated start */\n
    bool Read10BNoRST    : 1;   /* Abort 10B read no repeated start */\n
    bool MasterDisabled  : 1;   /* Abort Master disabled */\n
    bool ArbitLost       : 1;   /* Arbitration lost */\n
    bool SlavelushtxFIFO : 1;   /* Abort Slave flush Tx FIFO */\n
    bool SlaveArbitLost  : 1;   /* Slave arbitration lost */\n
    bool SlaveReadInTx   : 1;   /* Abort Slave read in transmit */\n
  } statusName;\n
} %'ModuleName'_TTxAbortStatus; /* Status flags. For languages which don't support bit access is byte or word (depend on CPU) access only to status flags possible. */\n
</PreparedHint>
      <Specific>&lt;!---VER_SPEC ~~ ^^ |56F802x,56F803x| DON'T CHANGE THIS LINE--&gt;</Specific>
      <Type>typedef union {\n
  word status;\n
  struct {\n
    bool Address7NACK    : 1;   /* Abort 7B address No Acknowledge */\n
    bool Address1NACK    : 1;   /* Abort 10B address1 No Acknowledge */\n
    bool Address2NACK    : 1;   /* Abort 10B address2 No Acknowledge */\n
    bool TxDataNACK      : 1;   /* Abort transmit data No Acknowledge */\n
    bool GeneralCallNACK : 1;   /* Abort General call No Acknowledge */\n
    bool GeneralCallRead : 1;   /* Abort General call read */\n
    bool                 : 1;\n
    bool StartByteACK    : 1;   /* Abort Start byte Acknowledge detect */\n
    bool                 : 1;\n
    bool StartByteNoRST  : 1;   /* Abort Start byte no repeated start */\n
    bool Read10BNoRST    : 1;   /* Abort 10B read no repeated start */\n
    bool MasterDisabled  : 1;   /* Abort Master disabled */\n
    bool ArbitLost       : 1;   /* Arbitration lost */\n
    bool SlavelushtxFIFO : 1;   /* Abort Slave flush Tx FIFO */\n
    bool SlaveArbitLost  : 1;   /* Slave arbitration lost */\n
    bool SlaveReadInTx   : 1;   /* Abort Slave read in transmit */\n
  } statusName;\n
} %'ModuleName'_TTxAbortStatus;</Type>
      <HWTestType>pointer</HWTestType>
    </Type>
  </UserTypes>
</Interface>

<?xml version="1.0" encoding="UTF-8"?>
<Interface>
  <Name>RTOS</Name>
  <Description>Interface "FAT_FileSystem\RTOS" for component FAT_FileSystem, generated by Component Wizard</Description>
  <Author>Erich Styger</Author>
  <Version>01.002</Version>
  <FileVersion>2</FileVersion>
  <MethodList>
    <Method>
      <TMthdItem>
        <Name>xSemaphoreCreateMutex</Name>
        <Symbol>xSemaphoreCreateMutex</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro that creates a mutex semaphore by using the existing queue mechanism.\n
\n
Mutexes created using this macro can be accessed using the xSemaphoreTake() and xSemaphoreGive() macros. The xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros should not be used.\n
\n
Mutexes and binary semaphores are very similar but have some subtle differences: Mutexes include a priority inheritance mechanism, binary semaphores do not. This makes binary semaphores the better choice for implementing synchronisation (between tasks or between tasks and an interrupt), and mutexes the better choice for implementing simple mutual exclusion.\n
\n
The priority of a task that 'takes' a mutex can potentially be raised if another task of higher priority attempts to obtain the same mutex. The task that owns the mutex 'inherits' the priority of the task attempting to 'take' the same mutex. This means the mutex must always be 'given' back - otherwise the higher priority task will never be able to obtain the mutex, and the lower priority task will never 'disinherit' the priority. An example of a mutex being used to implement mutual exclusion is provided on the xSemaphoreTake() documentation page.\n
\n
A binary semaphore need not be given back once obtained, so task synchronisation can be implemented by one task/interrupt continuously 'giving' the semaphore while another continuously 'takes' the semaphore. This is demonstrated by the sample code on the xSemaphoreGiveFromISR() documentation page.\n
\n
Both mutex and binary semaphores are assigned to variables of type xSemaphoreHandle and can be used in any API function that takes a parameter of this type. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>xSemaphoreHandle</ReturnType>
        <RetHint>Handle to the created mutex semaphore.  Should be of type  xSemaphoreHandle.</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>xSemaphoreHandle #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xSemaphoreTake</Name>
        <Symbol>xSemaphoreTake</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro to obtain a semaphore. The semaphore must have previously been created with a call to vSemaphoreCreateBinary(), xSemaphoreCreateMutex() or xSemaphoreCreateCounting().\n
\n
This macro must not be called from an ISR. xQueueReceiveFromISR() can be used to take a semaphore from within an interrupt if required, although this would not be a normal operation. Semaphores use queues as their underlying mechanism, so functions are to some extent interoperable.\n
\n
xSemaphoreTake() is part of the fully featured intertask communications API. xSemaphoreAltTake() is the alternative API equivalent. Both versions require the same parameters and return the same values.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>Boolean</ReturnType>
        <RetHint>Returns pdTRUE if the semaphore was obtained.  pdFALSE if xBlockTime expired without the semaphore becoming available.</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>xMutex</ParName>
          <ParType>xSemaphoreHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A handle to the mutex being obtained.  This is the handle returned by xSemaphoreCreateMutex();</ParHint>
        </Parameter>
        <Parameter>
          <ParName>xBlockTime</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The time in ticks to wait for the semaphore to become available.  The macro portTICK_RATE_MS can be used to convert this to a real time.  A block time of zero can be used to poll the semaphore.  If the task already owns the semaphore then xSemaphoreTakeRecursive() will return immediately no matter what the value of xBlockTime. Specifying the block time as portMAX_DELAY will cause the task to block indefinitely (without a timeout).</ParHint>
          <ParUserDeclaration>portTickType xBlockTime</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>bool #M#_#C#(xSemaphoreHandle xMutex, portTickType xBlockTime)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xSemaphoreGive</Name>
        <Symbol>xSemaphoreGive</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro to release a semaphore. The semaphore must have previously been created with a call to vSemaphoreCreateBinary(), xSemaphoreCreateMutex() or xSemaphoreCreateCounting(), and obtained using sSemaphoreTake().\n
\n
This must not be used from an ISR. See xSemaphoreGiveFromISR() for an alternative which can be used from an ISR.\n
\n
This macro must also not be used on semaphores created using xSemaphoreCreateRecursiveMutex().\n
\n
xSemaphoreGive() is part of the fully featured intertask communications API. xSemaphoreAltGive() is the alternative API equivalent. Both versions require the same parameters and return the same values. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>Boolean</ReturnType>
        <RetHint>Returns pdTRUE if the semaphore was given.</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xMutex</ParName>
          <ParType>xSemaphoreHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A handle to the mutex being released, or 'given'.  This is the handle returned by xSemaphoreCreateMutex();</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>bool #M#_#C#(xSemaphoreHandle xMutex)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
  </MethodList>
  <EventList>
    <EmptySection_DummyValue/>
  </EventList>
  <Registration>
    <Template>RTOS</Template>
    <Template>FreeRTOS</Template>
  </Registration>
  <UserTypes>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>xTaskHandle</Name>
      <Hint/>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>\n
</PreparedHint>
      <Type/>
      <HWTestType/>
    </Type>
    <Type>
      <UsrType>TRetypeType</UsrType>
      <Name>portBASE_TYPE</Name>
      <Hint/>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>  typedef int16_t portBASE_TYPE ;\n
</PreparedHint>
      <Type>16bit signed</Type>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>unsigned_portBASE_TYPE</Name>
      <Hint/>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>typedef unsigned_portBASE_TYPE unsigned portBASE_TYPE;\n
</PreparedHint>
      <Type>typedef unsigned_portBASE_TYPE unsigned portBASE_TYPE;</Type>
      <HWTestType/>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>xSemaphoreHandle</Name>
      <Hint/>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>\n
</PreparedHint>
      <Type/>
      <HWTestType/>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>signed_portBASE_TYPE</Name>
      <Hint/>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>typedef unsigned_portBASE_TYPE unsigned portBASE_TYPE;\n
</PreparedHint>
      <Type>typedef unsigned_portBASE_TYPE unsigned portBASE_TYPE;</Type>
      <HWTestType/>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>pVoid</Name>
      <Hint>pointer to void</Hint>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>typedef void* pVoid; /* pointer to void */\n
</PreparedHint>
      <Type>typedef void* pVoid;</Type>
      <HWTestType/>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>portTickType</Name>
      <Hint/>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>\n
</PreparedHint>
      <Type/>
      <HWTestType/>
    </Type>
  </UserTypes>
</Interface>

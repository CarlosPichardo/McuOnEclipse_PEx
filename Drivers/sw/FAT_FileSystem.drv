%-Driver generated by the Bean Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Bean Wizard
%- If you change these lines, Bean Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    21.07.2009
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%include FatFS_Files.prg
%-
%INTERFACE
%define! Settings Common\FAT_FileSystemSettings.Inc
%define! Abstract Common\FAT_FileSystemAbstract.Inc
%include Common\Header.h

/* Wrappers to FatFS types and constants */
#define %'ModuleName'%.FATFS            FATFS
#define %'ModuleName'%.DIR              DIR
#define %'ModuleName'%.FIL              FIL
#define %'ModuleName'%.FILINFO          FILINFO
#define %'ModuleName'%.FS_READONLY      _FS_READONLY
#define %'ModuleName'%.USE_LFN          _USE_LFN
#define %'ModuleName'%.MAX_LFN          _MAX_LFN
#define %'ModuleName'%.FS_REENTRANT     _FS_REENTRANT
#define %'ModuleName'%.MAX_SS           _MAX_SS
#define %'ModuleName'%.FS_RPATH         _FS_RPATH
#define %'ModuleName'%.FRESULT          FRESULT
#define %'ModuleName'%.DRESULT          DRESULT

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
#include "ff.h"
#include "diskio.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"
%include sw\CommonSupport.prg

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

#ifndef __BWUserType_%'ModuleName'_CHARP
#define __BWUserType_%'ModuleName'_CHARP
  typedef char * %'ModuleName'%.CHARP;                           %>40/* alias to a char pointer */
#endif
#ifndef __BWUserType_%'ModuleName'_INT
#define __BWUserType_%'ModuleName'_INT
  typedef int %'ModuleName'%.INT;                                %>40/* alias to int type. */
#endif

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;

%-BW_CUSTOM_USERTYPE_END


%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN open
%ifdef open
#define %'ModuleName'%.%open(fp, path, mode) \
  f_open(fp, path, mode)
%define! Parfp
%define! Parpath
%define! Parmode
%define! RetVal
%include Common\FAT_FileSystemopen.Inc

%endif %- open
%-BW_METHOD_END open
%-************************************************************************************************************
%-BW_METHOD_BEGIN close
%ifdef close
#define %'ModuleName'%.%close(fp) \
  f_close(fp)

%define! Parfp
%define! RetVal
%include Common\FAT_FileSystemclose.Inc

%endif %- close
%-BW_METHOD_END close
%-************************************************************************************************************
%-BW_METHOD_BEGIN read
%ifdef read
#define %'ModuleName'%.%read(fp, buff, btr, br) \
  f_read(fp, buff, btr, br)

%define! Parfp
%define! Parbuff
%define! Parbtr
%define! Parbr
%define! RetVal
%include Common\FAT_FileSystemread.Inc

%endif %- read
%-BW_METHOD_END read
%-************************************************************************************************************
%-BW_METHOD_BEGIN write
%ifdef write
#define %'ModuleName'%.%write(fp, buff, btw, bw) \
  f_write(fp, buff, btw, bw)

%define! Parfp
%define! Parbuff
%define! Parbtw
%define! Parbw
%define! RetVal
%include Common\FAT_FileSystemwrite.Inc

%endif %- write
%-BW_METHOD_END write
%-************************************************************************************************************
%-BW_METHOD_BEGIN opendir
%ifdef opendir
#define %'ModuleName'%.%opendir(dj, path) \
  f_opendir(dj, path)

%define! Pardj
%define! Parpath
%define! RetVal
%include Common\FAT_FileSystemopendir.Inc

%endif %- opendir
%-BW_METHOD_END opendir
%-************************************************************************************************************
%-BW_METHOD_BEGIN readdir
%ifdef readdir
#define %'ModuleName'%.%readdir(dj, fno) \
  f_readdir(dj, fno)

%define! Pardir
%define! Parfno
%define! RetVal
%include Common\FAT_FileSystemreaddir.Inc

%endif %- readdir
%-BW_METHOD_END readdir
%-************************************************************************************************************
%-BW_METHOD_BEGIN lseek
%ifdef lseek
#define %'ModuleName'%.%lseek(fp, ofs) \
  f_lseek(fp, ofs)

%define! Parfp
%define! Parofs
%define! RetVal
%include Common\FAT_FileSystemlseek.Inc

%endif %- lseek
%-BW_METHOD_END lseek
%-************************************************************************************************************
%-BW_METHOD_BEGIN unlink
%ifdef unlink
#define %'ModuleName'%.%unlink(path) \
  f_unlink(path)

%define! Parpath
%define! RetVal
%include Common\FAT_FileSystemunlink.Inc

%endif %- unlink
%-BW_METHOD_END unlink
%-************************************************************************************************************
%-BW_METHOD_BEGIN mount
%ifdef mount
#define %'ModuleName'%.%mount(vol, fs) \
  f_mount(vol, fs)

%define! Parvol
%define! Parfs
%define! RetVal
%include Common\FAT_FileSystemmount.Inc

%endif %- mount
%-BW_METHOD_END mount
%-************************************************************************************************************
%-BW_METHOD_BEGIN getfree
%ifdef getfree
#define %'ModuleName'%.getfree(path, nclst, fs) f_getfree(path, nclst, fs)
%define! Parpath
%define! Parnclst
%define! Parfatfs
%define! RetVal
%include Common\FAT_FileSystemgetfree.Inc

%endif %- getfree
%-BW_METHOD_END getfree
%-************************************************************************************************************
%-BW_METHOD_BEGIN sync
%ifdef sync
#define %'ModuleName'%.%sync(fp) \
  f_sync(fp)

%define! Parfp
%define! RetVal
%include Common\FAT_FileSystemsync.Inc

%endif %- sync
%-BW_METHOD_END sync
%-************************************************************************************************************
%-BW_METHOD_BEGIN rename
%ifdef rename
#define %'ModuleName'%.%rename(path_old, path_new) \
  f_rename(path_old, path_new)
%define! Parpath_old
%define! Parpath_new
%define! RetVal
%include Common\FAT_FileSystemrename.Inc

%endif %- rename
%-BW_METHOD_END rename
%-************************************************************************************************************
%-BW_METHOD_BEGIN isWriteProtected
%ifdef isWriteProtected
#define %'ModuleName'%.%isWriteProtected() \
%if WriteEnabled='no'
  %'ModuleName'%.FS_READONLY
%else
  %@Memory@'ModuleName'%.isWriteProtected()
%endif

%define! RetVal
%include Common\FAT_FileSystemisWriteProtected.Inc

%endif %- isWriteProtected
%-BW_METHOD_END isWriteProtected
%-************************************************************************************************************
%-BW_METHOD_BEGIN mkdir
%ifdef mkdir
#define %'ModuleName'%.%mkdir(path) \
  f_mkdir(path)
%define! Parpath
%define! RetVal
%include Common\FAT_FileSystemmkdir.Inc

%endif %- mkdir
%-BW_METHOD_END mkdir
%-************************************************************************************************************
%-BW_METHOD_BEGIN chmod
%ifdef chmod
#define %'ModuleName'%.%chmod(FileName, Attribute, AttributeMask) \
  f_chmod(FileName, Attribute, AttributeMask)

%define! ParFileName
%define! ParAttribute
%define! ParAttributeMask
%define! RetVal
%include Common\FAT_FileSystemchmod.Inc

%endif %- chmod
%-BW_METHOD_END chmod
%-************************************************************************************************************
%-BW_METHOD_BEGIN truncate
%ifdef truncate
#define %'ModuleName'%.%truncate(FILP) \
  f_truncate(FILP)

%define! ParFileObject
%define! RetVal
%include Common\FAT_FileSystemtruncate.Inc

%endif %- truncate
%-BW_METHOD_END truncate
%-************************************************************************************************************
%-BW_METHOD_BEGIN stat
%ifdef stat
#define %'ModuleName'%.%stat(FileName, FileInfo) \
  f_stat(FileName, FileInfo)

%define! ParFileName
%define! ParFileInfo
%define! RetVal
%include Common\FAT_FileSystemstat.Inc

%endif %- stat
%-BW_METHOD_END stat
%-************************************************************************************************************
%-BW_METHOD_BEGIN utime
%ifdef utime
#define %'ModuleName'%.%utime(FileName, TimeDate) \
  f_utime(FileName, TimeDate)

%define! ParFileName
%define! ParTimeDate
%define! RetVal
%include Common\FAT_FileSystemutime.Inc

%endif %- utime
%-BW_METHOD_END utime
%-************************************************************************************************************
%-BW_METHOD_BEGIN mkfs
%ifdef mkfs
#define %'ModuleName'%.%mkfs(drive, PartitioningRule, AllocSize) \
  f_mkfs(drive, PartitioningRule, AllocSize)

%define! Pardrive
%define! ParPartitioningRule
%define! ParAllocSize
%define! RetVal
%include Common\FAT_FileSystemmkfs.Inc

%endif %- mkfs
%-BW_METHOD_END mkfs
%-************************************************************************************************************
%-BW_METHOD_BEGIN forward
%ifdef forward
#define %'ModuleName'%.%forward(FileObject, Func, ByteToFwd, ByteFwd) \
  f_forward(FileObject, Func, ByteToFwd, ByteFwd)

%define! ParFileObject
%define! ParFunc
%define! ParByteToFwd
%define! ParByteFwd
%define! RetVal
%include Common\FAT_FileSystemforward.Inc

%endif %- forward
%-BW_METHOD_END forward
%-************************************************************************************************************
%-BW_METHOD_BEGIN chdir
%ifdef chdir
#define %'ModuleName'%.%chdir(Path) \
  f_chdir(Path)

%define! ParPath
%define! RetVal
%include Common\FAT_FileSystemchdir.Inc

%endif %- chdir
%-BW_METHOD_END chdir
%-************************************************************************************************************
%-BW_METHOD_BEGIN chdrive
%ifdef chdrive
#define %'ModuleName'%.%chdrive(Drive) \
  f_chdrive(Drive)

%define! ParDrive
%define! RetVal
%include Common\FAT_FileSystemchdrive.Inc

%endif %- chdrive
%-BW_METHOD_END chdrive
%-************************************************************************************************************
%-BW_METHOD_BEGIN getcwd
%ifdef getcwd
#define %'ModuleName'%.%getcwd(Buffer, BufferLen) \
  f_getcwd(Buffer, BufferLen)

%define! ParBuffer
%define! ParBufferLen
%define! RetVal
%include Common\FAT_FileSystemgetcwd.Inc

%endif %- getcwd
%-BW_METHOD_END getcwd
%-************************************************************************************************************
%-BW_METHOD_BEGIN errFResultMsg
%ifdef errFResultMsg
char* %'ModuleName'%.%errFResultMsg(int errNo);
%define! ParerrNo
%define! RetVal
%include Common\FAT_FileSystemerrFResultMsg.Inc

%endif %- errFResultMsg
%-BW_METHOD_END errFResultMsg
%-************************************************************************************************************
%-BW_METHOD_BEGIN errDResultMsg
%ifdef errDResultMsg
char* %'ModuleName'%.%errDResultMsg(int errNo);
%define! ParerrNo
%define! RetVal
%include Common\FAT_FileSystemerrDResultMsg.Inc

%endif %- errDResultMsg
%-BW_METHOD_END errDResultMsg
%-************************************************************************************************************
%-BW_METHOD_BEGIN isDiskPresent
%ifdef isDiskPresent
#define %'ModuleName'%.%isDiskPresent() \
  %@Memory@'ModuleName'%.CardPresent()

%define! RetVal
%include Common\FAT_FileSystemisDiskPresent.Inc

%endif %- isDiskPresent
%-BW_METHOD_END isDiskPresent
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_gets
%ifdef f_gets
#define %'ModuleName'%.%f_gets(buff, len, fil) \
  f_gets(buff,len,fil)

%define! Parbuff
%define! Parlen
%define! Parfil
%define! RetVal
%include Common\FAT_FileSystemf_gets.Inc

%endif %- f_gets
%-BW_METHOD_END f_gets
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_puts
%ifdef f_puts
#define %'ModuleName'%.%f_puts(str, fil) \
  f_puts(str, fil)

%define! Parbuff
%define! Parfil
%define! RetVal
%include Common\FAT_FileSystemf_puts.Inc

%endif %- f_puts
%-BW_METHOD_END f_puts
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_putc
%ifdef f_putc
#define %'ModuleName'%.%f_putc(c, fil) \
  f_putc(c, fil)

%define! Parbuff
%define! Parfil
%define! RetVal
%include Common\FAT_FileSystemf_putc.Inc

%endif %- f_putc
%-BW_METHOD_END f_putc
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_printf
%ifdef f_printf
#define %'ModuleName'%.%f_printf \
  f_printf

%define! ParVariable_1
%define! Parstr
%define! ParVariable_2
%define! RetVal
%include Common\FAT_FileSystemf_printf.Inc

%endif %- f_printf
%-BW_METHOD_END f_printf
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_eof
%ifdef f_eof
#define %'ModuleName'%.%f_eof(fp) \
  f_eof(fp)

%define! Parfp
%define! RetVal
%include Common\FAT_FileSystemf_eof.Inc

%endif %- f_eof
%-BW_METHOD_END f_eof
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_error
%ifdef f_error
#define %'ModuleName'%.%f_error(fp) \
  f_error(fp)

%define! Parfp
%define! RetVal
%include Common\FAT_FileSystemf_error.Inc

%endif %- f_error
%-BW_METHOD_END f_error
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_tell
%ifdef f_tell
#define %'ModuleName'%.%f_tell(fp) \
  f_tell(fp)

%define! Parfp
%define! RetVal
%include Common\FAT_FileSystemf_tell.Inc

%endif %- f_tell
%-BW_METHOD_END f_tell
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_size
%ifdef f_size
#define %'ModuleName'%.%f_size(fp) \
  f_size(fp)

%define! Parfp
%define! RetVal
%include Common\FAT_FileSystemf_size.Inc

%endif %- f_size
%-BW_METHOD_END f_size
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
void %'ModuleName'%.%Init(void);
%include Common\FAT_FileSystemInit.Inc

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
void %'ModuleName'%.%Deinit(void);
%include Common\FAT_FileSystemDeinit.Inc

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN get_fattime
%ifdef get_fattime
dword %'ModuleName'%.%get_fattime(void);
%define! RetVal
%include Common\FAT_FileSystemget_fattime.Inc

%endif %- get_fattime
%-BW_METHOD_END get_fattime
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_METHOD_BEGIN OnIdle
%ifdef OnIdle
%INTERFACE OnIdle
void %OnIdle(void);
%include Common\FAT_FileSystemOnIdle.Inc

%endif %- OnIdle
%-BW_METHOD_END OnIdle
%-BW_METHOD_BEGIN OnSchedule
%ifdef OnSchedule
%INTERFACE OnSchedule
void %OnSchedule(void);
%include Common\FAT_FileSystemOnSchedule.Inc

%endif %- OnSchedule
%-BW_METHOD_END OnSchedule
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\FAT_FileSystemSettings.Inc
%define! Abstract Common\FAT_FileSystemAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "ff.h"
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%-
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************

/* Unicode support functions */
#if _USE_LFN  /* Unicode - OEM code conversion */
#if _USE_LFN == 3   /* Memory functions */
void *ff_memalloc(UINT size) { /* Allocate memory block */
%if defined(RTOS)
  /* FreeRTOS */
  return %@RTOS@'ModuleName'%.pvPortMalloc(size);
%else
  #error "No RTOS defined?"
%endif
}

void ff_memfree (void* ptr) {  /* Free memory block */
%if defined(RTOS)
  /* FreeRTOS */
  %@RTOS@'ModuleName'%.vPortFree(ptr);
%else
  #error "No RTOS defined?"
%endif
}
#endif
#endif

#if _FS_REENTRANT
/*!
* \brief Create a Synchronization Object
* This function is called in f_mount function to create a new
* synchronization object, such as semaphore and mutex. When a FALSE is
* returned, the f_mount function fails with FR_INT_ERR.
* \param[in] vol Corresponding logical drive being processed
* \param[out] sobj Pointer to return the created sync object
* \return TRUE: Function succeeded, FALSE: Could not create due to any error
*/
%if defined(UserSyncFunctions) & %UserSyncFunctions='yes'
#if 0
int ff_cre_syncobj(uint8_t vol, _SYNC_t *sobj)
{
  /* You have decided in the component properties to implement your own user sync functions,
     with you own _SYNC_t type (e.g. HANDLE).
     You need to implement your own version of this function in your application.
  */
}
#endif
%else
int ff_cre_syncobj(uint8_t vol, _SYNC_t *sobj) {
  (void)vol; /* argument not used */
%if defined(RTOS)
  *sobj = %@RTOS@'ModuleName'%.xSemaphoreCreateMutex(); /* create semaphore */
  return (*sobj != NULL) ? TRUE : FALSE;
%- *sobj = OSMutexCreate(0, &err);                         /* uC/OS-II */
%- ret = (err == OS_NO_ERR) ? TRUE : FALSE;
%else
  /* _FS_REENTRANT enabled, no RTOS enabled, and you don't want to provide your own sync method.
     That means that you cannot have parallel access to the file system object.
     If you have parallel access to the memory bus, you need to handle this from the memory component.
   */
  (void)sobj;
  return TRUE;
%endif
}
%endif

/*!
* \brief Delete a Synchronization Object
* This function is called in f_mount function to delete a synchronization
* object that created with ff_cre_syncobj function. When a FALSE is
* returned, the f_mount function fails with FR_INT_ERR.
* \param[out] sobj Sync object tied to the logical drive to be deleted
* \return TRUE: Function succeeded, FALSE: Could not create due to any error
*/
%if defined(UserSyncFunctions) & %UserSyncFunctions='yes'
#if 0
int ff_del_syncobj(_SYNC_t sobj) {
  /* You have decided in the component properties to implement your own user sync functions,
     with you own _SYNC_t type (e.g. HANDLE).
     You need to implement your own version of this function in your application.
  */
}
#endif
%else
int ff_del_syncobj(_SYNC_t sobj) {
%if defined(RTOS)
  %@RTOS@'ModuleName'%.vQueueDelete(sobj); /* FreeRTOS: free up memory for semaphore */
  return TRUE; /* everything ok */
%-      OSMutexDel(sobj, OS_DEL_ALWAYS, &err);          /* uC/OS-II */
%-      ret = (err == OS_NO_ERR) ? TRUE : FALSE;
%else
  /* _FS_REENTRANT enabled, no RTOS enabled, and you don't want to provide your own sync method.
     That means that you cannot have parallel access to the file system object.
     If you have parallel access to the memory bus, you need to handle this from the memory component.
   */
  (void)sobj; /* unused parameter */
  return TRUE;
%endif
}
%endif

/*!
* \brief Request Grant to Access the Volume
* This function is called on entering file functions to lock the volume.
* When a FALSE is returned, the file function fails with FR_TIMEOUT.
* \param[in] sobj Sync object to wait
* \return TRUE: Function succeeded, FALSE: Could not create due to any error
*/
%if defined(UserSyncFunctions) & %UserSyncFunctions='yes'
#if 0
int ff_req_grant (_SYNC_t sobj) {
  /* You have decided in the component properties to implement your own user sync functions,
     with you own _SYNC_t type (e.g. HANDLE).
     You need to implement your own version of this function in your application.
  */
}
#endif
%else
int ff_req_grant (_SYNC_t sobj) {
%if defined(RTOS)
  if (%@RTOS@'ModuleName'%.xSemaphoreTake(sobj, _FS_TIMEOUT) == pdTRUE) {
    %@Memory@'ModuleName'%.Activate(); /* select memory device */
    return TRUE; /* success */
  } else {  /* failed to get the sync object? */
    return FALSE; /* failure */
  }
%-      OSMutexPend(sobj, _FS_TIMEOUT, &err));                  /* uC/OS-II */
%-      return (err == OS_NO_ERR) ? TRUE : FALSE;
%else
  /* _FS_REENTRANT enabled, no RTOS enabled, and you don't want to provide your own sync method.
     That means that you cannot have parallel access to the file system object.
     If you have parallel access to the memory bus, you need to handle this from the memory component.
   */
  (void)sobj; /* unused parameter */
  %@Memory@'ModuleName'%.Activate(); /* select memory device */
  return TRUE; /* success */
%endif
}
%endif

/*!
* \brief Release Grant to Access the Volume
* This function is called on leaving file functions to unlock the volume.
* \param[in] sobj Sync object to be signaled
*/
%if defined(UserSyncFunctions) & %UserSyncFunctions='yes'
#if 0
void ff_rel_grant (_SYNC_t sobj) {
  /* You have decided in the component properties to implement your own user sync functions,
     with you own _SYNC_t type (e.g. HANDLE).
     You need to implement your own version of this function in your application.
  */
}
#endif
%else
void ff_rel_grant (_SYNC_t sobj) {
  %@Memory@'ModuleName'%.Deactivate(); /* un-select memory device */
%if defined(RTOS)
  (void)%@RTOS@'ModuleName'%.xSemaphoreGive(sobj); /* FreeRTOS */
%-      OSMutexPost(sobj);              /* uC/OS-II */
%else
  /* _FS_REENTRANT enabled, no RTOS enabled, and you don't want to provide your own sync method.
     That means that you cannot have parallel access to the file system object.
     If you have parallel access to the memory bus, you need to handle this from the memory component.
   */
  (void)sobj; /* unused parameter */
%endif
}
%endif
#endif /* _FS_REENTRANT */

%-BW_METHOD_BEGIN open
%ifdef open
%define! Parfp
%define! Parpath
%define! Parmode
%define! RetVal
%include Common\FAT_FileSystemopen.Inc
/*
FRESULT %'ModuleName'%.%open(FIL *fp, const XCHAR *path, uint8_t mode)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- open
%-BW_METHOD_END open
%-************************************************************************************************************
%-BW_METHOD_BEGIN close
%ifdef close
%define! Parfp
%define! RetVal
%include Common\FAT_FileSystemclose.Inc
/*
FRESULT %'ModuleName'%.%close(FIL *fp)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- close
%-BW_METHOD_END close
%-************************************************************************************************************
%-BW_METHOD_BEGIN read
%ifdef read
%define! Parfp
%define! Parbuff
%define! Parbtr
%define! Parbr
%define! RetVal
%include Common\FAT_FileSystemread.Inc
/*
FRESULT %'ModuleName'%.%read(FIL *fp, void *buff, UINT btr, UINT *br)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- read
%-BW_METHOD_END read
%-************************************************************************************************************
%-BW_METHOD_BEGIN write
%ifdef write
%define! Parfp
%define! Parbuff
%define! Parbtw
%define! Parbw
%define! RetVal
%include Common\FAT_FileSystemwrite.Inc
/*
FRESULT %'ModuleName'%.%write(FIL *fp, const *void buff, UINT btw, UINT *bw)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- write
%-BW_METHOD_END write
%-************************************************************************************************************
%-BW_METHOD_BEGIN opendir
%ifdef opendir
%define! Pardj
%define! Parpath
%define! RetVal
%include Common\FAT_FileSystemopendir.Inc
/*
FRESULT %'ModuleName'%.%opendir(DIR *dj, const XCHAR *path)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- opendir
%-BW_METHOD_END opendir
%-************************************************************************************************************
%-BW_METHOD_BEGIN readdir
%ifdef readdir
%define! Pardir
%define! Parfno
%define! RetVal
%include Common\FAT_FileSystemreaddir.Inc
/*
FRESULT %'ModuleName'%.%readdir(DIR *dj, FILINFO *fno)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- readdir
%-BW_METHOD_END readdir
%-************************************************************************************************************
%-BW_METHOD_BEGIN lseek
%ifdef lseek
%define! Parfp
%define! Parofs
%define! RetVal
%include Common\FAT_FileSystemlseek.Inc
/*
FRESULT %'ModuleName'%.%lseek(FIL *fp, uint32_t ofs)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- lseek
%-BW_METHOD_END lseek
%-************************************************************************************************************
%-BW_METHOD_BEGIN unlink
%ifdef unlink
%define! Parpath
%define! RetVal
%include Common\FAT_FileSystemunlink.Inc
/*
FRESULT %'ModuleName'%.%unlink(const XCHAR *path)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- unlink
%-BW_METHOD_END unlink
%-************************************************************************************************************
%-BW_METHOD_BEGIN mount
%ifdef mount
%define! Parvol
%define! Parfs
%define! RetVal
%include Common\FAT_FileSystemmount.Inc
/*
FRESULT %'ModuleName'%.%mount(byte vol, FATFS *fs)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- mount
%-BW_METHOD_END mount
%-************************************************************************************************************
%-BW_METHOD_BEGIN getfree
%ifdef getfree
%define! Parpath
%define! Parnclst
%define! Parfatfs
%define! RetVal
%include Common\FAT_FileSystemgetfree.Inc
/*
FRESULT %'ModuleName'%.%getfree(const XCHAR *path, dword *nclst, FATFS **fatfs)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- getfree
%-BW_METHOD_END getfree
%-************************************************************************************************************
%-BW_METHOD_BEGIN sync
%ifdef sync
%define! Parfp
%define! RetVal
%include Common\FAT_FileSystemsync.Inc
/*
FRESULT %'ModuleName'%.%sync(FIL *fp)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- sync
%-BW_METHOD_END sync
%-************************************************************************************************************
%-BW_METHOD_BEGIN rename
%ifdef rename
%define! Parpath_old
%define! Parpath_new
%define! RetVal
%include Common\FAT_FileSystemrename.Inc
/*
FRESULT %'ModuleName'%.%rename(const XCHAR *path_old, const XCHAR *path_new)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- rename
%-BW_METHOD_END rename
%-************************************************************************************************************
%-BW_METHOD_BEGIN isWriteProtected
%ifdef isWriteProtected
%define! RetVal
%include Common\FAT_FileSystemisWriteProtected.Inc
/*
bool %'ModuleName'%.%isWriteProtected(void)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- isWriteProtected
%-BW_METHOD_END isWriteProtected
%-************************************************************************************************************
%-BW_METHOD_BEGIN mkdir
%ifdef mkdir
%define! Parpath
%define! RetVal
%include Common\FAT_FileSystemmkdir.Inc
/*
FRESULT %'ModuleName'%.%mkdir(const XCHAR *path)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- mkdir
%-BW_METHOD_END mkdir
%-************************************************************************************************************
%-BW_METHOD_BEGIN chmod
%ifdef chmod
%define! ParFileName
%define! ParAttribute
%define! ParAttributeMask
%define! RetVal
%include Common\FAT_FileSystemchmod.Inc
/*
FRESULT %'ModuleName'%.%chmod(const TCHAR* FileName, byte Attribute, byte AttributeMask)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- chmod
%-BW_METHOD_END chmod
%-************************************************************************************************************
%-BW_METHOD_BEGIN truncate
%ifdef truncate
%define! ParFileObject
%define! RetVal
%include Common\FAT_FileSystemtruncate.Inc
/*
FRESULT %'ModuleName'%.%truncate(FIL *FileObject)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- truncate
%-BW_METHOD_END truncate
%-************************************************************************************************************
%-BW_METHOD_BEGIN stat
%ifdef stat
%define! ParFileName
%define! ParFileInfo
%define! RetVal
%include Common\FAT_FileSystemstat.Inc
/*
FRESULT %'ModuleName'%.%stat(const TCHAR* FileName, FILINFO* FileInfo)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- stat
%-BW_METHOD_END stat
%-************************************************************************************************************
%-BW_METHOD_BEGIN utime
%ifdef utime
%define! ParFileName
%define! ParTimeDate
%define! RetVal
%include Common\FAT_FileSystemutime.Inc
/*
FRESULT %'ModuleName'%.%utime(const TCHAR* FileName, const FILINFO* TimeDate)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- utime
%-BW_METHOD_END utime
%-************************************************************************************************************
%-BW_METHOD_BEGIN mkfs
%ifdef mkfs
%define! Pardrive
%define! ParPartitioningRule
%define! ParAllocSize
%define! RetVal
%include Common\FAT_FileSystemmkfs.Inc
/*
FRESULT %'ModuleName'%.%mkfs(byte drive, byte PartitioningRule, UINT  AllocSize)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- mkfs
%-BW_METHOD_END mkfs
%-************************************************************************************************************
%-BW_METHOD_BEGIN forward
%ifdef forward
%define! ParFileObject
%define! ParFunc
%define! ParByteToFwd
%define! ParByteFwd
%define! RetVal
%include Common\FAT_FileSystemforward.Inc
/*
FRESULT %'ModuleName'%.%forward(FIL* FileObject, UINT (*Func)(const uint8_t*,UINT), UINT ByteToFwd, UINT* ByteFwd )
{
  *** method is implemented as macro in the header file
}
*/

%endif %- forward
%-BW_METHOD_END forward
%-************************************************************************************************************
%-BW_METHOD_BEGIN chdir
%ifdef chdir
%define! ParPath
%define! RetVal
%include Common\FAT_FileSystemchdir.Inc
/*
FRESULT %'ModuleName'%.%chdir(const TCHAR* Path)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- chdir
%-BW_METHOD_END chdir
%-************************************************************************************************************
%-BW_METHOD_BEGIN chdrive
%ifdef chdrive
%define! ParDrive
%define! RetVal
%include Common\FAT_FileSystemchdrive.Inc
/*
FRESULT %'ModuleName'%.%chdrive(byte Drive)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- chdrive
%-BW_METHOD_END chdrive
%-************************************************************************************************************
%-BW_METHOD_BEGIN getcwd
%ifdef getcwd
%define! ParBuffer
%define! ParBufferLen
%define! RetVal
%include Common\FAT_FileSystemgetcwd.Inc
/*
FRESULT %'ModuleName'%.%getcwd(TCHAR* Buffer, UINT BufferLen)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- getcwd
%-BW_METHOD_END getcwd
%-************************************************************************************************************
%-BW_METHOD_BEGIN errFResultMsg
%ifdef errFResultMsg
%define! ParerrNo
%define! RetVal
%include Common\FAT_FileSystemerrFResultMsg.Inc
char* %'ModuleName'%.%errFResultMsg(int errNo)
{
  switch(errNo) {
    case FR_OK:                  return "Succeeded";
    case FR_DISK_ERR:            return "A hard error occurred in the low level disk I/O layer";
    case FR_INT_ERR:             return "Assertion failed";
    case FR_NOT_READY:           return "The physical drive cannot work";
    case FR_NO_FILE:             return "Could not find the file";
    case FR_NO_PATH:             return "Could not find the path";
    case FR_INVALID_NAME:        return "The path name format is invalid";
    case FR_DENIED:              return "Access denied due to prohibited access or directory full";
    case FR_EXIST:               return "Access denied due to prohibited access";
    case FR_INVALID_OBJECT:      return "The file/directory object is invalid";
    case FR_WRITE_PROTECTED:     return "The physical drive is write protected";
    case FR_INVALID_DRIVE:       return "The logical drive number is invalid";
    case FR_NOT_ENABLED:         return "The volume has no work area";
    case FR_NO_FILESYSTEM:       return "There is no valid FAT volume on the physical drive";
    case FR_MKFS_ABORTED:        return "The f_mkfs() aborted due to any parameter error";
    case FR_TIMEOUT:             return "Could not get a grant to access the volume within defined period";
    case FR_LOCKED:              return "The operation is rejected according to the file sharing policy";
    case FR_NOT_ENOUGH_CORE:     return "LFN working buffer could not be allocated";
    case FR_TOO_MANY_OPEN_FILES: return "Number of open files > _FS_SHARE";
    default:                     return "unknown";
  } /* switch */
  return "";
}

%endif %- errFResultMsg
%-BW_METHOD_END errFResultMsg
%-************************************************************************************************************
%-BW_METHOD_BEGIN errDResultMsg
%ifdef errDResultMsg
%define! ParerrNo
%define! RetVal
%include Common\FAT_FileSystemerrDResultMsg.Inc
char* %'ModuleName'%.%errDResultMsg(int errNo)
{
  switch(errNo) {
    case RES_OK:     return "Successful";
    case RES_ERROR:  return "R/W Error";
    case RES_WRPRT:  return "Write Protected";
    case RES_NOTRDY: return "Not Ready";
    case RES_PARERR: return "Invalid Parameter";
    default:         return "unknown";
  } /* switch */
  return "";
}

%endif %- errDResultMsg
%-BW_METHOD_END errDResultMsg
%-************************************************************************************************************
%-BW_METHOD_BEGIN isDiskPresent
%ifdef isDiskPresent
%define! RetVal
%include Common\FAT_FileSystemisDiskPresent.Inc
/*
bool %'ModuleName'%.%isDiskPresent(void)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- isDiskPresent
%-BW_METHOD_END isDiskPresent
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_gets
%ifdef f_gets
%define! Parbuff
%define! Parlen
%define! Parfil
%define! RetVal
%include Common\FAT_FileSystemf_gets.Inc
/*
%'ModuleName'_CHARP %'ModuleName'%.%f_gets(TCHAR* buff, int len, FIL *fil)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- f_gets
%-BW_METHOD_END f_gets
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_puts
%ifdef f_puts
%define! Parbuff
%define! Parfil
%define! RetVal
%include Common\FAT_FileSystemf_puts.Inc
/*
%'ModuleName'_INT %'ModuleName'%.%f_puts(const TCHAR* str, FIL *fil)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- f_puts
%-BW_METHOD_END f_puts
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_putc
%ifdef f_putc
%define! Parbuff
%define! Parfil
%define! RetVal
%include Common\FAT_FileSystemf_putc.Inc
/*
%'ModuleName'_INT %'ModuleName'%.%f_putc(TCHAR c, FIL *fil)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- f_putc
%-BW_METHOD_END f_putc
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_printf
%ifdef f_printf
%define! ParVariable_1
%define! Parstr
%define! ParVariable_2
%define! RetVal
%include Common\FAT_FileSystemf_printf.Inc
/*
%'ModuleName'_INT %'ModuleName'%.%f_printf(FIL* fil, const TCHAR* str, ...)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- f_printf
%-BW_METHOD_END f_printf
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_eof
%ifdef f_eof
%define! Parfp
%define! RetVal
%include Common\FAT_FileSystemf_eof.Inc
/*
byte %'ModuleName'%.%f_eof(FIL *fil)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- f_eof
%-BW_METHOD_END f_eof
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_error
%ifdef f_error
%define! Parfp
%define! RetVal
%include Common\FAT_FileSystemf_error.Inc
/*
byte %'ModuleName'%.%f_error(FIL *fil)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- f_error
%-BW_METHOD_END f_error
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_tell
%ifdef f_tell
%define! Parfp
%define! RetVal
%include Common\FAT_FileSystemf_tell.Inc
/*
dword %'ModuleName'%.%f_tell(FIL *fil)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- f_tell
%-BW_METHOD_END f_tell
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_size
%ifdef f_size
%define! Parfp
%define! RetVal
%include Common\FAT_FileSystemf_size.Inc
/*
dword %'ModuleName'%.%f_size(FIL *fil)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- f_size
%-BW_METHOD_END f_size
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%include Common\FAT_FileSystemInit.Inc
void %'ModuleName'%.%Init(void)
{
  (void)%@Memory@'ModuleName'%.Init(NULL);
}

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
%include Common\FAT_FileSystemDeinit.Inc
void %'ModuleName'%.%Deinit(void)
{
  %@Memory@'ModuleName'%.Deinit(NULL);
}

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN get_fattime
%ifdef get_fattime
%if defined(UseTimeDate) & %UseTimeDate='no'
#if 0 /* usage of DateTime component disabled in properties */
%endif

#if !_FS_READONLY
%define! RetVal
%include Common\FAT_FileSystemget_fattime.Inc
dword %'ModuleName'%.%get_fattime(void)
{
  /* 31-25: Year(0-127 org.1980), 24-21: Month(1-12), 20-16: Day(1-31) */
  /* 15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) */
  /* Pack date and time into a uint32_t variable */
%if defined(RTC)
  TIMEREC time;
  DATEREC date;

  (void)%@RTC@'ModuleName'%.GetTime(&time);                      %>40 /* get time information */
  (void)%@RTC@'ModuleName'%.GetDate(&date);                      %>40 /* get time information */
  return ((uint32_t)(date.Year - 1980) << 25)
       | ((uint32_t)date.Month << 21)
       | ((uint32_t)date.Day << 16)
       | ((uint32_t)time.Hour << 11)
       | ((uint32_t)time.Min << 5);
%else
  /* Get time and date information and store it in 'time' and 'date'.
     If not using the DateTime component, you need to implement your own method here.
   */
  return 0;
%endif
}
#endif /*!_FS_READONLY*/

%if defined(UseTimeDate) & %UseTimeDate='no'
#endif /* usage of DateTime component disabled in properties */
%endif

%endif %- get_fattime
%-BW_METHOD_END get_fattime
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_METHOD_BEGIN OnIdle
%ifdef OnIdle
%IMPLEMENTATION OnIdle
%include Common\FAT_FileSystemOnIdle.Inc
void %OnIdle(void)
{
  /* Write your code here ... */
}

%endif %- OnIdle
%-BW_METHOD_END OnIdle
%-BW_METHOD_BEGIN OnSchedule
%ifdef OnSchedule
%IMPLEMENTATION OnSchedule
%include Common\FAT_FileSystemOnSchedule.Inc
void %OnSchedule(void)
{
  /* Write your code here ... */
}

%endif %- OnSchedule
%-BW_METHOD_END OnSchedule
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This bean is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-

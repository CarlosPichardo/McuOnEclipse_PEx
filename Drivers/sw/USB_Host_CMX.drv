%-Driver generated by the Bean Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Bean Wizard
%- If you change these lines, Bean Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    22.07.2009
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%define! Description_ScanMouse Mouse event driver
%define! Description_ScanKeyboard Keyboard event driver
%define! Description_ScanJoystick Joystick event driver
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\USB_Host_CMXSettings.Inc
%define! Abstract Common\USB_Host_CMXAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"
#include "hcc_types.h"
#include "usb_host.h"
#include "host_hid.h"
#include "host_hid_mouse.h"
#include "host_hid_kbd.h"
#include "host_hid_joy.h"

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

#ifndef __BWUserType_%'ModuleName'_TKeyboardInfoType
#define __BWUserType_%'ModuleName'_TKeyboardInfoType
  typedef struct {                                               %>40/* Defines the status of a keyboard event */
    byte nofKeys;                                                %>40/* number of currently pressed keys */
    byte* keys;                                                  %>40/* This holds the number of currently pressed keys */
    bool l_shift;                                                %>40/* left shift value (1 if pressed, 0 otherwise) */
    bool r_shift;                                                %>40/* right shift value (1 if pressed, 0 otherwise) */
    byte l_alt;                                                  %>40/* left alt value (1 if pressed, 0 otherwise) */
    byte r_alt;                                                  %>40/* right alt value (1 if pressed, 0 otherwise) */
    byte l_ctrl;                                                 %>40/* left ctrl value (1 if pressed, 0 otherwise) */
    byte r_ctrl;                                                 %>40/* rigth ctrl value (1 if pressed, 0 otherwise) */
    byte l_gui;                                                  %>40/* left gui value (1 if pressed, 0 otherwise) */
    byte r_gui;                                                  %>40/* rigth gui value (1 if pressed, 0 otherwise) */
  } %'ModuleName'_TKeyboardInfoType;
#endif

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
%-BW_CUSTOM_USERTYPE_END


%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN stack_init
%ifdef stack_init
void %'ModuleName'%.%stack_init(byte pattern);
%define! Parpattern
%include Common\USB_Host_CMXstack_init.Inc

%endif %- stack_init
%-BW_METHOD_END stack_init
%-************************************************************************************************************
%-BW_METHOD_BEGIN stack_size
%ifdef stack_size
long %'ModuleName'%.%stack_size(byte pattern);
%define! Parpattern
%define! RetVal
%include Common\USB_Host_CMXstack_size.Inc

%endif %- stack_size
%-BW_METHOD_END stack_size
%-************************************************************************************************************
%-BW_METHOD_BEGIN hw_init
%ifdef hw_init
void %'ModuleName'%.%hw_init(void);
%include Common\USB_Host_CMXhw_init.Inc

%endif %- hw_init
%-BW_METHOD_END hw_init
%-************************************************************************************************************
%-BW_METHOD_BEGIN init_clock
%ifdef init_clock
void %'ModuleName'%.%init_clock(void);
%include Common\USB_Host_CMXinit_clock.Inc

%endif %- init_clock
%-BW_METHOD_END init_clock
%-************************************************************************************************************
%-BW_METHOD_BEGIN Vbus_Sw_En
%ifdef Vbus_Sw_En
void %'ModuleName'%.%Vbus_Sw_En(void);
%include Common\USB_Host_CMXVbus_Sw_En.Inc

%endif %- Vbus_Sw_En
%-BW_METHOD_END Vbus_Sw_En
%-************************************************************************************************************
%-BW_METHOD_BEGIN enable_usb_pull_downs
%ifdef enable_usb_pull_downs
void %'ModuleName'%.%enable_usb_pull_downs(void);
%include Common\USB_Host_CMXenable_usb_pull_downs.Inc

%endif %- enable_usb_pull_downs
%-BW_METHOD_END enable_usb_pull_downs
%-************************************************************************************************************
%-BW_METHOD_BEGIN host_init
%ifdef host_init
#define %'ModuleName'%.%host_init() host_init()
%include Common\USB_Host_CMXhost_init.Inc

%endif %- host_init
%-BW_METHOD_END host_init
%-************************************************************************************************************
%-BW_METHOD_BEGIN ByteRev32
%ifdef ByteRev32
dword %'ModuleName'%.%ByteRev32(dword val);
%define! Parval
%define! RetVal
%include Common\USB_Host_CMXByteRev32.Inc

%endif %- ByteRev32
%-BW_METHOD_END ByteRev32
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScanDevices
%ifdef ScanDevices
byte %'ModuleName'%.%ScanDevices(void);
%define! ParHID_type
%define! RetVal
%include Common\USB_Host_CMXScanDevices.Inc

%endif %- ScanDevices
%-BW_METHOD_END ScanDevices
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
byte %'ModuleName'%.%Init(void);
%define! RetVal
%include Common\USB_Host_CMXInit.Inc

%endif %- Init
%-BW_METHOD_END Init
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_METHOD_BEGIN OnAttach
%ifdef OnAttach
%INTERFACE OnAttach
void %OnAttach(byte hid_type);
%define! Parhid_type
%include Common\USB_Host_CMXOnAttach.Inc

%endif %- OnAttach
%-BW_METHOD_END OnAttach
%-BW_METHOD_BEGIN OnDetach
%ifdef OnDetach
%INTERFACE OnDetach
void %OnDetach(byte hid_type);
%define! Parhid_type
%include Common\USB_Host_CMXOnDetach.Inc

%endif %- OnDetach
%-BW_METHOD_END OnDetach
%-BW_METHOD_BEGIN OnMouseMove
%ifdef OnMouseMove
%INTERFACE OnMouseMove
void %OnMouseMove(int x, int y);
%define! Parx
%define! Pary
%include Common\USB_Host_CMXOnMouseMove.Inc

%endif %- OnMouseMove
%-BW_METHOD_END OnMouseMove
%-BW_METHOD_BEGIN OnMouseButton
%ifdef OnMouseButton
%INTERFACE OnMouseButton
void %OnMouseButton(byte button0, byte button1, byte button2);
%define! Parbutton1
%define! Parbutton2
%define! Parbutton0
%include Common\USB_Host_CMXOnMouseButton.Inc

%endif %- OnMouseButton
%-BW_METHOD_END OnMouseButton
%-BW_METHOD_BEGIN OnKeyboardRawKey
%ifdef OnKeyboardRawKey
%INTERFACE OnKeyboardRawKey
void %OnKeyboardRawKey(%'ModuleName'_TKeyboardInfoType *keys);
%define! Parkeys
%include Common\USB_Host_CMXOnKeyboardRawKey.Inc

%endif %- OnKeyboardRawKey
%-BW_METHOD_END OnKeyboardRawKey
%-BW_METHOD_BEGIN OnKeyboardKey
%ifdef OnKeyboardKey
%INTERFACE OnKeyboardKey
void %OnKeyboardKey(byte ch);
%define! Parch
%include Common\USB_Host_CMXOnKeyboardKey.Inc

%endif %- OnKeyboardKey
%-BW_METHOD_END OnKeyboardKey
%-BW_METHOD_BEGIN OnIdle
%ifdef OnIdle
%INTERFACE OnIdle
void %OnIdle(void);
%include Common\USB_Host_CMXOnIdle.Inc

%endif %- OnIdle
%-BW_METHOD_END OnIdle
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\USB_Host_CMXSettings.Inc
%define! Abstract Common\USB_Host_CMXAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%if %CPUDerivative='MCF51JM128'
#include <hidef.h> /* for EnableInterrupts */
#include "mcf51xx_reg.h"
%elif %CPUDerivative='MCF52259'
#include "mcf5222x_reg.h"
%endif
#include "host_hid.h"

%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%-
static const byte RawToChar[256][2] = {
  /* NRML, SHFT*/
  {  0,  0}, /* KEY_NONE                               0x00 */
  {  0,  0}, /* KEY_ERRORROLLOVER                      0x01 */
  {  0,  0}, /* KEY_POSTFAIL                           0x02 */
  {  0,  0}, /* KEY_ERRORUNDEFINED                     0x03 */
  {'a','A'}, /* KEY_A                                  0x04 */
  {'b','B'}, /* KEY_B                                  0x05 */
  {'c','C'}, /* KEY_C                                  0x06 */
  {'d','D'}, /* KEY_D                                  0x07 */
  {'e','E'}, /* KEY_E                                  0x08 */
  {'f','F'}, /* KEY_F                                  0x09 */
  {'g','G'}, /* KEY_G                                  0x0A */
  {'h','H'}, /* KEY_H                                  0x0B */
  {'i','I'}, /* KEY_I                                  0x0C */
  {'j','J'}, /* KEY_J                                  0x0D */
  {'k','K'}, /* KEY_K                                  0x0E */
  {'l','L'}, /* KEY_L                                  0x0F */
  {'m','M'}, /* KEY_M                                  0x10 */
  {'n','N'}, /* KEY_N                                  0x11 */
  {'o','O'}, /* KEY_O                                  0x12 */
  {'p','P'}, /* KEY_P                                  0x13 */
  {'q','Q'}, /* KEY_Q                                  0x14 */
  {'r','R'}, /* KEY_R                                  0x15 */
  {'s','S'}, /* KEY_S                                  0x16 */
  {'t','T'}, /* KEY_T                                  0x17 */
  {'u','U'}, /* KEY_U                                  0x18 */
  {'v','V'}, /* KEY_V                                  0x19 */
  {'w','W'}, /* KEY_W                                  0x1A */
  {'x','X'}, /* KEY_X                                  0x1B */
  {'y','Y'}, /* KEY_Y                                  0x1C */
  {'z','Z'}, /* KEY_Z                                  0x1D */
  {'1','!'}, /* KEY_1_EXCLAMATION_MARK                 0x1E */
  {'2','@'}, /* KEY_2_AT                               0x1F */
  {'3','#'}, /* KEY_3_NUMBER_SIGN                      0x20 */
  {'4','$'}, /* KEY_4_DOLLAR                           0x21 */
  {'5','%%'}, /* KEY_5_PERCENT                          0x22 */
  {'6','^'}, /* KEY_6_CARET                            0x23 */
  {'7','&'}, /* KEY_7_AMPERSAND                        0x24 */
  {'8','*'}, /* KEY_8_ASTERISK                         0x25 */
  {'9','('}, /* KEY_9_OPARENTHESIS                     0x26 */
  {'0',')'}, /* KEY_0_CPARENTHESIS                     0x27 */
  {'\n','\n'},/* KEY_ENTER                              0x28 */
  {  0,  0}, /* KEY_ESCAPE                             0x29 */
  {  0,  0}, /* KEY_BACKSPACE                          0x2A */
  {'\t','\t'},/* KEY_TAB                                0x2B */
  {' ',' '}, /* KEY_SPACEBAR                           0x2C */
  {'-','_'}, /* KEY_MINUS_UNDERSCORE                   0x2D */
  {'=','+'}, /* KEY_EQUAL_PLUS                         0x2E */
  {'[','{'}, /* KEY_OBRACKET_AND_OBRACE                0x2F */
  {']','}'}, /* KEY_CBRACKET_AND_CBRACE                0x30 */
  {'\\','|'},/* KEY_BACKSLASH_VERTICAL_BAR             0x31 */
  {  0,  0}, /* KEY_NONUS_NUMBER_SIGN_TILDE            0x32 */
  {';',':'}, /* KEY_SEMICOLON_COLON                    0x33 */
  {'\'','"'},/* KEY_SINGLE_AND_DOUBLE_QUOTE            0x34 */
  {'`','~'}, /* KEY_GRAVE_ACCENT_AND_TILDE             0x35 */
  {',','<'}, /* KEY_COMMA_AND_LESS                     0x36 */
  {'.','>'}, /* KEY_DOT_GREATER                        0x37 */
  {'/','?'}, /* KEY_SLASH_QUESTION                     0x38 */
  {  0,  0}, /* KEY_CAPS_LOCK                          0x39 */
  {  0,  0}, /* KEY_F1                                 0x3A */
  {  0,  0}, /* KEY_F2                                 0x3B */
  {  0,  0}, /* KEY_F3                                 0x3C */
  {  0,  0}, /* KEY_F4                                 0x3D */
  {  0,  0}, /* KEY_F5                                 0x3E */
  {  0,  0}, /* KEY_F6                                 0x3F */
  {  0,  0}, /* KEY_F7                                 0x40 */
  {  0,  0}, /* KEY_F8                                 0x41 */
  {  0,  0}, /* KEY_F9                                 0x42 */
  {  0,  0}, /* KEY_F10                                0x43 */
  {  0,  0}, /* KEY_F11                                0x44 */
  {  0,  0}, /* KEY_F12                                0x45 */
  {  0,  0}, /* KEY_PRINTSCREEN                        0x46 */
  {  0,  0}, /* KEY_SCROLL_LOCK                        0x47 */
  {  0,  0}, /* KEY_PAUSE                              0x48 */
  {  0,  0}, /* KEY_INSERT                             0x49 */
  {  0,  0}, /* KEY_HOME                               0x4A */
  {  0,  0}, /* KEY_PAGEUP                             0x4B */
  {  0,  0}, /* KEY_DELETE                             0x4C */
  {  0,  0}, /* KEY_END1                               0x4D */
  {  0,  0}, /* KEY_PAGEDOWN                           0x4E */
  {  0,  0}, /* KEY_RIGHTARROW                         0x4F */
  {  0,  0}, /* KEY_LEFTARROW                          0x50 */
  {  0,  0}, /* KEY_DOWNARROW                          0x51 */
  {  0,  0}, /* KEY_UPARROW                            0x52 */
  {  0,  0}, /* KEY_KEYPAD_NUM_LOCK_AND_CLEAR          0x53 */
  {'/',  0}, /* KEY_KEYPAD_SLASH                       0x54 */
  {'*',  0}, /* KEY_KEYPAD_ASTERIKS                    0x55 */
  {'-',  0}, /* KEY_KEYPAD_MINUS                       0x56 */
  {'+',  0}, /* KEY_KEYPAD_PLUS                        0x57 */
  {'\n',  0}, /* KEY_KEYPAD_ENTER                       0x58 */
  {'1',  0}, /* KEY_KEYPAD_1_END                       0x59 */
  {'2',  0}, /* KEY_KEYPAD_2_DOWN_ARROW                0x5A */
  {'3',  0}, /* KEY_KEYPAD_3_PAGEDN                    0x5B */
  {'4',  0}, /* KEY_KEYPAD_4_LEFT_ARROW                0x5C */
  {'5',  0}, /* KEY_KEYPAD_5                           0x5D */
  {'6',  0}, /* KEY_KEYPAD_6_RIGHT_ARROW               0x5E */
  {'7',  0}, /* KEY_KEYPAD_7_HOME                      0x5F */
  {'8',  0}, /* KEY_KEYPAD_8_UP_ARROW                  0x60 */
  {'9',  0}, /* KEY_KEYPAD_9_PAGEUP                    0x61 */
  {'0',  0}, /* KEY_KEYPAD_0_INSERT                    0x62 */
  {'.',  0}, /* KEY_KEYPAD_DECIMAL_SEPARATOR_DELETE    0x63 */
  {  0,  0}, /* KEY_NONUS_BACK_SLASH_VERTICAL_BAR      0x64 */
  {  0,  0}, /* KEY_APPLICATION                        0x65 */
  {  0,  0}, /* KEY_POWER                              0x66 */
  {  0,  0}, /* KEY_KEYPAD_EQUAL                       0x67 */
  {  0,  0}, /* KEY_F13                                0x68 */
  {  0,  0}, /* KEY_F14                                0x69 */
  {  0,  0}, /* KEY_F15                                0x6A */
  {  0,  0}, /* KEY_F16                                0x6B */
  {  0,  0}, /* KEY_F17                                0x6C */
  {  0,  0}, /* KEY_F18                                0x6D */
  {  0,  0}, /* KEY_F19                                0x6E */
  {  0,  0}, /* KEY_F20                                0x6F */
  {  0,  0}, /* KEY_F21                                0x70 */
  {  0,  0}, /* KEY_F22                                0x71 */
  {  0,  0}, /* KEY_F23                                0x72 */
  {  0,  0}, /* KEY_F24                                0x73 */
  {  0,  0}, /* KEY_EXECUTE                            0x74 */
  {  0,  0}, /* KEY_HELP                               0x75 */
  {  0,  0}, /* KEY_MENU                               0x76 */
  {  0,  0}, /* KEY_SELECT                             0x77 */
  {  0,  0}, /* KEY_STOP                               0x78 */
  {  0,  0}, /* KEY_AGAIN                              0x79 */
  {  0,  0}, /* KEY_UNDO                               0x7A */
  {  0,  0}, /* KEY_CUT                                0x7B */
  {  0,  0}, /* KEY_COPY                               0x7C */
  {  0,  0}, /* KEY_PASTE                              0x7D */
  {  0,  0}, /* KEY_FIND                               0x7E */
  {  0,  0}, /* KEY_MUTE                               0x7F */
  {  0,  0}, /* KEY_VOLUME_UP                          0x80 */
  {  0,  0}, /* KEY_VOLUME_DOWN                        0x81 */
  {  0,  0}, /* KEY_LOCKING_CAPS_LOCK                  0x82 */
  {  0,  0}, /* KEY_LOCKING_NUM_LOCK                   0x83 */
  {  0,  0}, /* KEY_LOCKING_SCROLL_LOCK                0x84 */
  {  0,  0}, /* KEY_KEYPAD_COMMA                       0x85 */
  {  0,  0}, /* KEY_KEYPAD_EQUAL_SIGN                  0x86 */
  {  0,  0}, /* KEY_INTERNATIONAL1                     0x87 */
  {  0,  0}, /* KEY_INTERNATIONAL2                     0x88 */
  {  0,  0}, /* KEY_INTERNATIONAL3                     0x89 */
  {  0,  0}, /* KEY_INTERNATIONAL4                     0x8A */
  {  0,  0}, /* KEY_INTERNATIONAL5                     0x8B */
  {  0,  0}, /* KEY_INTERNATIONAL6                     0x8C */
  {  0,  0}, /* KEY_INTERNATIONAL7                     0x8D */
  {  0,  0}, /* KEY_INTERNATIONAL8                     0x8E */
  {  0,  0}, /* KEY_INTERNATIONAL9                     0x8F */
  {  0,  0}, /* KEY_LANG1                              0x90 */
  {  0,  0}, /* KEY_LANG2                              0x91 */
  {  0,  0}, /* KEY_LANG3                              0x92 */
  {  0,  0}, /* KEY_LANG4                              0x93 */
  {  0,  0}, /* KEY_LANG5                              0x94 */
  {  0,  0}, /* KEY_LANG6                              0x95 */
  {  0,  0}, /* KEY_LANG7                              0x96 */
  {  0,  0}, /* KEY_LANG8                              0x97 */
  {  0,  0}, /* KEY_LANG9                              0x98 */
  {  0,  0}, /* KEY_ALTERNATE_ERASE                    0x99 */
  {  0,  0}, /* KEY_SYSREQ                             0x9A */
  {  0,  0}, /* KEY_CANCEL                             0x9B */
  {  0,  0}, /* KEY_CLEAR                              0x9C */
  {  0,  0}, /* KEY_PRIOR                              0x9D */
  {  0,  0}, /* KEY_RETURN                             0x9E */
  {  0,  0}, /* KEY_SEPARATOR                          0x9F */
  {  0,  0}, /* KEY_OUT                                0xA0 */
  {  0,  0}, /* KEY_OPER                               0xA1 */
  {  0,  0}, /* KEY_CLEAR_AGAIN                        0xA2 */
  {  0,  0}, /* KEY_CRSEL                              0xA3 */
  {  0,  0}, /* KEY_EXSEL                              0xA4 */
  {  0,  0}, /* KEY_KEYPAD_00                          0xB0 */
  {  0,  0}, /* KEY_KEYPAD_000                         0xB1 */
  {  0,  0}, /* KEY_THOUSANDS_SEPARATOR                0xB2 */
  {  0,  0}, /* KEY_DECIMAL_SEPARATOR                  0xB3 */
  {  0,  0}, /* KEY_CURRENCY_UNIT                      0xB4 */
  {  0,  0}, /* KEY_CURRENCY_SUB_UNIT                  0xB5 */
  {  0,  0}, /* KEY_KEYPAD_OPARENTHESIS                0xB6 */
  {  0,  0}, /* KEY_KEYPAD_CPARENTHESIS                0xB7 */
  {  0,  0}, /* KEY_KEYPAD_OBRACE                      0xB8 */
  {  0,  0}, /* KEY_KEYPAD_CBRACE                      0xB9 */
  {  0,  0}, /* KEY_KEYPAD_TAB                         0xBA */
  {  0,  0}, /* KEY_KEYPAD_BACKSPACE                   0xBB */
  {  0,  0}, /* KEY_KEYPAD_A                           0xBC */
  {  0,  0}, /* KEY_KEYPAD_B                           0xBD */
  {  0,  0}, /* KEY_KEYPAD_C                           0xBE */
  {  0,  0}, /* KEY_KEYPAD_D                           0xBF */
  {  0,  0}, /* KEY_KEYPAD_E                           0xC0 */
  {  0,  0}, /* KEY_KEYPAD_F                           0xC1 */
  {  0,  0}, /* KEY_KEYPAD_XOR                         0xC2 */
  {  0,  0}, /* KEY_KEYPAD_CARET                       0xC3 */
  {  0,  0}, /* KEY_KEYPAD_PERCENT                     0xC4 */
  {  0,  0}, /* KEY_KEYPAD_LESS                        0xC5 */
  {  0,  0}, /* KEY_KEYPAD_GREATER                     0xC6 */
  {  0,  0}, /* KEY_KEYPAD_AMPERSAND                   0xC7 */
  {  0,  0}, /* KEY_KEYPAD_LOGICAL_AND                 0xC8 */
  {  0,  0}, /* KEY_KEYPAD_VERTICAL_BAR                0xC9 */
  {  0,  0}, /* KEY_KEYPAD_LOGIACL_OR                  0xCA */
  {  0,  0}, /* KEY_KEYPAD_COLON                       0xCB */
  {  0,  0}, /* KEY_KEYPAD_NUMBER_SIGN                 0xCC */
  {  0,  0}, /* KEY_KEYPAD_SPACE                       0xCD */
  {  0,  0}, /* KEY_KEYPAD_AT                          0xCE */
  {  0,  0}, /* KEY_KEYPAD_EXCLAMATION_MARK            0xCF */
  {  0,  0}, /* KEY_KEYPAD_MEMORY_STORE                0xD0 */
  {  0,  0}, /* KEY_KEYPAD_MEMORY_RECALL               0xD1 */
  {  0,  0}, /* KEY_KEYPAD_MEMORY_CLEAR                0xD2 */
  {  0,  0}, /* KEY_KEYPAD_MEMORY_ADD                  0xD3 */
  {  0,  0}, /* KEY_KEYPAD_MEMORY_SUBTRACT             0xD4 */
  {  0,  0}, /* KEY_KEYPAD_MEMORY_MULTIPLY             0xD5 */
  {  0,  0}, /* KEY_KEYPAD_MEMORY_DIVIDE               0xD6 */
  {  0,  0}, /* KEY_KEYPAD_PLUSMINUS                   0xD7 */
  {  0,  0}, /* KEY_KEYPAD_CLEAR                       0xD8 */
  {  0,  0}, /* KEY_KEYPAD_CLEAR_ENTRY                 0xD9 */
  {  0,  0}, /* KEY_KEYPAD_BINARY                      0xDA */
  {  0,  0}, /* KEY_KEYPAD_OCTAL                       0xDB */
  {  0,  0}, /* KEY_KEYPAD_DECIMAL                     0xDC */
  {  0,  0}, /* KEY_KEYPAD_HEXADECIMAL                 0xDD */
  {  0,  0}, /* KEY_LEFTCONTROL                        0xE0 */
  {  0,  0}, /* KEY_LEFTSHIFT                          0xE1 */
  {  0,  0}, /* KEY_LEFTALT                            0xE2 */
  {  0,  0}, /* KEY_LEFT_GUI                           0xE3 */
  {  0,  0}, /* KEY_RIGHTCONTROL                       0xE4 */
  {  0,  0}, /* KEY_RIGHTSHIFT                         0xE5 */
  {  0,  0}, /* KEY_RIGHTALT                           0xE6 */
  {  0,  0}  /* KEY_RIGHT_GUI                          0xE7 */
  /* E8 to 0xff are reserved */
};


%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-UNLOCKED
/* Internal method prototypes */
%-INTERNAL_LOC_METHOD_BEG ScanMouse
static void ScanMouse(void);
%-INTERNAL_LOC_METHOD_END ScanMouse
%-INTERNAL_LOC_METHOD_BEG ScanKeyboard
static void ScanKeyboard(void);
%-INTERNAL_LOC_METHOD_END ScanKeyboard
%-INTERNAL_LOC_METHOD_BEG ScanJoystick
static void ScanJoystick(void);
%-INTERNAL_LOC_METHOD_END ScanJoystick
%-

%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN init_clock
%ifdef init_clock
%include Common\USB_Host_CMXinit_clock.Inc
void %'ModuleName'%.%init_clock(void)
{
 /* Assume 12MHz external clock source connected. */

  /* In order to use the USB we need to enter PEE mode and MCGOUT set to 48 MHz.
     Out of reset MCG is in FEI mode. */

  /**** Moving from FEI (FLL engaged internal) to PEE (PLL engaged external) mode. */
  /* switch from FEI to FBE (FLL bypassed external) */
    /* enable external clock source */
  MCGC2 = MCGC2_HGO_MASK       /* oscillator in high gain mode */
          | MCGC2_EREFS_MASK   /* because crystal is being used */
          | MCGC2_RANGE_MASK   /* 12 MHz is in high freq range */
          | MCGC2_ERCLKEN_MASK;     /* activate external reference clock */
  while (MCGSC_OSCINIT == 0)
    ;
    /* select clock mode */
  MCGC1 = (2<<6)         /* CLKS = 10 -> external reference clock. */
          | (3<<3);      /* RDIV = 3 -> 12MHz/8=1.5 MHz */

  /* wait for mode change to be done */
  while (MCGSC_IREFST != 0)
    ;
  while (MCGSC_CLKST != 2)
    ;

  /* switch from FBE to PBE (PLL bypassed internal) mode */
  MCGC3=MCGC3_PLLS_MASK
        | (8<<0);     /* VDIV=6 -> multiply by 32 -> 1.5MHz * 32 = 48MHz */
  while(MCGSC_PLLST != 1)
    ;
  while(MCGSC_LOCK != 1)
    ;
  /* finally switch from PBE to PEE (PLL enabled external mode) */
  MCGC1 = (0<<6)         /* CLKS = 0 -> PLL or FLL output clock. */
          | (3<<3);      /* RDIV = 3 -> 12MHz/8=1.5 MHz */
  while(MCGSC_CLKST!=3)
    ;

  /* Now MCGOUT=48MHz, BUS_CLOCK=24MHz */
}

%endif %- init_clock
%-BW_METHOD_END init_clock
%-************************************************************************************************************
%-BW_METHOD_BEGIN stack_init
%ifdef stack_init
%define! Parpattern
%include Common\USB_Host_CMXstack_init.Inc
void %'ModuleName'%.%stack_init(byte pattern)
{
  extern unsigned long far __SP_END;
  byte far * stackEnd  = (byte far*)&__SP_END;
  byte far * stackPointer;
  asm {
    move.l A7,stackPointer
  }
  stackPointer -= 4;
  for (;stackPointer >= stackEnd;)
  {
    *stackPointer-- = pattern;
  }
}

%endif %- stack_init
%-BW_METHOD_END stack_init
%-************************************************************************************************************
%-BW_METHOD_BEGIN stack_size
%ifdef stack_size
%define! Parpattern
%define! RetVal
%include Common\USB_Host_CMXstack_size.Inc
long %'ModuleName'%.%stack_size(byte pattern)
{
  extern unsigned long far __SP_END;
  extern unsigned long far __SP_INIT;
  byte far * stackEnd  = (byte far*)&__SP_END;
  byte far * stackBegin = (byte far*)&__SP_INIT;
  byte far * stackPointer;
  byte far *tempStackPointer = stackEnd;
  long stackSize = 0;

  asm{
   move.l A7,stackPointer
  }

  // Search the stack for pattern
  for(;tempStackPointer <= (stackPointer);tempStackPointer++)
  {
    if(*tempStackPointer != pattern)
    {
       break;
    }
    stackSize++;
  }
  return (stackBegin-stackEnd+1-stackSize);
}

%endif %- stack_size
%-BW_METHOD_END stack_size
%-************************************************************************************************************
%-BW_METHOD_BEGIN hw_init
%ifdef hw_init
%include Common\USB_Host_CMXhw_init.Inc
void %'ModuleName'%.%hw_init(void)
{
%if %CPUDerivative='MCF51JM128'
  /* Disable watchdog. */
  SOPT1_COPT=0;
#ifdef LITTLE_ENDIAN_MODE
  SOPT2  &= ~(1<<5); /* MUST clear bit 5 to use little endian for memory access */
#endif
%if defined(init_clock)
  %'ModuleName'%.init_clock();
%endif
  EnableInterrupts;
%elif %CPUDerivative='MCF52259'
%endif
}

%endif %- hw_init
%-BW_METHOD_END hw_init
%-************************************************************************************************************
%-BW_METHOD_BEGIN Vbus_Sw_En
%ifdef Vbus_Sw_En
%include Common\USB_Host_CMXVbus_Sw_En.Inc
void %'ModuleName'%.%Vbus_Sw_En(void)
{
%if %CPUDerivative='MCFJM128'
#if 0
  PTHD_PTHD4 = 0;  // turn AMD (Vbus) switch on
  PTHDD_PTHDD4 = 1; // Set PTH4 as output to ON of AMD switch
  PTGDD_PTGDD0 = 0; // configure PTG0 as input from FAULT from AMD switch
#endif
%elif %CPUDerivative='MCF52259'
#if 0
  MCF_GPIO_PORTUA &= ~MCF_GPIO_PORTUA_PORTUA3; /* turn AMD (Vbus) switch on */
#endif
%endif
}

%endif %- Vbus_Sw_En
%-BW_METHOD_END Vbus_Sw_En
%-************************************************************************************************************
%-BW_METHOD_BEGIN enable_usb_pull_downs
%ifdef enable_usb_pull_downs
%include Common\USB_Host_CMXenable_usb_pull_downs.Inc
void %'ModuleName'%.%enable_usb_pull_downs(void)
{
#ifndef ON_THE_GO
  /* MUST use external pulldown to connect PTA4 and PTA5 which output 0V.
   * In addition, the internal weak pulldown should be disabled.
   */
%if %CPUDerivative='MCFJM128'
  MCF_USB_OTGPIN = (MCF_USB_OTGPIN_DPDOWN | MCF_USB_OTGPIN_DMDOWN);
%elif %CPUDerivative='MCF52259'
  MCF_USB_OTG_CTRL = MCF_USB_OTG_CTRL_DP_LOW | MCF_USB_OTG_CTRL_DM_LOW |MCF_USB_OTG_CTRL_OTG_EN;
  MCF_GPIO_PQSPAR |= MCF_GPIO_PQSPAR_PQSPAR5(3) | MCF_GPIO_PQSPAR_PQSPAR6(3);
%endif
#endif
}

%endif %- enable_usb_pull_downs
%-BW_METHOD_END enable_usb_pull_downs
%-************************************************************************************************************
%-BW_METHOD_BEGIN host_init
%ifdef host_init
%include Common\USB_Host_CMXhost_init.Inc
#if 0 /* implemented as macro in the header file */
void %'ModuleName'%.%host_init(void)
{
}
#endif

%endif %- host_init
%-BW_METHOD_END host_init
%-************************************************************************************************************
%-BW_METHOD_BEGIN ByteRev32
%ifdef ByteRev32
%define! Parval
%define! RetVal
%include Common\USB_Host_CMXByteRev32.Inc
dword %'ModuleName'%.%ByteRev32(dword val)
{
 /* implementing it as inline assembly routine (and not as assembly).
 That way we are are calling convention independant. */
  asm {
    move val, D0   // get argument into register
    byterev.l D0   // reverse value
    return         // return to caller
  }
}

%endif %- ByteRev32
%-BW_METHOD_END ByteRev32
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG ScanMouse
%include Common\GeneralInternalGlobal.inc (ScanMouse)
static void ScanMouse(void)
{
%if defined(OnMouseMove)
  int16_t x, y, tmp16;
  uint8_t changedXY;
%endif
%if defined(OnMouseButton)
  uint8_t b0, b1, b2, tmp8;
  uint8_t changedB012;
%endif

%if defined(OnMouseMove)
  x = y = 0;
  changedXY = 1;
%endif
%if defined(OnMouseButton)
  b0 = b1 = b2 = 0;
  changedB012 = 1;
%endif
  while (hid_mouse_process()==0) {
%if defined(OnMouseMove)
    if (x != (tmp16=hid_mouse_get_x())) {                        %>40 /* get X position */
      changedXY=1;
      x=tmp16;
    }
    if (y != (tmp16=hid_mouse_get_y())) {                        %>40 /* get Y position */
      changedXY=1;
      y=tmp16;
    }
   if (changedXY) {
     %OnMouseMove(x, y);                                         %>40 /* call user event */
     changedXY = 0;                                              %>40 /* reset */
   }
%endif
%if defined(OnMouseButton)
    if (b0 != (tmp8=hid_mouse_get_button(0))) {                  %>40 /* get B0 status */
      changedB012=1;
      b0=tmp8;
    }
    if (b1 != (tmp8=hid_mouse_get_button(1))) {                  %>40 /* get B1 status */
      changedB012=1;
      b1=tmp8;
    }
    if (b2 != (tmp8=hid_mouse_get_button(2))) {                  %>40 /* get B2 status */
      changedB012=1;
      b2=tmp8;
    }
    if (changedB012) {
      %OnMouseButton(b0, b1, b2);                                %>40 /* call user event */
      changedB012 = 0;                                           %>40 /* reset */
    }
%endif
%if defined(OnIdle)
    %OnIdle();                                                   %>40 /* wait for some time */
%endif
  } /* while */
%if defined(OnDetach)
  %OnDetach(HIDTYPE_MOUSE);                                      %>40 /* call user event */
%endif
}

%-INTERNAL_METHOD_END ScanMouse
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG ScanKeyboard
%include Common\GeneralInternalGlobal.inc (ScanKeyboard)
static void ScanKeyboard(void)
{
  %'ModuleName'_TKeyboardInfoType keys;
  byte keyBuf[6]; /* this holds the number keys which can be pressed at the same time */
  bool changed = TRUE; /* create initial event */
  byte tmp;
  int nkey;
  byte i;

  /* initialize all variables */
  keys.nofKeys = 0;
  keys.l_shift = keys.r_shift = 0;
  keys.l_alt   = keys.r_alt   = 0;
  keys.l_ctrl  = keys.r_ctrl  = 0;
  keys.l_gui   = keys.r_gui   = 0;
  keys.keys = &keyBuf[0];
  for(i=0; i<sizeof(keyBuf)/sizeof(keyBuf[0]); i++) {            %>40 /* initialize array */
    keyBuf[i] = 0;
  }
  while (hid_kbd_process()==0) {
%if %SHIFTKey='yes'
    if (keys.l_shift!=(tmp=hid_kbd_get_lshift())) {
      changed = TRUE;
      keys.l_shift = tmp;
    }
    if (keys.r_shift!=(tmp=hid_kbd_get_rshift())) {
      changed = TRUE;
      keys.r_shift = tmp;
    }
%endif
%if %ALTKey='yes'
    if (keys.l_alt!=(tmp=hid_kbd_get_lalt())) {
      changed = TRUE;
      keys.l_alt = tmp;
    }
    if (keys.r_alt!=(tmp=hid_kbd_get_ralt())) {
      changed = TRUE;
      keys.r_alt = tmp;
    }
%endif
%if %CTRLKey='yes'
    if (keys.l_ctrl!=(tmp=hid_kbd_get_lctrl())) {
      changed = TRUE;
      keys.l_ctrl = tmp;
    }
%endif
%if %CTRLKey='yes'
    if (keys.r_ctrl!=(tmp=hid_kbd_get_rctrl())) {
      changed = TRUE;
      keys.r_ctrl = tmp;
    }
%endif
%if %GUIKey='yes'
    if (keys.l_gui!=(tmp=hid_kbd_get_lgui())) {
      changed = TRUE;
      keys.l_gui = tmp;
    }
    if (keys.r_gui!=(tmp=hid_kbd_get_rgui())) {
      changed = TRUE;
      keys.r_gui = tmp;
    }
%endif
    nkey = hid_kbd_get_nkey();
    if (nkey > sizeof(keyBuf)) {                                 %>40 /* avoid buffer overflow */
      nkey = sizeof(keyBuf);
    }
    keys.nofKeys = (byte)nkey;
    for(i=0; i<nkey; i++) {                                      %>40 /* get the keys pressed */
      if (keyBuf[i]!=(tmp=hid_kbd_get_key(i))) {
        changed = TRUE;
        keyBuf[i] = tmp;
      }
    }
    while(i<sizeof(keyBuf)/sizeof(keyBuf[0])) {                  %>40 /* need to check as well the remainder */
      if (keyBuf[i]!=0) {
        changed = TRUE;
        keyBuf[i] = 0;
      }
      i++;
    }
    if (changed) {
%if defined(OnKeyboardRawKey)
      %OnKeyboardRawKey(&keys);                                  %>40 /* call user event */
%endif
%if defined(OnKeyboardKey)
      for(i=0; i<keys.nofKeys; i++) {                            %>40 /* get the keys pressed */
%if %SHIFTKey='yes'
        tmp = RawToChar[keyBuf[i]][keys.l_shift|keys.r_shift];   %>40 /* translate to ASCII code */
%else
        tmp = RawToChar[keyBuf[i]][0];                           %>40 /* translate to ASCII code */
%endif
        if (tmp != 0) {                                          %>40 /* valid translation */
          %OnKeyboardKey(tmp);                                   %>40 /* call user event */
        }
      } /* for */
%endif
      changed = FALSE;                                           %>40 /* reset */
    }
%if defined(OnIdle)
    %OnIdle();                                                   %>40 /* wait for some time */
%endif
  } /* while */
%if defined(OnDetach)
  %OnDetach(HIDTYPE_KBD);                                        %>40 /* call user event */
%endif
}

%-INTERNAL_METHOD_END ScanKeyboard
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG ScanJoystick
%include Common\GeneralInternalGlobal.inc (ScanJoystick)
static void ScanJoystick(void)
{
  while (hid_joy_process()==0) {
%if defined(OnIdle)
    %OnIdle();                                                   %>40 /* wait for some time */
%endif
  } /* while */
%if defined(OnDetach)
  %OnDetach(HIDTYPE_JOY);                                        %>40 /* call user event */
%endif
}

%-INTERNAL_METHOD_END ScanJoystick
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScanDevices
%ifdef ScanDevices
%define! ParHID_type
%define! RetVal
%include Common\USB_Host_CMXScanDevices.Inc
byte %'ModuleName'%.%ScanDevices(void)
{
  byte hid_type;
  int res;

  res = host_scan_for_device();                                  %>40 /* check for device */
  if (res==0) {                                                  %>40 /* driver says no device available */
    return ERR_NOTAVAIL;                                         %>40 /* no device available */
  }
  if (res==2) {                                                  %>40 /* driver says there is a device, but does not respond? */
    return ERR_BUSOFF;                                           %>40 /* you may need to re-init the bus? */
  }
  if (hid_init()!=0) {                                           %>40 /* initialize HID device */
    return ERR_FAULT;                                            %>40 /* failed initializing device */
  }
  hid_type = hid_get_dev_type();
%if defined(OnAttach)
  %OnAttach(hid_type);                                           %>40 /* call user event */
%endif
  switch(hid_type) {
    case HIDTYPE_MOUSE:
%if defined(OnMouseMove) | defined(OnMouseButton)
      ScanMouse();
%endif
      break;
    case HIDTYPE_KBD:
%if defined(OnKeyboardRawKey) | defined(OnKeyboardKey)
      ScanKeyboard();
%endif
      break;
    case HIDTYPE_JOY:
      break;
    case HIDTYPE_UNKNOWN:
      break;
    default:
      return ERR_FAULT;
  }
  return ERR_OK;
}

%endif %- ScanDevices
%-BW_METHOD_END ScanDevices
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%define! RetVal
%include Common\USB_Host_CMXInit.Inc
byte %'ModuleName'%.%Init(void)
{
  %'ModuleName'%.hw_init();
  %'ModuleName'%.Vbus_Sw_En();
  %'ModuleName'%.host_init();
  return ERR_OK;
}

%endif %- Init
%-BW_METHOD_END Init
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_METHOD_BEGIN OnAttach
%ifdef OnAttach
%IMPLEMENTATION OnAttach
%define! Parhid_type
%include Common\USB_Host_CMXOnAttach.Inc
void %OnAttach(byte hid_type)
{
  /* Write your code here ... */
#if 0 /* example code follows... */
  switch(hid_type) {
    case HIDTYPE_MOUSE:   Term1_SendStr("Mouse attached...\r\n"); break;
    case HIDTYPE_KBD:     Term1_SendStr("Keyboard attached...\r\n"); break;
    case HIDTYPE_JOY:     Term1_SendStr("Joystick attached...\r\n"); break;
    default:
    case HIDTYPE_UNKNOWN: Term1_SendStr("Unknown device attached...\r\n"); break;
  }
#endif
}

%endif %- OnAttach
%-BW_METHOD_END OnAttach
%-BW_METHOD_BEGIN OnDetach
%ifdef OnDetach
%IMPLEMENTATION OnDetach
%define! Parhid_type
%include Common\USB_Host_CMXOnDetach.Inc
void %OnDetach(byte hid_type)
{
  /* Write your code here ... */
#if 0 /* example code follows... */
  switch(hid_type) {
    case HIDTYPE_MOUSE:   Term1_SendStr("Mouse detached...\r\n"); break;
    case HIDTYPE_KBD:     Term1_SendStr("Keyboard detached...\r\n"); break;
    case HIDTYPE_JOY:     Term1_SendStr("Joystick detached...\r\n"); break;
    default:
    case HIDTYPE_UNKNOWN: Term1_SendStr("Unknown device detached...\r\n"); break;
  }
#endif
}

%endif %- OnDetach
%-BW_METHOD_END OnDetach
%-BW_METHOD_BEGIN OnMouseMove
%ifdef OnMouseMove
%IMPLEMENTATION OnMouseMove
%define! Parx
%define! Pary
%include Common\USB_Host_CMXOnMouseMove.Inc
void %OnMouseMove(int x, int y)
{
  /* Write your code here ... */
#if 0 /* example code follows */
  char buf[38];

  UTIL1_strcpy(buf, sizeof(buf), "Mouse move: x");
  UTIL1_strcatNum16sFormatted(buf, sizeof(buf), (int16_t)x, ' ', 7);
  UTIL1_strcat(buf, sizeof(buf), ", y");
  UTIL1_strcatNum16sFormatted(buf, sizeof(buf), (int16_t)y, ' ', 7);
  UTIL1_strcat(buf, sizeof(buf), "\r\n");
  Term1_SendStr(buf);
#endif
}

%endif %- OnMouseMove
%-BW_METHOD_END OnMouseMove
%-BW_METHOD_BEGIN OnMouseButton
%ifdef OnMouseButton
%IMPLEMENTATION OnMouseButton
%define! Parbutton1
%define! Parbutton2
%define! Parbutton0
%include Common\USB_Host_CMXOnMouseButton.Inc
void %OnMouseButton(byte button0, byte button1, byte button2)
{
  /* Write your code here ... */
#if 0 /* example code follows... */
  Term1_SendStr("Mouse buttons: ");
  if (button0==1) {
    Term1_SendStr("ON  ");
  } else {
    Term1_SendStr("OFF ");
  }
  if (button1==1) {
    Term1_SendStr("ON  ");
  } else {
    Term1_SendStr("OFF ");
  }
  if (button2==1) {
    Term1_SendStr("ON\r\n");
  } else {
    Term1_SendStr("OFF\r\n");
  }
#endif
}

%endif %- OnMouseButton
%-BW_METHOD_END OnMouseButton
%-BW_METHOD_BEGIN OnKeyboardRawKey
%ifdef OnKeyboardRawKey
%IMPLEMENTATION OnKeyboardRawKey
%define! Parkeys
%include Common\USB_Host_CMXOnKeyboardRawKey.Inc
void %OnKeyboardRawKey(%'ModuleName'_TKeyboardInfoType *keys)
{
  /* Write your code here ... */
#if 0 /* example code follows... */
  byte nof, i;
  char buf[12];

  Term1_SendStr("keyboard raw keys: ");
  if (keys->l_shift || keys->r_shift) {
    Term1_SendStr("SHIFT-");
  }
  if (keys->l_alt || keys->r_alt) {
    Term1_SendStr("ALT-");
  }
  if (keys->l_ctrl || keys->r_ctrl) {
    Term1_SendStr("CTRL-");
  }
  if (keys->l_gui || keys->r_gui) {
    Term1_SendStr("GUI-");
  }
  nof = keys->nofKeys;
  if (nof != 0) {
    for(i=0;i<nof;i++) {
      buf[0] = '\0';
      UTIL1_strcatNum16sFormatted(buf, sizeof(buf), keys->keys[i], ' ', 4);
      UTIL1_strcat(buf, sizeof(buf), " ");
      Term1_SendStr(buf);
    }
  }
  Term1_SendStr("\r\n");
#endif
}

%endif %- OnKeyboardRawKey
%-BW_METHOD_END OnKeyboardRawKey
%-BW_METHOD_BEGIN OnKeyboardKey
%ifdef OnKeyboardKey
%IMPLEMENTATION OnKeyboardKey
%define! Parch
%include Common\USB_Host_CMXOnKeyboardKey.Inc
void %OnKeyboardKey(byte ch)
{
  /* Write your code here ... */
#if 0 /* example code follows... */
  Term1_SendStr("keyboard key: ");
  Term1_SendChar(ch);
  Term1_SendStr("\r\n");
#endif
}

%endif %- OnKeyboardKey
%-BW_METHOD_END OnKeyboardKey
%-BW_METHOD_BEGIN OnIdle
%ifdef OnIdle
%IMPLEMENTATION OnIdle
%include Common\USB_Host_CMXOnIdle.Inc
void %OnIdle(void)
{
  /* Write your code here ... */
}

%endif %- OnIdle
%-BW_METHOD_END OnIdle
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
  /* Write code here ... */
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-

%else %- Language (& Compiler)
  %error^ This bean is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
%-*****************************************************************************************************
%FILE %'DirRel_Code'usb_host.h
%-*****************************************************************************************************
/***************************************************************************
 *
 *            Copyright (c) 2006-2007 by CMX Systems, Inc.
 *
 * This software is copyrighted by and is the sole property of
 * CMX.  All rights, title, ownership, or other interests
 * in the software remain the property of CMX.  This
 * software may only be used in accordance with the corresponding
 * license agreement.  Any unauthorized use, duplication, transmission,
 * distribution, or disclosure of this software is expressly forbidden.
 *
 * This Copyright notice may not be removed or modified without prior
 * written consent of CMX.
 *
 * CMX reserves the right to modify this software without notice.
 *
 * CMX Systems, Inc.
 * 12276 San Jose Blvd. #511
 * Jacksonville, FL 32223
 * USA
 *
 * Tel:  (904) 880-1840
 * Fax:  (904) 880-1632
 * http: www.cmx.com
 * email: cmx@cmx.com
 *
 ***************************************************************************/
#ifndef _USB_HOST_H_
#define _USB_HOST_H_

#include "hcc_types.h"

/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif

/* Transaction types. */
#define TRT_NONE  0u
#define TRT_IN    1u
#define TRT_OUT   2u
#define TRT_SETUP 3u

#define INVALID_ADDRESS  ((hcc_u8)-1u)
#define RETVAL_ERROR  ((hcc_u16) -1u)
#define DEVICE_IS_INVALID(dt, dev)  ((dt)[(dev)].address == INVALID_ADDRESS)

/* Access common properties of USB descriptors. */
#define USBDSC_LENGTH(p)  (((hcc_u8*)(p))[0])
#define USBDSC_TYPE(p)    (((hcc_u8*)(p))[1])

/* Read device descriptor members. */
#define DEVDESC_BCDUSB(p)      RD_LE16(((hcc_u8*)(p))+2)
#define DEVDESC_CLASS(p)       (((hcc_u8*)(p))[4])
#define DEVDESC_SCLASS(p)      (((hcc_u8*)(p))[5])
#define DEVDESC_PROTOCOL(p)    (((hcc_u8*)(p))[6])
#define DEVDESC_PACKET_SIZE(p) (((hcc_u8*)(p))[7])
#define DEVDESC_VID(p)         RD_LE16(((hcc_u8*)(p))+8)
#define DEVDESC_PID(p)         RD_LE16(((hcc_u8*)(p))+10)
#define DEVDESC_REV(p)         RD_LE16(((hcc_u8*)(p))+12)
#define DEVDESC_MANUFACT(p)   (((hcc_u8*)(p))[14))
#define DEVDESC_PRODUCT(p)    (((hcc_u8*)(p))[15])
#define DEVDESC_SERNO(p)      (((hcc_u8*)(p))[16])
#define DEVDESC_NCFG(p)       (((hcc_u8*)(p))[17])

/* Read configuration descriptor members. */
#define CONFDESC_TOTLENGTH(p) RD_LE16(((hcc_u8*)(p))+2)
#define CONFDESC_INTRFACES(p) (((hcc_u8*)(p))[4])
#define CONFDESC_MY_NDX(p)    (((hcc_u8*)(p))[5])
#define CONFDESC_MY_STR(p)    (((hcc_u8*)(p))[6])
#define CONFDESC_ATTRIB(p)    (((hcc_u8*)(p))[7])
#define CONFDESC_MAX_POW(p)   (((hcc_u8*)(p))[8])

/* Read interface descriptor members. */
#define IFCDESC_MY_NDX(p)     (((hcc_u8*)(p))[2])
#define IFCDESC_ALTERNATE(p)  (((hcc_u8*)(p))[3])
#define IFCDESC_ENDPONTS(p)   (((hcc_u8*)(p))[4])
#define IFCDESC_CLASS(p)      (((hcc_u8*)(p))[5])
#define IFCDESC_SCLASS(p)     (((hcc_u8*)(p))[6])
#define IFCDESC_PROTOCOL(p)   (((hcc_u8*)(p))[7])
#define IFCDESC_MY_STR(p)     (((hcc_u8*)(p))[8])

#define EPDESC_ADDRESS(p)     (((hcc_u8*)(p))[2])
#define EPDESC_ATTRIB(p)      (((hcc_u8*)(p))[3])
#define EPDESC_PSIZE(p)       RD_LE16(((hcc_u8*)(p))+4)
#define EPDESC_INTERVAL(p)    (((hcc_u8*)(p))[6])

#define EPTYPE_INVALID        ((hcc_u8)-1u)
#define EPTYPE_CTRL           ((hcc_u8)0u)
#define EPTYPE_ISO            ((hcc_u8)1u)
#define EPTYPE_BULK           ((hcc_u8)2u)
#define EPTYPE_INT            ((hcc_u8)3u)


/* Driver returns information extracted from device descriptors using this
   type. */
typedef struct {
  hcc_u16 vid;
  hcc_u16 pid;
  hcc_u16 rev;
  hcc_u8  clas;
  hcc_u8  sclas;
  hcc_u8  protocol;
  hcc_u8  ncfg;
} device_info_t;

/* Driver returns information extracted from interface descriptors using this
   type. */
typedef struct {
  hcc_u8 clas;
  hcc_u8 sclas;
  hcc_u8 protocol;
  hcc_u8 ndx;
  hcc_u8 alt_set;
  hcc_u8 str;
  hcc_u8 nep;
} ifc_info_t;

/* Driver returns information extracted from configuration descriptors using
   this type. */
typedef struct {
  hcc_u8 nifc;
  hcc_u8 ndx;
  hcc_u8 str;
  hcc_u8 attrib;
  hcc_u8 max_power;
} cfg_info_t;

/* Driver returns information extracted from endpoint descriptors using this
   type. */
typedef struct {
  hcc_u16 psize;
  hcc_u8 address;
  hcc_u8 type;
  hcc_u8 interval;
} ep_info_t;

/* Error codes. */
typedef enum {
  tre_none=0,
  tre_not_running,  /* host operation disabled */
  tre_no_device,    /* no device connected */
  tre_disconnected, /* device has been disconnected */
  tre_stall,        /* endpoint halted by device*/
  tre_data_error,   /* communicatin error (CRC, etc...)*/
  tre_silent,       /* device returned no handshake at all */
  tre_no_ep         /* endpoint not configured */
} tr_error_t;

extern tr_error_t tr_error;
/* Driver call this. Shall enable pull down resistors. */
extern void enable_usb_pull_downs(void);
/* Shall be called before any other call. Initializes driver and hardware. */
extern void host_init(void);
/* Stop host functionality. */
extern void host_stop(void);
/* Send USB reset to connected device. */
extern void host_reset_bus(void);
/* Send data to the device on the control channel. */
extern hcc_u16 host_send_control(hcc_u8 *setup_data, hcc_u8* buffer, hcc_u8 ep);
/* Get data from device on the control channel. */
extern hcc_u16 host_receive_control(hcc_u8 *setup_data, hcc_u8* buffer, hcc_u8 ep);
/* Send data to the device on non control channels. */
extern hcc_u32 host_send(hcc_u8* buffer, hcc_u32 length, hcc_u8 ep);
/* Get data from device on non control channels. */
extern hcc_u32 host_receive(hcc_u8* buffer, hcc_u32 length, hcc_u8 ep);

/* Define an endpoint for the device. Driver above the host driver shall call
   it when selecting a configuration. */
extern hcc_u8 host_add_ep(hcc_u8 type, hcc_u8 address, hcc_u8 interval, hcc_u16 psize);
/* Remove an endpoint for the device. Driver above the host driver shall call
   it when selecting a configuration. */
extern void host_remove_ep(hcc_u8 ep_handle);
/* Modifi an endpoint of the device. Driver above the host driver may call
   it when selecting a configuration. */
extern void host_modify_ep(hcc_u8 ep_handle, hcc_u8 type, hcc_u8 address, hcc_u8 interval, hcc_u16 psize);
/* This function will wait the specifyed number of mS. */
#if 1 /* adaption for Processor Expert */
#define host_ms_delay(ms) ((ms)<=20?%@Wait@'ModuleName'%.Waitms(ms):%@Wait@'ModuleName'%.WaitOSms(ms))
#else
extern void host_ms_delay(hcc_u32);
#endif
/* Check if a device is connected, and do basic configuration. */
extern int host_scan_for_device(void);
/* Return non0 if a device is connected. Use to see if a the device is still
   connected.*/
extern hcc_u8 host_has_device(void);

extern void host_sleep(void);
extern void host_wakeup(void);
#endif
/****************************** END OF FILE **********************************/
%-*****************************************************************************************************
%FILE %'DirRel_Code'usb_host.c
%-*****************************************************************************************************
/****************************************************************************
 *
 *            Copyright (c) 2006-2007 by CMX Systems, Inc.
 *
 * This software is copyrighted by and is the sole property of
 * CMX.  All rights, title, ownership, or other interests
 * in the software remain the property of CMX.  This
 * software may only be used in accordance with the corresponding
 * license agreement.  Any unauthorized use, duplication, transmission,
 * distribution, or disclosure of this software is expressly forbidden.
 *
 * This Copyright notice may not be removed or modified without prior
 * written consent of CMX.
 *
 * CMX reserves the right to modify this software without notice.
 *
 * CMX Systems, Inc.
 * 12276 San Jose Blvd. #511
 * Jacksonville, FL 32223
 * USA
 *
 * Tel:  (904) 880-1840
 * Fax:  (904) 880-1632
 * http: www.cmx.com
 * email: cmx@cmx.com
 *
 ***************************************************************************/
#include "hcc_types.h"
%if %CPUDerivative='MCF51JM128'
#include "mcf51xx_reg.h"
%elif %CPUDerivative='MCF52259'
#include "mcf5222x_reg.h"
%endif
#include "usb_host.h"
#include "usb_utils.h"

#define DEBUG_TRACE 0u
#define DSC_BUG 0u

/*****************************************************************************
 * Macro definitions.
 *****************************************************************************/
#define MIN(a,b)  ((a) < (b) ? (a) : (b))

/* Number of maximum endpoints supported per device. */
#define MAX_EP_PER_DEVICE  3u

/* This macro shall evaluate to a uint32 pointer to the start address of the
   buffer descriptor table (BDT). The BDT has 32 bytes for each endpoint.
   The BDT shall be alignet to 512 byte boundary! */
extern hcc_u32 _BDT_BASE[];

#if 0 /* adaption for Processor Expert */
extern hcc_u32 _BDT_BASE[];
#else
#define _BDT_BASE ((hcc_u32*)0x%#l%BDTBase) /* 512 bytes, aligned at 512 byte boundaries */
#endif
#define BDT_BASE              ((hcc_u32*)(_BDT_BASE))
#define BDT_CTL_RX(ep, b)     (BDT_BASE[((ep)<<3)+((b)<<1)+0])
#define BDT_ADR_RX(ep, b)     (BDT_BASE[((ep)<<3)+((b)<<1)+1])
#define BDT_CTL_TX(ep, b)     (BDT_BASE[((ep)<<3)+((b)<<1)+4])
#define BDT_ADR_TX(ep, b)     (BDT_BASE[((ep)<<3)+((b)<<1)+5])

#define BDT_CTL_STALL BIT2
#define BDT_CTL_DTS   BIT3
#define BDT_CTL_DATA  BIT6
#define BDT_CTL_OWN   BIT7

/* Token values. */
#define TOKEN_SETUP   0xd
#define TOKEN_IN      0x9
#define TOKEN_OUT     0x1
#define TOKEN_NAK     0xa
#define TOKEN_STALL   0xe
#define TOKEN_ACK     0x2

/* Maximum possible packet size for endpoint 0. */
#define MAX_EP0_PSIZE   64u
#define MIN_EP0_PSIZE   8u

#if DEBUG_TRACE == 1
#define MKDBG_TRACE(evnt, epndx)   (evstk[evndx].ev=(evnt), evstk[evndx++].ep=(epndx))
#else
#define MKDBG_TRACE(evnt, epndx)
#endif


/*****************************************************************************
 * External references.
 *****************************************************************************/
/* none */

/*****************************************************************************
 * Local types.
 *****************************************************************************/
 /* Information about endpoints of connected devices. */
 typedef struct {
  hcc_u16 last_due;
  hcc_u16 psize;
  hcc_u8 type;
  hcc_u8 address;
  hcc_u8 interval;
  hcc_u8 tgl_rx;
  hcc_u8 tgl_tx;
} device_ep_t;

/* Information about connected devices. */
typedef struct {
  hcc_u8 address;
  hcc_u8 low_speed;
  device_ep_t eps[MAX_EP_PER_DEVICE];
} dev_table_element_t;

#if DEBUG_TRACE == 1
enum event
{
  ev_none = 0,
  ev_bus_reset,
  ev_host_init,
  ev_no_attach,
  ev_attach_ls_dev,
  ev_attach_fs_dev,
  ev_host_stop,
  ev_trt_setup,
  ev_trt_in,
  ev_trt_out,
  ev_got_ack,
  ev_got_nak,
  ev_got_stall,
  ev_got_unknown,
  ev_got_data_error,
  ev_disconnect,
  ev_send_control,
  ev_receive_control,
  ev_send,
  ev_receive,
  ev_no_device,
  ev_no_ep,
  ev_ep0_psize_failed,
  ev_set_address_failed
};
#endif
/*****************************************************************************
 * Module variables.
 *****************************************************************************/
#if DEBUG_TRACE == 1

volatile hcc_u8 evndx=0;

struct
{
  enum event ev;
  hcc_u8 ep;
} evstk[1<<(sizeof(evndx)<<3)];

#endif

/* This structure tells us which packet buffer was last used for TX and RX. */
struct {
  hcc_u8 next_rx;
  hcc_u8 next_tx;
} ep_info;

/* This table contains information about connected devices. Since we do not
   support external HUBS and this hardware has no ROOT HUB, only one device
   can be connected at a time. */
dev_table_element_t my_device;

/* Error code for the device. */
tr_error_t tr_error;
/*****************************************************************************
 * Function prototypes
 *****************************************************************************/
/*  */

/*****************************************************************************
 * Function declarations
 *****************************************************************************/

/*****************************************************************************
 * evt_disconnect
 * IN:  -
 * OUT: -
 * Assumptions:
 * Description:
 *   Put hardware and firmware to disconnected state.
 *****************************************************************************/
static void evt_disconnect(void)
{
  MKDBG_TRACE(ev_disconnect, 0);

#if DSC_BUG == 0
  while(MCF_USB_CTL & MCF_USB_CTL_TXDSUSPEND_TOKBUSY)
  {
    if (MCF_USB_INT_STAT & MCF_USB_INT_STAT_USB_RST)
    {
      MCF_USB_CTL &= ~MCF_USB_CTL_TXDSUSPEND_TOKBUSY;
      break;
    }
  }
#endif

  my_device.address = INVALID_ADDRESS;
  my_device.low_speed = 0;
  /* disable SOF generation */

  MCF_USB_INT_STAT = MCF_USB_INT_STAT_USB_RST | MCF_USB_INT_STAT_ATTACH;
  host_sleep();
}

static hcc_u8 evt_connect(void)
{
  hcc_u8 ep;

  /* debounce (100 mS) */
  host_ms_delay(100);

  /* clear attach event */
  MCF_USB_INT_STAT = MCF_USB_INT_STAT_ATTACH;

  /* Some delay is needed between clearing the ATTACH flag, and checking
     it again. Unfortunately there is no information about the length of
     the delay. */
  host_ms_delay(10);

  /* Is a device connected? */
  if((MCF_USB_INT_STAT & MCF_USB_INT_STAT_ATTACH) == 0)
  { /* no */
    return(0);
  }

  /* A newly connected device shall have address 0, */
  my_device.address=0;

  /* and only ep0 is working. We assume packet size of
     ep0 is the possible minimum. We will read the real
     value during enumeration. */
  host_modify_ep(0, EPTYPE_CTRL, 0, 0, MIN_EP0_PSIZE);

  /* remove all endpoints except 0 */
  for(ep=1;ep<MAX_EP_PER_DEVICE;ep++)
  {
    host_remove_ep(ep);
  }

  /* clear low speed bit to make JSTATE detection consistent. */
  MCF_USB_ADDR=0;

  /* let settle D+ and D- to the right state */
  host_ms_delay(1);

  /* Check if device is low or high speed. */
  if ((MCF_USB_CTL & MCF_USB_CTL_JSTATE) == 0)
  {
    MKDBG_TRACE(ev_attach_ls_dev, 0);
    /* Low speed device. */
    my_device.low_speed=1;
%if %CPUDerivative='MCF52259'
    MCF_USB_ADDR = MCF_USB_ADDR_LS_EN;
%endif
  }
  else
  {
    MKDBG_TRACE(ev_attach_fs_dev, 0);
    my_device.low_speed=0;
  }
  return(1);
}

static hcc_u8 chk_dev(void)
{
  if (my_device.address != INVALID_ADDRESS)
  {
    /* If a reset was seen while we have not been issued a reset, then
       the device is disconnected (surprise removal). */
    if (MCF_USB_INT_STAT & MCF_USB_INT_STAT_USB_RST)
    {
      evt_disconnect();
    }
  }

  if (my_device.address == INVALID_ADDRESS)
  {
    /* If we can not clear the attach flag, then a device is connected. */
    MCF_USB_INT_STAT = MCF_USB_INT_STAT_ATTACH;

    /* the host then waits for at
     least 100 ms to allow completion of an insertion process and
     for power at the device to become stable. */
    host_ms_delay(100);

    if (MCF_USB_INT_STAT & MCF_USB_INT_STAT_ATTACH)
    {
      evt_connect();
    }
  }
  return((hcc_u8)(my_device.address != INVALID_ADDRESS));
}
/*****************************************************************************
 * host_has_device
 * IN:  -
 * OUT: -
 * Assumptions:
 * Description:
 *   Return true if a device is still connected.
 *****************************************************************************/
hcc_u8 host_has_device(void)
{
  if ((MCF_USB_CTL & MCF_USB_CTL_HOST_MODE_EN) == 0)
  {
    tr_error=tre_not_running;
    return(0);
  }
  tr_error=tre_none;
  return chk_dev();
}


/*****************************************************************************
 * host_add_ep
 * IN:
 *     type:     type of endpoint
 *     address:  address of endpoint
 *     interval: poll interval for periodic endpoints
 *     psize:    maximum packet size
 * OUT:
 *     endpoint handle
 * Assumptions:
 * Description:
 *   Add a new endpoint to a device
 *****************************************************************************/
hcc_u8 host_add_ep(hcc_u8 type, hcc_u8 address, hcc_u8 interval, hcc_u16 psize)
{
  hcc_u8 x;

  if ((MCF_USB_CTL & MCF_USB_CTL_HOST_MODE_EN) == 0)
  {
    tr_error=tre_not_running;
    return(INVALID_ADDRESS);
  }

  for(x=0; x < MAX_EP_PER_DEVICE; x++)
  {
    if (my_device.eps[x].address == INVALID_ADDRESS)
    {
      my_device.eps[x].type=type;
      my_device.eps[x].address=(hcc_u8)(address & 0x7f);
      my_device.eps[x].interval=interval;
      my_device.eps[x].psize=psize;
      my_device.eps[x].tgl_rx=0;
      my_device.eps[x].tgl_tx=0;
      my_device.eps[x].last_due=0;
      return(x);
    }
  }
  return(INVALID_ADDRESS);
}

/*****************************************************************************
 * host_remove_ep
 * IN:  ep_handle: handle of endpoint
 * OUT: n/a
 * Assumptions:
 *   The parameter is a valid handle.
 * Description:
 *   Remove an dendpoint of a device.
 *****************************************************************************/
void host_remove_ep(hcc_u8 ep_handle)
{
  CMX_ASSERT(ep_handle < MAX_EP_PER_DEVICE);

  my_device.eps[ep_handle].address=INVALID_ADDRESS;
}

/*****************************************************************************
 * host_modify_ep
 * IN:
 *     ep_handle: handle of an endpoint
 *     type:      type of endpoint
 *     address:   address of endpoint
 *     interval:  poll interval for periodic endpoints
 *     psize:     maximum packet size
 * OUT:
 * Assumptions:
 * Description:
 *   Add a new endpoint to a device
 *****************************************************************************/
void host_modify_ep(hcc_u8 ep_handle, hcc_u8 type, hcc_u8 address, hcc_u8 interval, hcc_u16 psize)
{
  CMX_ASSERT(ep_handle < MAX_EP_PER_DEVICE);
  my_device.eps[ep_handle].type=type;
  my_device.eps[ep_handle].address=address;
  my_device.eps[ep_handle].interval=interval;
  my_device.eps[ep_handle].psize=psize;
}

/*****************************************************************************
 * host_reset_bus
 * IN: n/a
 * OUT: n/a
 * Assumptions: n/a
 * Description:
 *   Do reset signaling on the USB bus.
 *****************************************************************************/

void host_reset_bus(void)
{
  hcc_u8 ep=0;

  MKDBG_TRACE(ev_bus_reset, 0);

#if 1 /* <<EST works if we set here a breakpoint? Inserting some delay */
  host_ms_delay(50);
#endif

  if ((MCF_USB_CTL & MCF_USB_CTL_HOST_MODE_EN) == 0)
  {
    tr_error=tre_not_running;
    return;
  }

  /********* Prepare for BUS reset. */
  /* Wait till pending tokens are processed. */
#if DSC_BUG == 0
  while(MCF_USB_CTL & MCF_USB_CTL_TXDSUSPEND_TOKBUSY)
  {
    if (MCF_USB_INT_STAT & MCF_USB_INT_STAT_USB_RST)
    {
      MCF_USB_CTL &= ~MCF_USB_CTL_TXDSUSPEND_TOKBUSY;
      break;
    }
  }
#endif
  /********* reset */
  /* Start reset signaling. */
  MCF_USB_CTL |= MCF_USB_CTL_RESET;

  /* The minumum reset signal length is 10 mS. We use an 1 mS timer so it has
     at least 1mS error (1 period). USB specifies +-0.05%% accuracy for frame
     interval. So we are good enough if we wait for 11 SOF due times. */
  host_ms_delay(11);

  /* stop reset signaling */
  MCF_USB_CTL &= ~MCF_USB_CTL_RESET;

  /* Clear reset event. */
  MCF_USB_INT_STAT = MCF_USB_INT_STAT_USB_RST | MCF_USB_INT_STAT_SOF_TOK;

  /********* do firmware reset */
  /* A reset device shall have address 0, */
  if (my_device.address != INVALID_ADDRESS)
  {
    my_device.address=0;
  }

  /* and only ep0 is working. We assume packet size of
     ep0 is the possible minimum. We will read the real
     value during enumeration. */
  host_modify_ep(0, EPTYPE_CTRL, 0, 0, MIN_EP0_PSIZE);
  //ENDPT0 = 0x0d;

  /* remove all endpoints except 0 */
  for(ep=1;ep<MAX_EP_PER_DEVICE;ep++)
  {
    host_remove_ep(ep);
  }

  /* check if we have a device connected */
  /* if a device is connected, it will answer to address 0 */
#if 1 /* <<EST works if we set here a breakpoint? Inserting some delay */
  host_ms_delay(50);
#endif
  if (chk_dev())
  {

    MCF_USB_INT_STAT = MCF_USB_INT_STAT_SLEEP | MCF_USB_INT_STAT_RESUME;

     /* enable SOF generation */
    MCF_USB_CTL |= MCF_USB_CTL_USB_EN_SOF_EN;
     /* Read out endpoint 0 packet size. */
    if (set_ep0_psize())
    {
      MKDBG_TRACE(ev_ep0_psize_failed, (hcc_u8)-1u);
      return;
    }
    /* set device address */
    if (set_address(1))
    {
      MKDBG_TRACE(ev_set_address_failed, (hcc_u8)-1u);
      return;
    }
    my_device.address=1;
  }
}

/*****************************************************************************
 * host_init
 * IN: n/a
 * OUT: n/a
 * Assumptions: n/a
 * Description:
 *   Initialize host.
 *****************************************************************************/
void host_init(void)
{
  hcc_u8 ep;
  MKDBG_TRACE(ev_host_init, 0);
  /****** inicialize module variables. */
  my_device.address=INVALID_ADDRESS;
  ep_info.next_tx=0;
  ep_info.next_rx=0;
  tr_error=tre_none;

  /* remove all endpoints */
  for(ep=0;ep<MAX_EP_PER_DEVICE;ep++)
  {
    host_remove_ep(ep);
  }
  /****** Configure hardware. */
%if %CPUDerivative='MCF51JM128'
  /* Reset USB module first. */
  USBTRC0_USBRESET = 1;
  while (USBTRC0_USBRESET) {}
%endif
  /* Clear all pending events. */
  MCF_USB_INT_STAT = 0xff;

  /* select USB clock source and enable internal weak pulldowns */
%if %CPUDerivative='MCF51JM128'
  MCF_USB_USB_CTRL = MCF_USB_USB_CTRL_CLKSRC_SYS
  #ifndef ON_THE_GO
//                    | MCF_USB_USB_CTRL_PDE
  #endif
  ;
%elif %CPUDerivative='MCF52259'
  MCF_USB_USB_CTRL = MCF_USB_USB_CTRL_CLKSRC_OSC;
%endif

  /* use first rx and tx buffer */
  MCF_USB_CTL |= MCF_USB_CTL_ODD_RST;

  /* set BDT address */
  MCF_USB_BDT_PAGE_01 = (hcc_u8)(((hcc_u32)BDT_BASE) >> 8);
  MCF_USB_BDT_PAGE_02 = (hcc_u8)(((hcc_u32)BDT_BASE) >> 16);
  MCF_USB_BDT_PAGE_03 = (hcc_u8)(((hcc_u32)BDT_BASE) >> 24);

  /* Set SOF threshold */
  MCF_USB_SOF_THLDL = 74;

  /* Enable pull-down resistors. */
  %'ModuleName'%.enable_usb_pull_downs();

%if %CPUDerivative='MCF51JM128'
  USBTRC0_USBVREN = 1;

  ADDR = 0;
%endif
  /* Enable host operation mode. */
  MCF_USB_CTL = MCF_USB_CTL_HOST_MODE_EN;
}

/*****************************************************************************
 * host_scan_for_device
 * IN: n/a
 * OUT: 0: no device
 *      1: device detected
 * adoption by EST for Processor Expert
 *      2: there is a device, but bus reset failed
 * Assumptions: n/a
 * Description:
 *   Check if the device has been attached. If yes, set its basic parameters.
 *****************************************************************************/
int host_scan_for_device(void)
{
  if ((MCF_USB_CTL & MCF_USB_CTL_HOST_MODE_EN) == 0)
  {
    tr_error=tre_not_running;
    return(0);
  }

  tr_error=tre_none;

  if (chk_dev())
  {
    host_reset_bus();
    if (tr_error!= tre_none)
    {
#if 1 /* << EST: need to have a way to find out if we should reset the bus */
      return 2;
#else
      return(0);
#endif
    }
    return(1);
  }
  return(0);
}

/*****************************************************************************
 * host_stop
 * IN: n/a
 * OUT: n/a
 * Assumptions: n/a
 * Description:
 *   Stop host operation.
 *****************************************************************************/
void host_stop(void)
{
  MKDBG_TRACE(ev_host_stop, 0);

  if ((MCF_USB_CTL & MCF_USB_CTL_HOST_MODE_EN) == 0)
  {
    tr_error=tre_not_running;
    return;
  }

  /* Disable all interrupt sources. */
  MCF_USB_INT_ENB = 0;
  MCF_USB_ERR_ENB = 0;
  /* Clear all pending events. */
  MCF_USB_INT_STAT =0;
  MCF_USB_ERR_STAT =0;
  /* Disable SOF generation. */
  MCF_USB_CTL &= ~MCF_USB_CTL_USB_EN_SOF_EN;

  /* Stop USB.*/
  MCF_USB_CTL = 0;

  MCF_USB_USB_CTRL = 0;
}

/*****************************************************************************
 * usb_host_start_transaction
 * IN: type   - type of transaction
 *     buffer - data area for the transfer
 *     length - size of the buffer
 * OUT:
 *      -1: error
 *       x: number of processed bytes otherwise.
 * Assumptions: n/a
 * Description:
 *   Start the specified transatcion on the USB.
 *****************************************************************************/
static hcc_u16 usb_host_start_transaction(hcc_u8 type, hcc_u8 *buffer, hcc_u16 length, hcc_u8 ep)
{
  hcc_u8 token;
  hcc_u32* bdt_ctl;
  hcc_u8 retry=3;

  if ((MCF_USB_CTL & MCF_USB_CTL_HOST_MODE_EN) == 0)
  {
    tr_error=tre_not_running;
    return((hcc_u16)-1u);
  }

  /* Check if a device is attached. */
  if (my_device.address == INVALID_ADDRESS)
  {
    tr_error=tre_no_device;
    MKDBG_TRACE(ev_no_device, 0);
    return((hcc_u16)-1u);
  }

  if (my_device.eps[ep].address == INVALID_ADDRESS)
  {
    tr_error=tre_no_ep;
    MKDBG_TRACE(ev_no_ep, ep);
    return((hcc_u16)-1u);
  }

  /* Set device address. */
  MCF_USB_ADDR = (hcc_u8)(my_device.low_speed ?
                        my_device.address | MCF_USB_ADDR_LS_EN :
                        my_device.address);
  /* We are not talking over a HUB. */
  MCF_USB_ENDPT0 = MCF_USB_ENDPT0_HOST_WO_HUB;

  /* If this is an interrupt endpoint wait till the endpoint is due. */
  if (my_device.eps[ep].type == EPTYPE_INT)
  {
    hcc_u16 elapsed;
    /* Disable hardware retry. */
    MCF_USB_ENDPT0 |= MCF_USB_ENDPT0_RETRY_DIS;
    /* Disable software retry. */
    retry=1;

    /* wait till frame is due */
    do {
      elapsed=(hcc_u16)(MCF_USB_FRM_NUM-my_device.eps[ep].last_due);
      elapsed &= ((1<<11)-1);
      if (MCF_USB_INT_STAT & MCF_USB_INT_STAT_USB_RST)
      {
        evt_disconnect();
        tr_error=tre_disconnected;
        return((hcc_u16)-1u);
      }
    } while(elapsed < my_device.eps[ep].interval);


    my_device.eps[ep].last_due += my_device.eps[ep].interval;
    my_device.eps[ep].last_due &= ((1<<11)-1);
  }

  do  {
    tr_error=tre_none;
    retry--;
    switch(type)
    {
      case TRT_SETUP:
        MKDBG_TRACE(ev_trt_setup, ep);
        /* Configure bi-directional communication. */
        /* Usb spec says setup packets shall be accepted
           even if the device was not able to process its packet
           buffer. Thus NAK handshake shaould not be given to a
           setup packet by the device. Anyway some devices will
           happily NAK setup packets :( */
        MCF_USB_ENDPT0 |= /*MCF_USB_ENDPT0_RETRY_DIS |*/ 0x0d;

        /* After the setup we shall send/receive DATA1 packets. */
        my_device.eps[ep].tgl_tx=1;
        my_device.eps[ep].tgl_rx=1;
        /* Set data buffer address. */
        WR_LE32(&BDT_ADR_TX(0, ep_info.next_tx), (hcc_u32)buffer);
        /* Set packet properties and give buffer to USB. */
        bdt_ctl=&BDT_CTL_TX(0, ep_info.next_tx);
        WR_LE32(bdt_ctl, (0x8<<16) | BDT_CTL_OWN | 0);
        /* Wait till pending tokens are processed. */
#if DSC_BUG == 0
        while(MCF_USB_CTL & MCF_USB_CTL_TXDSUSPEND_TOKBUSY)
        {
          if (MCF_USB_INT_STAT & MCF_USB_INT_STAT_USB_RST)
          {
            MCF_USB_CTL &= ~MCF_USB_CTL_TXDSUSPEND_TOKBUSY;
            evt_disconnect();
            tr_error=tre_disconnected;
            return((hcc_u16)-1u);
          }
        }
#endif

        /* Start transaction. */
        MCF_USB_TOKEN=(hcc_u8)((TOKEN_SETUP<<4) | (my_device.eps[ep].address | (0<<7)));
        break;
      case TRT_IN:
        MKDBG_TRACE(ev_trt_in, ep);
        /* Configure bi-directional communication + auto repeat. */
        MCF_USB_ENDPT0 |= 0x0d;
        /* Set RX buffer address. */
        WR_LE32(&BDT_ADR_RX(0, ep_info.next_rx), (hcc_u32)buffer);
        /* Set packet properies and give next buffer to USB. */
        bdt_ctl=&BDT_CTL_RX(0, ep_info.next_rx);
        WR_LE32(bdt_ctl, (length<<16) | BDT_CTL_OWN | my_device.eps[ep].tgl_rx);
        my_device.eps[ep].tgl_rx =(hcc_u8)(my_device.eps[ep].tgl_rx ? 0 : BDT_CTL_DATA);
        /* Wait till pending tokens are processed. */
#if DSC_BUG == 0
        while(MCF_USB_CTL & MCF_USB_CTL_TXDSUSPEND_TOKBUSY)
        {
          if (MCF_USB_INT_STAT & MCF_USB_INT_STAT_USB_RST)
          {
            MCF_USB_CTL &= ~MCF_USB_CTL_TXDSUSPEND_TOKBUSY;
            evt_disconnect();
            tr_error=tre_disconnected;
            return((hcc_u16)-1u);
          }
        }
#endif
        /* Start transaction. */
        MCF_USB_TOKEN=(hcc_u8)((TOKEN_IN<<4) | (my_device.eps[ep].address | (1<<7)));
        break;
      case TRT_OUT:
        MKDBG_TRACE(ev_trt_out, ep);
        /* Configure bi-directional communication + auto repeat. */
        MCF_USB_ENDPT0 |= 0x0d;
        /* Set TX buffer address. */
        WR_LE32(&BDT_ADR_TX(0, ep_info.next_tx), (hcc_u32)buffer);
        /* Set packet properties ang give buffer to USB. */
        bdt_ctl=&BDT_CTL_TX(0, ep_info.next_tx);
        WR_LE32(bdt_ctl, (length<<16) | BDT_CTL_OWN | my_device.eps[ep].tgl_tx);
        my_device.eps[ep].tgl_tx = (hcc_u8)(my_device.eps[ep].tgl_tx ? 0 : BDT_CTL_DATA);
        /* Wait till pending tokens are processed. */
#if DSC_BUG == 0
        while(MCF_USB_CTL & MCF_USB_CTL_TXDSUSPEND_TOKBUSY)
        {
          if (MCF_USB_INT_STAT & MCF_USB_INT_STAT_USB_RST)
          {
            MCF_USB_CTL &= ~MCF_USB_CTL_TXDSUSPEND_TOKBUSY;
            evt_disconnect();
            tr_error=tre_disconnected;
            return((hcc_u16)-1u);
          }
        }
#endif
        /* Start transaction. */
        MCF_USB_TOKEN=(hcc_u8)((TOKEN_OUT<<4) | (my_device.eps[ep].address | (0<<7)));
        break;
      default:
        CMX_ASSERT(0);
    }

    /* Wait for transaction end or an error occurs */
    while((MCF_USB_INT_STAT & (MCF_USB_INT_STAT_TOK_DNE | MCF_USB_INT_STAT_STALL | MCF_USB_INT_STAT_ERROR)) ==0)
    {
      if (MCF_USB_INT_STAT & MCF_USB_INT_STAT_USB_RST)
      {
        evt_disconnect();
        tr_error=tre_disconnected;
        return((hcc_u16)-1u);
      }
    }
    if(MCF_USB_INT_STAT & MCF_USB_INT_STAT_USB_RST) {
    /* the device is disconnected, do not try
     */
       if (MCF_USB_INT_STAT & MCF_USB_INT_STAT_USB_RST)
      {
        evt_disconnect();
        tr_error=tre_disconnected;
        return((hcc_u16)-1u);
      }

    }
    if ((MCF_USB_ERR_STAT & ~MCF_USB_ERR_STAT_CRC5_EOF) != 0)
    {
      MCF_USB_ERR_STAT = 0xff;
      MCF_USB_INT_STAT = MCF_USB_INT_STAT_ERROR;
      tr_error=tre_data_error;
      continue;
    }

    /* device not disconnected while waiting for an aswer */
    /* clear transfer ok event */
    MCF_USB_INT_STAT=MCF_USB_INT_STAT_TOK_DNE;
    MCF_USB_CTL &= ~MCF_USB_CTL_TXDSUSPEND_TOKBUSY;

    /* switch to next buffer */
    if (type== TRT_SETUP || type == TRT_OUT)
    {
      ep_info.next_tx ^= 0x1u;
    }
    else
    {
      ep_info.next_rx ^= 0x1u;
    }

    if (MCF_USB_INT_STAT & MCF_USB_INT_STAT_STALL)
    {        /* device has an error */
      MCF_USB_INT_STAT=MCF_USB_INT_STAT_STALL;
      MKDBG_TRACE(ev_got_stall, ep);
      tr_error=tre_stall;
      return((hcc_u16)-1u);
    }

    /* Check transaction status.*/
    token=(hcc_u8)((RD_LE32(bdt_ctl) >> 2) & 0x0f);

    /* transaction accepted by device */
    switch (token)
    {
    default:
    case TOKEN_ACK:
      MKDBG_TRACE(ev_got_ack, ep);
      return((hcc_u16)((RD_LE32(bdt_ctl) >> 16u) & 0x3ffu));
    case TOKEN_NAK:
      /* device is not ready */
      MKDBG_TRACE(ev_got_nak, ep);
      if (my_device.eps[ep].type == EPTYPE_INT)
      {
        return(0);
      }
      /* retry */
      break;
    case TOKEN_STALL: /* endpoint stalled by device */
      /* we can not get here beacuse we already checked
         INT_STAT_STALL. */
      tr_error=tre_stall;
      return((hcc_u16)-1u);
    case 0xf:  /* data error, retry */
      MKDBG_TRACE(ev_got_data_error, ep);
      tr_error=tre_data_error;
      break;
    case 0:  /* no answer, retry. */
      MKDBG_TRACE(ev_got_unknown, ep);
      tr_error=tre_silent;
      break;
    }
  }while(retry);
  return((hcc_u16)-1u);
}

/*****************************************************************************
 * host_send_control
 * IN: buffer - data area for the transfer
 *     length - size of the buffer
 * OUT: != -1: Number of transmitted data bytes
 *      -1   : error
 * Assumptions: n/a
 * Description:
 *   Make an OUT transfer on a control endpoint.
 *****************************************************************************/
hcc_u16 host_send_control(hcc_u8 *setup_data, hcc_u8* buffer, hcc_u8 ep)
{
  hcc_u32 curr=0;
  hcc_u16 length=RD_LE16(setup_data+6);

  MKDBG_TRACE(ev_send_control, ep);

  if ((MCF_USB_CTL & MCF_USB_CTL_HOST_MODE_EN) == 0)
  {
    tr_error=tre_not_running;
    return((hcc_u16)-1u);
  }

  /* setup transaction. */
  if (((hcc_u16)-1u)==usb_host_start_transaction(TRT_SETUP, setup_data, 8, ep))
  {
    return((hcc_u16)-1u);
  }

  /* data transactions */
  while(curr<length)
  {
    hcc_u16 psize=(hcc_u16)(MIN(my_device.eps[ep].psize, length));
    hcc_u8 r=(hcc_u8)usb_host_start_transaction(TRT_OUT, buffer+curr, psize, ep);
    if (r != psize)
    {
      CMX_ASSERT(r==((hcc_u8)-1u));
      return((hcc_u16)-1u);
    }
    curr += psize;
  }
  /* handshake transaction */
  my_device.eps[ep].tgl_rx = BDT_CTL_DATA;
  if (((hcc_u16)-1u)==usb_host_start_transaction(TRT_IN, (void *)0, 0, ep))
  {
    return((hcc_u16)-1u);
  }

  return((hcc_u16)curr);
}

/*****************************************************************************
 * host_send
 * IN: buffer - data area for the transfer
 *     length - size of the buffer
 * OUT: != -1: Number of transmitted data bytes
 *      -1   : error
 * Assumptions: n/a
 * Description:
 *   Make an OUT transfer on a non control endpoint.
 *****************************************************************************/
hcc_u32 host_send(hcc_u8* buffer, hcc_u32 length, hcc_u8 ep)
{
  hcc_u32 curr=0;

  MKDBG_TRACE(ev_send, ep);

  if ((MCF_USB_CTL & MCF_USB_CTL_HOST_MODE_EN) == 0)
  {
    tr_error=tre_not_running;
    return(0);
  }

  /* data transactions */
  while(curr<length)
  {
    hcc_u16 psize=(hcc_u16)(MIN(my_device.eps[ep].psize, length));
    /* do transaction */
    hcc_u16 r=usb_host_start_transaction(TRT_OUT, buffer+curr, psize, ep);
    if (r!=psize)
    {
      CMX_ASSERT(r==((hcc_u16)-1u));
      break;
    }
    curr += psize;
  }
  return(curr);
}

/*****************************************************************************
 * host_receive
 * IN: buffer - data area for the transfer
 *     length - size of the buffer
 * OUT: != -1: Number of transmitted data bytes
 *      -1   : error
 * Assumptions: n/a
 * Description:
 *   Make an IN transfer on a control endpoint.
 *****************************************************************************/
hcc_u32 host_receive(hcc_u8* buffer, hcc_u32 length, hcc_u8 ep)
{
  hcc_u32 curr=0;

  MKDBG_TRACE(ev_receive, ep);

  if ((MCF_USB_CTL & MCF_USB_CTL_HOST_MODE_EN) == 0)
  {
    tr_error=tre_not_running;
    return(0);
  }

  /* data transactions */
  while(curr<length)
  {
    hcc_u16 got,
            psize=(hcc_u16)(MIN(my_device.eps[ep].psize, length));
    got=usb_host_start_transaction(TRT_IN, buffer+curr, psize, ep);
    if (got == ((hcc_u16)-1u))
    {
      break;
    }
    curr += got;
    /* short packet means end of transfer */
    if (got != my_device.eps[ep].psize)
    {
      break;
    }
  }
  return(curr);
}


/*****************************************************************************
 * host_receive_control
 * IN: buffer - data area for the transfer
 *     length - size of the buffer
 * OUT: != -1: Number of transmitted data bytes
 *      -1   : error
 * Assumptions: n/a
 * Description:
 *   Make an IN transfer on a control endpoint.
 *****************************************************************************/
hcc_u16 host_receive_control(hcc_u8 *setup_data, hcc_u8* buffer, hcc_u8 ep)
{
  hcc_u32 curr=0;
  hcc_u16 length = RD_LE16(setup_data+6);

  MKDBG_TRACE(ev_receive_control, ep);
  /* setup transaction. */

  if ((MCF_USB_CTL & MCF_USB_CTL_HOST_MODE_EN) == 0)
  {
    tr_error=tre_not_running;
    return((hcc_u16) -1u);
  }

  if (((hcc_u16)-1u)==usb_host_start_transaction(TRT_SETUP, setup_data, 8, ep))
  {
    return((hcc_u16)-1u);
  }

  /* data transactions */
  while(curr<length)
  {
    hcc_u16 got,
            psize=(hcc_u16)(MIN(my_device.eps[ep].psize, length));
    got=usb_host_start_transaction(TRT_IN, buffer+curr, psize, ep);
    curr += got;
    if (got == ((hcc_u16)-1u))
    {
      return((hcc_u16)-1u);
    }
    /* short packet means end of transfer */
    if (got != my_device.eps[ep].psize)
    {
      break;
    }
  }
  /* handshake transaction */
  my_device.eps[0].tgl_tx = BDT_CTL_DATA;
  if (((hcc_u16)-1u)==usb_host_start_transaction(TRT_OUT, (void *)0, 0, ep))
  {
    return((hcc_u16)-1u);
  }

  return((hcc_u16)curr);
}

/*****************************************************************************
 * host_drop_device
 * IN: n/a
 * OUT: n/a
 * Assumptions: n/a
 * Description:
 *   Remove device fro host.
 *****************************************************************************/
static void host_drop_device(void)
{

  if ((MCF_USB_CTL & MCF_USB_CTL_HOST_MODE_EN) == 0)
  {
    tr_error=tre_not_running;
    return;
  }

  /* if we don't have any device */
  if (my_device.address == INVALID_ADDRESS)
  {
    return;
  }
  host_sleep();
}


/*****************************************************************************
 * host_sleep
 * IN: n/a
 * OUT: n/a
 * Assumptions: n/a
 * Description:
 *   Put the BUS into low-power mode.
 *****************************************************************************/
void host_sleep(void)
{
  /* Sleep does not seems to work when SOF_TOK is off. Thus we treat
     resume=0 while suspended as sleep. */
  MCF_USB_INT_STAT = MCF_USB_INT_STAT_RESUME
                     | MCF_USB_INT_STAT_SOF_TOK;
  /* disable SOF generation */
  MCF_USB_CTL &= ~MCF_USB_CTL_USB_EN_SOF_EN;
  /* Wait 3 mS to let BUS enter suspended state. */
  host_ms_delay(3);
}

/*****************************************************************************
 * host_wakeup
 * IN: n/a
 * OUT: n/a
 * Assumptions: n/a
 * Description:
 *   Wake-up.
 *****************************************************************************/
void host_wakeup(void)
{
  if ((MCF_USB_CTL & MCF_USB_CTL_HOST_MODE_EN) == 0)
  {
    tr_error=tre_not_running;
    return;
  }

  /* if we don't have any device */
  if (my_device.address == INVALID_ADDRESS)
  {
    return;
  }

  /* Check if device has been disconnected. */
  if (!chk_dev())
  {
    return;
  }

  /* Start wakeup signaling. */
  MCF_USB_CTL |= MCF_USB_CTL_RESUME;
  host_ms_delay(20);
  MCF_USB_CTL &= ~MCF_USB_CTL_RESUME;

  /* enable SOF generation */
  MCF_USB_CTL |= MCF_USB_CTL_USB_EN_SOF_EN;
  MCF_USB_INT_STAT = MCF_USB_INT_STAT_SLEEP | MCF_USB_INT_STAT_RESUME;
  /* Wakeup recovery. */
  host_ms_delay(10);
}

/****************************** END OF FILE **********************************/
%-*****************************************************************************************************
%FILE %'DirRel_Code'usb_utils.h
%-*****************************************************************************************************
/***************************************************************************
 *
 *            Copyright (c) 2006-2007 by CMX Systems, Inc.
 *
 * This software is copyrighted by and is the sole property of
 * CMX.  All rights, title, ownership, or other interests
 * in the software remain the property of CMX.  This
 * software may only be used in accordance with the corresponding
 * license agreement.  Any unauthorized use, duplication, transmission,
 * distribution, or disclosure of this software is expressly forbidden.
 *
 * This Copyright notice may not be removed or modified without prior
 * written consent of CMX.
 *
 * CMX reserves the right to modify this software without notice.
 *
 * CMX Systems, Inc.
 * 12276 San Jose Blvd. #511
 * Jacksonville, FL 32223
 * USA
 *
 * Tel:  (904) 880-1840
 * Fax:  (904) 880-1632
 * http: www.cmx.com
 * email: cmx@cmx.com
 *
 ***************************************************************************/
#ifndef _USB_UTILS_H_
#define _USB_UTILS_H_

/* Standard descriptor types */
#define STDDTYPE_DEVICE        1u
#define STDDTYPE_CONFIGURATION 2u
#define STDDTYPE_STRING        3u
#define STDDTYPE_INTERFACE     4u
#define STDDTYPE_ENDPOINT      5u

/* Setup packet fields. */
#define STP_DIR_IN            (1u<<7)
#define STP_DIR_OUT           (0u<<7)
#define STP_TYPE_STD          (0u<<5)
#define STP_TYPE_CLASS        (1u<<5)
#define STP_TYPE_VENDOR       (2u<<5)
#define STP_RECIPIENT_DEVICE  (0<<0)
#define STP_RECIPIENT_IFC     (1<<0)
#define STP_RECIPIENT_ENDPT   (2<<0)
#define STP_RECIPIENT_OTHER   (3<<0)

/* Standard request values */
#define STDRQ_GET_STATUS         0u
#define STDRQ_CLEAR_FEATURE      1u
#define STDRQ_SET_FEATURE        3u
#define STDRQ_SET_ADDRESS        5u
#define STDRQ_GET_DESCRIPTOR     6u
#define STDRQ_SET_DESCRIPTOR     7u
#define STDRQ_GET_CONFIGURATION  8u
#define STDRQ_SET_CONFIGURATION  9u
#define STDRQ_GET_INTERFACE      10u
#define STDRQ_SET_INTERFACE      11u
#define STDRQ_SYNCH_FRAME        12u


#define DBUFFER_SIZE    255u

typedef enum {
  stderr_none=0,
  stderr_host,
  stderr_bad_desc
} std_error_t;

extern std_error_t std_error;

extern int get_dev_desc(void);
extern int get_cfg_desc(hcc_u8 ndx);
extern int set_address(hcc_u8 address);
extern int set_config(hcc_u8 cfg);
extern int get_device_info(device_info_t *res);
extern int get_ifc_info(ifc_info_t *res, hcc_u16 offset);
extern hcc_u16 find_ifc_ndx(hcc_u8 ndx);
extern hcc_u16 find_ifc_csp(hcc_u8 class, hcc_u8 sclass, hcc_u8 protocol);
extern hcc_u16 find_descriptor(hcc_u8 type, hcc_u16 start, hcc_u8 next);
extern int get_ep_info(ep_info_t *res, hcc_u16 offset);
extern void fill_setup_packet(hcc_u8* dst, hcc_u8 dir, hcc_u8 type, hcc_u8 recipient,
                       hcc_u8 req, hcc_u16 val, hcc_u16 ndx, hcc_u16 len);
extern int get_cfg_info(cfg_info_t *res);
extern int set_ep0_psize(void);
extern int enumerate_device(void);
#if 1 /* Processor Expert: make sure we have the data aligned on 4 byte boundaries */
extern hcc_u32 dbuffer32[(DBUFFER_SIZE+1)/4];
#define dbuffer   ((hcc_u8*)&dbuffer32[0])
#else
extern hcc_u8 dbuffer[DBUFFER_SIZE];
#endif
#endif
/****************************** END OF FILE **********************************/
%-*****************************************************************************************************
%FILE %'DirRel_Code'usb_utils.c
%-*****************************************************************************************************
/***************************************************************************
 *
 *            Copyright (c) 2006-2007 by CMX Systems, Inc.
 *
 * This software is copyrighted by and is the sole property of
 * CMX.  All rights, title, ownership, or other interests
 * in the software remain the property of CMX.  This
 * software may only be used in accordance with the corresponding
 * license agreement.  Any unauthorized use, duplication, transmission,
 * distribution, or disclosure of this software is expressly forbidden.
 *
 * This Copyright notice may not be removed or modified without prior
 * written consent of CMX.
 *
 * CMX reserves the right to modify this software without notice.
 *
 * CMX Systems, Inc.
 * 12276 San Jose Blvd. #511
 * Jacksonville, FL 32223
 * USA
 *
 * Tel:  (904) 880-1840
 * Fax:  (904) 880-1632
 * http: www.cmx.com
 * email: cmx@cmx.com
 *
 ***************************************************************************/
#include "hcc_types.h"
#include "usb_host.h"
#include "usb_utils.h"

/* Descriptors will be read to this buffer. */
#if 1 /* Processor Expert: align it to 4 byte boundaries */
hcc_u32 dbuffer32[(DBUFFER_SIZE+1)/4];
#else
hcc_u8 dbuffer[DBUFFER_SIZE];  // aligned to even address boundary
#endif

std_error_t std_error;
/*****************************************************************************
 * fill_setup_packet
 * IN:
 * OUT:
 * Assumptions: n/a
 * Description:
 *   Create data for a setup packet.
 *****************************************************************************/
void fill_setup_packet(hcc_u8* dst, hcc_u8 dir, hcc_u8 type, hcc_u8 recipient,
                       hcc_u8 req, hcc_u16 val, hcc_u16 ndx, hcc_u16 len)
{
  dst[0]=(hcc_u8)(dir | type | recipient);
  dst[1]=req;
  dst[2]=(hcc_u8)val;
  dst[3]=(hcc_u8)(val>>8);
  dst[4]=(hcc_u8)ndx;
  dst[5]=(hcc_u8)(ndx>>8);
  dst[6]=(hcc_u8)(len);
  dst[7]=(hcc_u8)(len>>8);
}

/*****************************************************************************
 * get_dev_desc
 * IN:
 * OUT:
 * Assumptions: n/a
 * Description:
 *   Read device desriptor to dbuffer.
 *****************************************************************************/
int get_dev_desc(void)
{
   hcc_u8 setup[8];
   hcc_u8 retry=3;

   std_error=stderr_none;
   fill_setup_packet(setup, STP_DIR_IN, STP_TYPE_STD, STP_RECIPIENT_DEVICE,
   STDRQ_GET_DESCRIPTOR, (STDDTYPE_DEVICE<<8)|0, 0, 18);

   do {
     if (18 == host_receive_control(setup, dbuffer, 0))
     {
       /* Check returned descriptor type and length (ignore extra bytes). */
       if ((USBDSC_TYPE(dbuffer) == STDDTYPE_DEVICE)
          && (USBDSC_LENGTH(dbuffer) <= 18))
       {
         return(0);
       }
     }
   } while(retry--);
   std_error=stderr_host;
   return(1);
}

/*****************************************************************************
 * get_cfg_desc
 * IN:
 * OUT:
 * Assumptions: n/a
 * Description:
 *   Read device desriptor to dbuffer.
 *****************************************************************************/
int get_cfg_desc(hcc_u8 ndx)
{
   hcc_u8 setup[8];
   hcc_u16 length=5;
   hcc_u8 retry=3;

   std_error=stderr_none;
   do {
     fill_setup_packet(setup, STP_DIR_IN, STP_TYPE_STD, STP_RECIPIENT_DEVICE,
     STDRQ_GET_DESCRIPTOR, (hcc_u16)((STDDTYPE_CONFIGURATION<<8)|ndx), 0, length);
     if (length == host_receive_control(setup, dbuffer, 0))
     {
       /* Check returned descriptor type and length (ignore extra bytes) */
       if ((USBDSC_TYPE(dbuffer) == STDDTYPE_CONFIGURATION)
          && (USBDSC_LENGTH(dbuffer) <= 9))
       {
         length=RD_LE16(dbuffer+2);
         CMX_ASSERT(length < DBUFFER_SIZE);

         fill_setup_packet(setup, STP_DIR_IN, STP_TYPE_STD, STP_RECIPIENT_DEVICE,
         STDRQ_GET_DESCRIPTOR, (hcc_u16)((STDDTYPE_CONFIGURATION<<8)|ndx), 0, length);

         if (length == host_receive_control(setup, dbuffer, 0))
         {
           return(0);
         }
       }
     }
   }while(retry--);
   std_error=stderr_host;
   return(1);
}

/*****************************************************************************
 * set_ep0_psize
 * IN:
 * OUT:
 * Assumptions: n/a
 * Description:
 *   Read device desriptor to dbuffer.
 *****************************************************************************/
int set_ep0_psize(void)
{
  hcc_u8 setup[8];

  std_error=stderr_none;
  fill_setup_packet(setup, STP_DIR_IN, STP_TYPE_STD, STP_RECIPIENT_DEVICE,
  STDRQ_GET_DESCRIPTOR, (STDDTYPE_DEVICE<<8) | 0, 0, 8);

  if (8 == host_receive_control(setup, dbuffer, 0))
  {
    if ((USBDSC_TYPE(dbuffer) == STDDTYPE_DEVICE)
       && (USBDSC_LENGTH(dbuffer) <= 18))
    {
      host_modify_ep(0, EPTYPE_CTRL, 0, 0, DEVDESC_PACKET_SIZE(dbuffer));
      return(0);
    }
  }
  std_error=stderr_host;
  return(1);
}

/*****************************************************************************
 * set_address
 * IN:
 * OUT:
 * Assumptions: n/a
 * Description:
 *   Set device address.
 *****************************************************************************/
int set_address(hcc_u8 address)
{
  hcc_u8 setup[8];
  hcc_u8 retry=3;

  std_error=stderr_none;
  fill_setup_packet(setup, STP_DIR_OUT, STP_TYPE_STD, STP_RECIPIENT_DEVICE,
  STDRQ_SET_ADDRESS, address, 0, 0);

  do {
    if (0==host_send_control(setup, dbuffer, 0))
    {
      /* we need to wait maximum 50 mS to let the device change its address. */
      host_ms_delay(45);
      return(0);
    }
  }while(retry--);
  std_error=stderr_host;
  return(1);
}
/*****************************************************************************
 * set_config
 * IN:
 * OUT:
 * Assumptions: n/a
 * Description:
 *   Set device configuration
 *****************************************************************************/
int set_config(hcc_u8 cfg)
{
  hcc_u8 setup[8];
  hcc_u8 retry=3;

  std_error=stderr_none;
  fill_setup_packet(setup, STP_DIR_OUT, STP_TYPE_STD, STP_RECIPIENT_DEVICE,
  STDRQ_SET_CONFIGURATION, cfg, 0, 0);
  do {
    if (0==host_send_control(setup, dbuffer, 0))
    {
      return(0);
    }
  } while(retry--);
  std_error=stderr_host;
  return(1);
}

/*****************************************************************************
 * get_device_info
 * IN:
 * OUT:
 * Assumptions: n/a
 * Description:
 *   Get device identifycation info.
 *****************************************************************************/
int get_device_info(device_info_t *res)
{
   /* read descriptor from device. */
   std_error=stderr_none;
   if (get_dev_desc())
   {
     std_error=stderr_host;
     return(1);
   }

   /* give read values to caller */
   res->clas=DEVDESC_CLASS(dbuffer);
   res->sclas=DEVDESC_SCLASS(dbuffer);
   res->protocol=DEVDESC_PROTOCOL(dbuffer);
   res->rev=DEVDESC_REV(dbuffer);
   res->vid=DEVDESC_VID(dbuffer);
   res->pid=DEVDESC_PID(dbuffer);
   res->ncfg=DEVDESC_NCFG(dbuffer);

   return(0);
}

/*****************************************************************************
 * find_descriptor
 * IN:
 * OUT:
 * Assumptions: n/a
 * Description:
 *   find a descriptor in the loaded configuration info
 *****************************************************************************/
hcc_u16 find_descriptor(hcc_u8 type, hcc_u16 start, hcc_u8 next)
{
  hcc_u8 *p=dbuffer+start;

  CMX_ASSERT(USBDSC_TYPE(dbuffer) == STDDTYPE_CONFIGURATION);

  if (next)
  {
    p+=USBDSC_LENGTH(p);
  }

  while(p < dbuffer+CONFDESC_TOTLENGTH(dbuffer))
  {
    if(USBDSC_TYPE(p) == type)
    {
      return((hcc_u16)(p-dbuffer));
    }
    p+=USBDSC_LENGTH(p);
  }
  return((hcc_u16)-1u);
}
/*****************************************************************************
 * find_ifc_csp
 * IN:
 * OUT:
 * Assumptions: n/a
 * Description:
 *   find an interface in the loaded config descriptor
 *****************************************************************************/
/* Currently only able to find the first matching ifc. Add start. */
hcc_u16 find_ifc_csp(hcc_u8 class, hcc_u8 sclass, hcc_u8 protocol)
{
  int ifc;
  hcc_u8 *p=dbuffer;

  /* at least class must be specifyed */
  CMX_ASSERT(class != 0);
  /* config descriptor shall be in dbuffer */
  CMX_ASSERT(USBDSC_TYPE(dbuffer) == STDDTYPE_CONFIGURATION);
  /* pharse configuration descriptor */
  for(ifc=0; ifc < CONFDESC_INTRFACES(dbuffer); ifc++)
  {
    while(USBDSC_TYPE(p) != STDDTYPE_INTERFACE)
    {
      p+=USBDSC_LENGTH(p);
    }

    /* if interface class is ok */
    if (IFCDESC_CLASS(p) == class)
    {
      /* check subclass and protocol if needed */
      if (((sclass == 0) || (IFCDESC_SCLASS(p) == sclass))
         && ((protocol == 0) || (IFCDESC_PROTOCOL(p) == protocol)))
      { /* return start address of interface */
        return((hcc_u8)((hcc_u32)p-(hcc_u32)dbuffer));
      }
    }
    p+=USBDSC_LENGTH(p);
  }
  return(0);
}

/*****************************************************************************
 * find_ifc_ndx
 * IN:
 * OUT:
 * Assumptions: n/a
 * Description:
 *   find an interface in the loaded config descriptor
 *****************************************************************************/
hcc_u16 find_ifc_ndx(hcc_u8 ndx)
{
  int ifc;
  hcc_u8 *p=dbuffer;

  /* config descriptor shall be in dbuffer */
  CMX_ASSERT(USBDSC_TYPE(dbuffer) == STDDTYPE_CONFIGURATION);

  /* pharse configuration descriptor */
  for(ifc=0; ifc < CONFDESC_INTRFACES(dbuffer); ifc++)
  {
    while(USBDSC_TYPE(p) != STDDTYPE_INTERFACE)
    {
      p+=USBDSC_LENGTH(p);
    }

    /* Nonboot hid mouse */
    if (IFCDESC_MY_NDX(p) == ndx)
    {
      return((hcc_u16)((hcc_u32)p-(hcc_u32)dbuffer));
    }
    p+=USBDSC_LENGTH(p);
  }
  return(0);
}

/*****************************************************************************
 * get_cfg_info
 * IN:
 * OUT:
 * Assumptions: n/a
 * Description:
 *   Get configuration info
 *****************************************************************************/
int get_cfg_info(cfg_info_t *res)
{
  res->nifc=CONFDESC_INTRFACES(dbuffer);
  res->ndx=CONFDESC_MY_NDX(dbuffer);
  res->str=CONFDESC_MY_STR(dbuffer);
  res->attrib=CONFDESC_ATTRIB(dbuffer);
  res->max_power=CONFDESC_MAX_POW(dbuffer);
  return(0);
}

/*****************************************************************************
 * get_ifc_info
 * IN:
 * OUT:
 * Assumptions: n/a
 * Description:
 *   Get interface info
 *****************************************************************************/
int get_ifc_info(ifc_info_t *res, hcc_u16 offset)
{
  res->clas=IFCDESC_CLASS(&dbuffer[offset]);
  res->sclas=IFCDESC_SCLASS(&dbuffer[offset]);
  res->protocol=IFCDESC_PROTOCOL(&dbuffer[offset]);
  res->ndx=IFCDESC_MY_NDX(&dbuffer[offset]);
  res->alt_set=IFCDESC_ALTERNATE(&dbuffer[offset]);
  res->str=IFCDESC_MY_STR(&dbuffer[offset]);
  res->nep=IFCDESC_ENDPONTS(&dbuffer[offset]);
  return(0);
}

/*****************************************************************************
 * get_ep_info
 * IN:
 * OUT:
 * Assumptions: n/a
 * Description:
 *   Get endpoint info
 *****************************************************************************/
int get_ep_info(ep_info_t *res, hcc_u16 offset)
{
  res->address=EPDESC_ADDRESS(&dbuffer[offset]);
  res->type=EPDESC_ATTRIB(&dbuffer[offset]);
  res->interval=EPDESC_INTERVAL(&dbuffer[offset]);
  res->psize=EPDESC_PSIZE(&dbuffer[offset]);
  return(0);
}
/****************************** END OF FILE **********************************/
%-*****************************************************************************************************
%FILE %'DirRel_Code'hcc_types.h
%-*****************************************************************************************************
/****************************************************************************
 *
 *            Copyright (c) 2006-2007 by CMX Systems, Inc.
 *
 * This software is copyrighted by and is the sole property of
 * CMX.  All rights, title, ownership, or other interests
 * in the software remain the property of CMX.  This
 * software may only be used in accordance with the corresponding
 * license agreement.  Any unauthorized use, duplication, transmission,
 * distribution, or disclosure of this software is expressly forbidden.
 *
 * This Copyright notice may not be removed or modified without prior
 * written consent of CMX.
 *
 * CMX reserves the right to modify this software without notice.
 *
 * CMX Systems, Inc.
 * 12276 San Jose Blvd. #511
 * Jacksonville, FL 32223
 * USA
 *
 * Tel:  (904) 880-1840
 * Fax:  (904) 880-1632
 * http: www.cmx.com
 * email: cmx@cmx.com
 *
 ***************************************************************************/
#ifndef _CMX_TYPES_H_
#define _CMX_TYPES_H_
#include "%ProcessorModule.h"

/* Type definitions */
typedef unsigned char hcc_u8;
typedef unsigned short hcc_u16;
typedef unsigned long int hcc_u32;

typedef volatile hcc_u8 hcc_reg8;
typedef volatile hcc_u16 hcc_reg16;
typedef volatile hcc_u32 hcc_reg32;

typedef hcc_u32 hcc_imask;

#ifdef NDEBUG
#define CMX_ASSERT(c) (void)0
#else
#define CMX_ASSERT(c)\
do {\
  if(!(c))\
  {\
    int a=1;\
    while(a)\
      ;\
  }\
}while(0)
#endif
#if 1 /* with Processor Expert, we are NOT using the assembly version, as it will not work for all calling conventions */
#include "%'ModuleName'.h"

#define mcf5xxx_byterev(val)  %'ModuleName'%.ByteRev32(val)
#else
extern hcc_u32 mcf5xxx_byterev(hcc_u32 val);
#endif

#define WR_LE32(a, v) ((*(hcc_u32*)(a))= mcf5xxx_byterev(v))
#define WR_LE16(a, v) ((*(hcc_u16*)(a))=(hcc_u16)(mcf5xxx_byterev(v) >> 16))
#define WR_LE16(a, v) ((*(hcc_u16*)(a))=(hcc_u16)(mcf5xxx_byterev(v) >> 16))
#define RD_LE32(a)    (mcf5xxx_byterev(*(hcc_u32*)(a)))
#define RD_LE16(a)    ((hcc_u16)(mcf5xxx_byterev((hcc_u32)*(hcc_u16*)(a))>>16))

/* Read 16 bit big endian value from address. */
#define RD_BE16(a) (*(hcc_u16*)(a))
/* Write 16bit value in v to address a in big endian order. */
#define WR_BE16(a, v) (*(hcc_u16*)(a) = (hcc_u16)(v))
/* Read 32 bit little endian value from address. */
#define RD_BE32(a) (*(hcc_u32*)(a))
/* Write 32bit value in v to address a in big endian order. */
#define WR_BE32(a, v) (*(hcc_u32*)(a) = (hcc_u32)(v))


#endif /*_CMX_TYPES_H_*/

/****************************** END OF FILE **********************************/
%if %CPUDerivative='MCF51JM128'
%-*****************************************************************************************************
%FILE %'DirRel_Code'mcf51xx_reg.h
%-*****************************************************************************************************
/***************************************************************************
 *
 *            Copyright (c) 2006-2007 by CMX Systems, Inc.
 *
 * This software is copyrighted by and is the sole property of
 * CMX.  All rights, title, ownership, or other interests
 * in the software remain the property of CMX.  This
 * software may only be used in accordance with the corresponding
 * license agreement.  Any unauthorized use, duplication, transmission,
 * distribution, or disclosure of this software is expressly forbidden.
 *
 * This Copyright notice may not be removed or modified without prior
 * written consent of CMX.
 *
 * CMX reserves the right to modify this software without notice.
 *
 * CMX Systems, Inc.
 * 12276 San Jose Blvd. #511
 * Jacksonville, FL 32223
 * USA
 *
 * Tel:  (904) 880-1840
 * Fax:  (904) 880-1632
 * http: www.cmx.com
 * email: cmx@cmx.com
 *
 ***************************************************************************/
 /*
  * Author: William Jiang
  * Change History:
  *       version 1, Oct.31, 2007 --- initial version
  */
#ifndef _MCF51XX_REGS_H_
#define _MCF51XX_REGS_H_

#include "hcc_types.h"
#include "%ProcessorModule.h"

#define LITTLE_ENDIAN_MODE

#define nop()       asm( nop)

/*
 * Memory map definitions from linker command files
 */
#if 0 /* adaption for Processor Expert */
extern volatile byte  const _IPSBAR[];
#else
  #define _IPSBAR ((char*)0xFFFF8000)
#endif

/*
 * Memory Map Info
 */

#define BITX(x) (1U<<(x))
#define BIT0        BITX(0)
#define BIT1        BITX(1)
#define BIT2        BITX(2)
#define BIT3        BITX(3)
#define BIT4        BITX(4)
#define BIT5        BITX(5)
#define BIT6        BITX(6)
#define BIT7         BITX(7)
#define BIT8        BITX(8)
#define BIT9        BITX(9)
#define BIT10   BITX(10)
#define BIT11        BITX(11)
#define BIT12   BITX(12)
#define BIT13        BITX(13)
#define BIT14   BITX(14)
#define BIT15        BITX(15)
#define BIT16   BITX(16)
#define BIT17        BITX(17)
#define BIT18   BITX(18)
#define BIT19        BITX(19)
#define BIT20   BITX(20)
#define BIT21        BITX(21)
#define BIT22   BITX(22)
#define BIT23        BITX(23)
#define BIT24   BITX(24)
#define BIT25        BITX(25)
#define BIT26   BITX(26)
#define BIT27        BITX(27)
#define BIT28   BITX(28)
#define BIT29        BITX(29)
#define BIT30   BITX(30)
#define BIT31        BITX(31)


/*********************************************************************
*
* Core register bit definitions
*
*********************************************************************/
/* Status Register */
#define MCF5XXX_SR_T        (0x8000)
#define MCF5XXX_SR_S        (0x2000)
#define MCF5XXX_SR_M        (0x1000)
#define MCF5XXX_SR_IPL      (0x0700)
#define MCF5XXX_SR_IPL_0    (0x0000)
#define MCF5XXX_SR_IPL_1    (0x0100)
#define MCF5XXX_SR_IPL_2    (0x0200)
#define MCF5XXX_SR_IPL_3    (0x0300)
#define MCF5XXX_SR_IPL_4    (0x0400)
#define MCF5XXX_SR_IPL_5    (0x0500)
#define MCF5XXX_SR_IPL_6    (0x0600)
#define MCF5XXX_SR_IPL_7    (0x0700)
#define MCF5XXX_SR_X        (0x0010)
#define MCF5XXX_SR_N        (0x0008)
#define MCF5XXX_SR_Z        (0x0004)
#define MCF5XXX_SR_V        (0x0002)
#define MCF5XXX_SR_C        (0x0001)


/*********************************************************************
*
* Universal Serial Bus (USB)
*
*********************************************************************/

/* Register read/write macros */
#define MCF_USB_PER_ID                       (*(hcc_reg8 *)(&_IPSBAR[0x1A00]))
#define MCF_USB_IP_COMP                      (*(hcc_reg8 *)(&_IPSBAR[0x1A04]))
#define MCF_USB_REV                          (*(hcc_reg8 *)(&_IPSBAR[0x1A08]))
#define MCF_USB_ADD_INFO                     (*(hcc_reg8 *)(&_IPSBAR[0x1A0C]))
#define MCF_USB_OTG_INT_STAT                 (*(hcc_reg8 *)(&_IPSBAR[0x1A10]))
#define MCF_USB_OTG_INT_EN                   (*(hcc_reg8 *)(&_IPSBAR[0x1A14]))
#define MCF_USB_OTG_STATUS                   (*(hcc_reg8 *)(&_IPSBAR[0x1A18]))
#define MCF_USB_OTG_CTRL                     (*(hcc_reg8 *)(&_IPSBAR[0x1A1C]))
#define MCF_USB_INT_STAT                     (*(hcc_reg8 *)(&_IPSBAR[0x1A80]))
#define MCF_USB_INT_ENB                      (*(hcc_reg8 *)(&_IPSBAR[0x1A84]))
#define MCF_USB_ERR_STAT                     (*(hcc_reg8 *)(&_IPSBAR[0x1A88]))
#define MCF_USB_ERR_ENB                      (*(hcc_reg8 *)(&_IPSBAR[0x1A8C]))
#define MCF_USB_STAT                         (*(hcc_reg8 *)(&_IPSBAR[0x1A90]))
#define MCF_USB_CTL                          (*(hcc_reg8 *)(&_IPSBAR[0x1A94]))
#define MCF_USB_ADDR                         (*(hcc_reg8 *)(&_IPSBAR[0x1A98]))
#define MCF_USB_BDT_PAGE_01                  (*(hcc_reg8 *)(&_IPSBAR[0x1A9C]))
#define MCF_USB_FRM_NUML                     (*(hcc_reg8 *)(&_IPSBAR[0x1AA0]))
#define MCF_USB_FRM_NUMH                     (*(hcc_reg8 *)(&_IPSBAR[0x1AA4]))
#define MCF_USB_FRM_NUM       (MCF_USB_INT_STAT=MCF_USB_INT_STAT_SOF_TOK ,MCF_USB_FRM_NUML | (((hcc_u16)MCF_USB_FRM_NUMH)<<8))
#define MCF_USB_TOKEN                        (*(hcc_reg8 *)(&_IPSBAR[0x1AA8]))
#define MCF_USB_SOF_THLDL                    (*(hcc_reg8 *)(&_IPSBAR[0x1AAC]))
#define MCF_USB_BDT_PAGE_02                  (*(hcc_reg8 *)(&_IPSBAR[0x1AB0]))
#define MCF_USB_BDT_PAGE_03                  (*(hcc_reg8 *)(&_IPSBAR[0x1AB4]))
#define MCF_USB_ENDPT0                       (*(hcc_reg8 *)(&_IPSBAR[0x1AC0]))
#define MCF_USB_ENDPT1                       (*(hcc_reg8 *)(&_IPSBAR[0x1AC4]))
#define MCF_USB_ENDPT2                       (*(hcc_reg8 *)(&_IPSBAR[0x1AC8]))
#define MCF_USB_ENDPT3                       (*(hcc_reg8 *)(&_IPSBAR[0x1ACC]))
#define MCF_USB_ENDPT4                       (*(hcc_reg8 *)(&_IPSBAR[0x1AD0]))
#define MCF_USB_ENDPT5                       (*(hcc_reg8 *)(&_IPSBAR[0x1AD4]))
#define MCF_USB_ENDPT6                       (*(hcc_reg8 *)(&_IPSBAR[0x1AD8]))
#define MCF_USB_ENDPT7                       (*(hcc_reg8 *)(&_IPSBAR[0x1ADC]))
#define MCF_USB_ENDPT8                       (*(hcc_reg8 *)(&_IPSBAR[0x1AE0]))
#define MCF_USB_ENDPT9                       (*(hcc_reg8 *)(&_IPSBAR[0x1AE4]))
#define MCF_USB_ENDPT10                      (*(hcc_reg8 *)(&_IPSBAR[0x1AE8]))
#define MCF_USB_ENDPT11                      (*(hcc_reg8 *)(&_IPSBAR[0x1AEC]))
#define MCF_USB_ENDPT12                      (*(hcc_reg8 *)(&_IPSBAR[0x1AF0]))
#define MCF_USB_ENDPT13                      (*(hcc_reg8 *)(&_IPSBAR[0x1AF4]))
#define MCF_USB_ENDPT14                      (*(hcc_reg8 *)(&_IPSBAR[0x1AF8]))
#define MCF_USB_ENDPT15                      (*(hcc_reg8 *)(&_IPSBAR[0x1AFC]))
#define MCF_USB_USB_CTRL                     (*(hcc_reg8 *)(&_IPSBAR[0x1B00]))
#define MCF_USB_USB_OTG_OBSERVE              (*(hcc_reg8 *)(&_IPSBAR[0x1B04]))
#define MCF_USB_USB_OTG_CONTROL              (*(hcc_reg8 *)(&_IPSBAR[0x1B08]))

/* two new added registers for V1 */
#define MCF_USB_USBTRC0                                         (*(hcc_reg8 *)(&_IPSBAR[0x1B0C]))
#define MCF_USB_OTGPIN                                         (*(hcc_reg8 *)(&_IPSBAR[0x1B10]))

/* Bit definitions and macros for MCF_USB_USBTRC0 */
#define MCF_USB_USBTRC0_USB_RESUME_INT                (0x01)
#define MCF_USB_USBTRC0_USBVREN                        (0x04)
#define MCF_USB_USBTRC0_USBRESMEN                (0x20)
#define MCF_USB_USBTRC0_USBPU                        (0x40)
#define MCF_USB_USBTRC0_USBRESET                (0x80)

/* Bit definitions and macros for MCF_USB_OTGPIN */
#define MCF_USB_OTGPIN_SESSVLD                        (0x01)
#define MCF_USB_OTGPIN_SESSEND                        (0x02)
#define MCF_USB_OTGPIN_VBUSVLD                        (0x04)
#define MCF_USB_OTGPIN_PULLUP                        (0x08)
#define MCF_USB_OTGPIN_DPDOWN                        (0x10)
#define MCF_USB_OTGPIN_DMDOWN                        (0x20)
#define MCF_USB_OTGPIN_USBID                        (0x40)


/* Bit definitions and macros for MCF_USB_PER_ID */
#define MCF_USB_PER_ID_ID(x)                 (((x)&0x3F)<<0)

/* Bit definitions and macros for MCF_USB_IP_COMP */
#define MCF_USB_IP_COMP_NID(x)               (((x)&0x3F)<<0)

/* Bit definitions and macros for MCF_USB_REV */
#define MCF_USB_REV_REV(x)                   (((x)&0xFF)<<0)

/* Bit definitions and macros for MCF_USB_ADD_INFO */
#define MCF_USB_ADD_INFO_HOST                (0x01)
#define MCF_USB_ADD_INFO_IRQ_NUM(x)          (((x)&0x1F)<<3)

/* Bit definitions and macros for MCF_USB_OTG_INT_STAT */
#define MCF_USB_OTG_INT_STAT_A_VBUS_VLD_CHG  (0x01)
#define MCF_USB_OTG_INT_STAT_B_SESS_END_CHG  (0x04)
#define MCF_USB_OTG_INT_STAT_SESS_VLD_CHG    (0x08)
#define MCF_USB_OTG_INT_STAT_LINE_STATE      (0x20)
#define MCF_USB_OTG_INT_STAT_1_MSEC          (0x40)
#define MCF_USB_OTG_INT_STAT_ID_CHG          (0x80)

/* Bit definitions and macros for MCF_USB_OTG_INT_EN */
#define MCF_USB_OTG_INT_EN_A_VBUS_VLD_EN     (0x01)
#define MCF_USB_OTG_INT_EN_B_SESS_END_EN     (0x04)
#define MCF_USB_OTG_INT_EN_SESS_VLD_EN       (0x08)
#define MCF_USB_OTG_INT_EN_LINE_STATE        (0x20)
#define MCF_USB_OTG_INT_EN_1_MSEC_EN         (0x40)
#define MCF_USB_OTG_INT_EN_ID_EN             (0x80)

/* Bit definitions and macros for MCF_USB_OTG_STATUS */
#define MCF_USB_OTG_STATUS_A_VBUS_VLD        (0x01)
#define MCF_USB_OTG_STATUS_B_SESS_END        (0x04)
#define MCF_USB_OTG_STATUS_SESS_VLD          (0x08)
#define MCF_USB_OTG_STATUS_LINE_STATE        (0x20)
#define MCF_USB_OTG_STATUS_1_MSEC            (0x40)
#define MCF_USB_OTG_STATUS_ID                (0x80)

/* Bit definitions and macros for MCF_USB_OTG_CTRL */
#define MCF_USB_OTG_CTRL_VBUS_DSCHG          (0x01)
#define MCF_USB_OTG_CTRL_VBUS_CHG            (0x02)
#define MCF_USB_OTG_CTRL_OTG_EN              (0x04)
#define MCF_USB_OTG_CTRL_VBUS_ON             (0x08)
#define MCF_USB_OTG_CTRL_DM_LOW              (0x10)
#define MCF_USB_OTG_CTRL_DP_LOW              (0x20)
#define MCF_USB_OTG_CTRL_DM_HIGH             (0x40)
#define MCF_USB_OTG_CTRL_DP_HIGH             (0x80)

/* Bit definitions and macros for MCF_USB_INT_STAT */
#define MCF_USB_INT_STAT_USB_RST             (0x01)
#define MCF_USB_INT_STAT_ERROR               (0x02)
#define MCF_USB_INT_STAT_SOF_TOK             (0x04)
#define MCF_USB_INT_STAT_TOK_DNE             (0x08)
#define MCF_USB_INT_STAT_SLEEP               (0x10)
#define MCF_USB_INT_STAT_RESUME              (0x20)
#define MCF_USB_INT_STAT_ATTACH              (0x40)
#define MCF_USB_INT_STAT_STALL               (0x80)

/* Bit definitions and macros for MCF_USB_INT_ENB */
#define MCF_USB_INT_ENB_USB_RST              (0x01)
#define MCF_USB_INT_ENB_ERROR                (0x02)
#define MCF_USB_INT_ENB_SOF_TOK              (0x04)
#define MCF_USB_INT_ENB_TOK_DNE              (0x08)
#define MCF_USB_INT_ENB_SLEEP                (0x10)
#define MCF_USB_INT_ENB_RESUME               (0x20)
#define MCF_USB_INT_ENB_ATTACH               (0x40)
#define MCF_USB_INT_ENB_STALL                (0x80)

/* Bit definitions and macros for MCF_USB_ERR_STAT */
#define MCF_USB_ERR_STAT_PID_ERR             (0x01)
#define MCF_USB_ERR_STAT_CRC5_EOF            (0x02)
#define MCF_USB_ERR_STAT_CRC16               (0x04)
#define MCF_USB_ERR_STAT_DFN8                (0x08)
#define MCF_USB_ERR_STAT_BTO_ERR             (0x10)
#define MCF_USB_ERR_STAT_DMA_ERR             (0x20)
#define MCF_USB_ERR_STAT_BTS_ERR             (0x80)

/* Bit definitions and macros for MCF_USB_ERR_ENB */
#define MCF_USB_ERR_ENB_PID_ERR              (0x01)
#define MCF_USB_ERR_ENB_CRC5_EOF             (0x02)
#define MCF_USB_ERR_ENB_CRC16                (0x04)
#define MCF_USB_ERR_ENB_DFN8                 (0x08)
#define MCF_USB_ERR_ENB_BTO_ERR              (0x10)
#define MCF_USB_ERR_ENB_DMA_ERR              (0x20)
#define MCF_USB_ERR_ENB_BTS_ERR              (0x80)

/* Bit definitions and macros for MCF_USB_STAT */
#define MCF_USB_STAT_ODD                     (0x04)
#define MCF_USB_STAT_TX                      (0x08)
#define MCF_USB_STAT_ENDP(x)                 (((x)&0x0F)<<4)

/* Bit definitions and macros for MCF_USB_CTL */
#define MCF_USB_CTL_USB_EN_SOF_EN            (0x01)
#define MCF_USB_CTL_ODD_RST                  (0x02)
#define MCF_USB_CTL_RESUME                   (0x04)
#define MCF_USB_CTL_HOST_MODE_EN             (0x08)
#define MCF_USB_CTL_RESET                    (0x10)
#define MCF_USB_CTL_TXDSUSPEND_TOKBUSY       (0x20)
#define MCF_USB_CTL_SE0                      (0x40)
#define MCF_USB_CTL_JSTATE                   (0x80)

/* Bit definitions and macros for MCF_USB_ADDR */
#define MCF_USB_ADDR_ADDR(x)                 (((x)&0x7F)<<0)
#define MCF_USB_ADDR_LS_EN                   (0x80)

/* Bit definitions and macros for MCF_USB_BDT_PAGE_01 */
#define MCF_USB_BDT_PAGE_01_BDT_BA9          (0x02)
#define MCF_USB_BDT_PAGE_01_BDT_BA10         (0x04)
#define MCF_USB_BDT_PAGE_01_BDT_BA11         (0x08)
#define MCF_USB_BDT_PAGE_01_BDT_BA12         (0x10)
#define MCF_USB_BDT_PAGE_01_BDT_BA13         (0x20)
#define MCF_USB_BDT_PAGE_01_BDT_BA14         (0x40)
#define MCF_USB_BDT_PAGE_01_BDT_BA15         (0x80)

/* Bit definitions and macros for MCF_USB_FRM_NUM */
#define MCF_USB_FRM_NUM_FRM(x)               (((x)&0xFFFF)<<0)

/* Bit definitions and macros for MCF_USB_FRM_NUML */
#define MCF_USB_FRM_NUML_FRM0                (0x01)
#define MCF_USB_FRM_NUML_FRM1                (0x02)
#define MCF_USB_FRM_NUML_FRM2                (0x04)
#define MCF_USB_FRM_NUML_FRM3                (0x08)
#define MCF_USB_FRM_NUML_FRM4                (0x10)
#define MCF_USB_FRM_NUML_FRM5                (0x20)
#define MCF_USB_FRM_NUML_FRM6                (0x40)
#define MCF_USB_FRM_NUML_FRM7                (0x80)

/* Bit definitions and macros for MCF_USB_FRM_NUMH */
#define MCF_USB_FRM_NUMH_FRM8                (0x01)
#define MCF_USB_FRM_NUMH_FRM9                (0x02)
#define MCF_USB_FRM_NUMH_FRM10               (0x04)
#define MCF_USB_FRM_NUMH_FRM11               (0x08)
#define MCF_USB_FRM_NUMH_FRM12               (0x10)
#define MCF_USB_FRM_NUMH_FRM13               (0x20)
#define MCF_USB_FRM_NUMH_FRM14               (0x40)
#define MCF_USB_FRM_NUMH_FRM15               (0x80)

/* Bit definitions and macros for MCF_USB_TOKEN */
#define MCF_USB_TOKEN_TOKEN_ENDPT(x)         (((x)&0x0F)<<0)
#define MCF_USB_TOKEN_TOKEN_PID(x)           (((x)&0x0F)<<4)

/* Bit definitions and macros for MCF_USB_SOF_THLDL */
#define MCF_USB_SOF_THLDL_CNT(x)             (((x)&0xFF)<<0)

/* Bit definitions and macros for MCF_USB_BDT_PAGE_02 */
#define MCF_USB_BDT_PAGE_02_BDT_BA16         (0x01)
#define MCF_USB_BDT_PAGE_02_BDT_BA17         (0x02)
#define MCF_USB_BDT_PAGE_02_BDT_BA18         (0x04)
#define MCF_USB_BDT_PAGE_02_BDT_BA19         (0x08)
#define MCF_USB_BDT_PAGE_02_BDT_BA20         (0x10)
#define MCF_USB_BDT_PAGE_02_BDT_BA21         (0x20)
#define MCF_USB_BDT_PAGE_02_BDT_BA22         (0x40)
#define MCF_USB_BDT_PAGE_02_BDT_BA23         (0x80)

/* Bit definitions and macros for MCF_USB_BDT_PAGE_03 */
#define MCF_USB_BDT_PAGE_03_BDT_BA24         (0x01)
#define MCF_USB_BDT_PAGE_03_BDT_BA25         (0x02)
#define MCF_USB_BDT_PAGE_03_BDT_BA26         (0x04)
#define MCF_USB_BDT_PAGE_03_BDT_BA27         (0x08)
#define MCF_USB_BDT_PAGE_03_BDT_BA28         (0x10)
#define MCF_USB_BDT_PAGE_03_BDT_BA29         (0x20)
#define MCF_USB_BDT_PAGE_03_BDT_BA30         (0x40)
#define MCF_USB_BDT_PAGE_03_BDT_BA31         (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT0 */
#define MCF_USB_ENDPT0_EP_HSHK               (0x01)
#define MCF_USB_ENDPT0_EP_STALL              (0x02)
#define MCF_USB_ENDPT0_EP_EN_TX              (0x04)
#define MCF_USB_ENDPT0_EP_EN_RX              (0x08)
#define MCF_USB_ENDPT0_EP_CTL_DIS            (0x10)
#define MCF_USB_ENDPT0_RETRY_DIS             (0x40)
#define MCF_USB_ENDPT0_HOST_WO_HUB           (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT1 */
#define MCF_USB_ENDPT1_EP_HSHK               (0x01)
#define MCF_USB_ENDPT1_EP_STALL              (0x02)
#define MCF_USB_ENDPT1_EP_EN_TX              (0x04)
#define MCF_USB_ENDPT1_EP_EN_RX              (0x08)
#define MCF_USB_ENDPT1_EP_CTL_DIS            (0x10)
#define MCF_USB_ENDPT1_RETRY_DIS             (0x40)
#define MCF_USB_ENDPT1_HOST_WO_HUB           (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT2 */
#define MCF_USB_ENDPT2_EP_HSHK               (0x01)
#define MCF_USB_ENDPT2_EP_STALL              (0x02)
#define MCF_USB_ENDPT2_EP_EN_TX              (0x04)
#define MCF_USB_ENDPT2_EP_EN_RX              (0x08)
#define MCF_USB_ENDPT2_EP_CTL_DIS            (0x10)
#define MCF_USB_ENDPT2_RETRY_DIS             (0x40)
#define MCF_USB_ENDPT2_HOST_WO_HUB           (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT3 */
#define MCF_USB_ENDPT3_EP_HSHK               (0x01)
#define MCF_USB_ENDPT3_EP_STALL              (0x02)
#define MCF_USB_ENDPT3_EP_EN_TX              (0x04)
#define MCF_USB_ENDPT3_EP_EN_RX              (0x08)
#define MCF_USB_ENDPT3_EP_CTL_DIS            (0x10)
#define MCF_USB_ENDPT3_RETRY_DIS             (0x40)
#define MCF_USB_ENDPT3_HOST_WO_HUB           (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT4 */
#define MCF_USB_ENDPT4_EP_HSHK               (0x01)
#define MCF_USB_ENDPT4_EP_STALL              (0x02)
#define MCF_USB_ENDPT4_EP_EN_TX              (0x04)
#define MCF_USB_ENDPT4_EP_EN_RX              (0x08)
#define MCF_USB_ENDPT4_EP_CTL_DIS            (0x10)
#define MCF_USB_ENDPT4_RETRY_DIS             (0x40)
#define MCF_USB_ENDPT4_HOST_WO_HUB           (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT5 */
#define MCF_USB_ENDPT5_EP_HSHK               (0x01)
#define MCF_USB_ENDPT5_EP_STALL              (0x02)
#define MCF_USB_ENDPT5_EP_EN_TX              (0x04)
#define MCF_USB_ENDPT5_EP_EN_RX              (0x08)
#define MCF_USB_ENDPT5_EP_CTL_DIS            (0x10)
#define MCF_USB_ENDPT5_RETRY_DIS             (0x40)
#define MCF_USB_ENDPT5_HOST_WO_HUB           (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT6 */
#define MCF_USB_ENDPT6_EP_HSHK               (0x01)
#define MCF_USB_ENDPT6_EP_STALL              (0x02)
#define MCF_USB_ENDPT6_EP_EN_TX              (0x04)
#define MCF_USB_ENDPT6_EP_EN_RX              (0x08)
#define MCF_USB_ENDPT6_EP_CTL_DIS            (0x10)
#define MCF_USB_ENDPT6_RETRY_DIS             (0x40)
#define MCF_USB_ENDPT6_HOST_WO_HUB           (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT7 */
#define MCF_USB_ENDPT7_EP_HSHK               (0x01)
#define MCF_USB_ENDPT7_EP_STALL              (0x02)
#define MCF_USB_ENDPT7_EP_EN_TX              (0x04)
#define MCF_USB_ENDPT7_EP_EN_RX              (0x08)
#define MCF_USB_ENDPT7_EP_CTL_DIS            (0x10)
#define MCF_USB_ENDPT7_RETRY_DIS             (0x40)
#define MCF_USB_ENDPT7_HOST_WO_HUB           (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT8 */
#define MCF_USB_ENDPT8_EP_HSHK               (0x01)
#define MCF_USB_ENDPT8_EP_STALL              (0x02)
#define MCF_USB_ENDPT8_EP_EN_TX              (0x04)
#define MCF_USB_ENDPT8_EP_EN_RX              (0x08)
#define MCF_USB_ENDPT8_EP_CTL_DIS            (0x10)
#define MCF_USB_ENDPT8_RETRY_DIS             (0x40)
#define MCF_USB_ENDPT8_HOST_WO_HUB           (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT9 */
#define MCF_USB_ENDPT9_EP_HSHK               (0x01)
#define MCF_USB_ENDPT9_EP_STALL              (0x02)
#define MCF_USB_ENDPT9_EP_EN_TX              (0x04)
#define MCF_USB_ENDPT9_EP_EN_RX              (0x08)
#define MCF_USB_ENDPT9_EP_CTL_DIS            (0x10)
#define MCF_USB_ENDPT9_RETRY_DIS             (0x40)
#define MCF_USB_ENDPT9_HOST_WO_HUB           (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT10 */
#define MCF_USB_ENDPT10_EP_HSHK              (0x01)
#define MCF_USB_ENDPT10_EP_STALL             (0x02)
#define MCF_USB_ENDPT10_EP_EN_TX             (0x04)
#define MCF_USB_ENDPT10_EP_EN_RX             (0x08)
#define MCF_USB_ENDPT10_EP_CTL_DIS           (0x10)
#define MCF_USB_ENDPT10_RETRY_DIS            (0x40)
#define MCF_USB_ENDPT10_HOST_WO_HUB          (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT11 */
#define MCF_USB_ENDPT11_EP_HSHK              (0x01)
#define MCF_USB_ENDPT11_EP_STALL             (0x02)
#define MCF_USB_ENDPT11_EP_EN_TX             (0x04)
#define MCF_USB_ENDPT11_EP_EN_RX             (0x08)
#define MCF_USB_ENDPT11_EP_CTL_DIS           (0x10)
#define MCF_USB_ENDPT11_RETRY_DIS            (0x40)
#define MCF_USB_ENDPT11_HOST_WO_HUB          (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT12 */
#define MCF_USB_ENDPT12_EP_HSHK              (0x01)
#define MCF_USB_ENDPT12_EP_STALL             (0x02)
#define MCF_USB_ENDPT12_EP_EN_TX             (0x04)
#define MCF_USB_ENDPT12_EP_EN_RX             (0x08)
#define MCF_USB_ENDPT12_EP_CTL_DIS           (0x10)
#define MCF_USB_ENDPT12_RETRY_DIS            (0x40)
#define MCF_USB_ENDPT12_HOST_WO_HUB          (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT13 */
#define MCF_USB_ENDPT13_EP_HSHK              (0x01)
#define MCF_USB_ENDPT13_EP_STALL             (0x02)
#define MCF_USB_ENDPT13_EP_EN_TX             (0x04)
#define MCF_USB_ENDPT13_EP_EN_RX             (0x08)
#define MCF_USB_ENDPT13_EP_CTL_DIS           (0x10)
#define MCF_USB_ENDPT13_RETRY_DIS            (0x40)
#define MCF_USB_ENDPT13_HOST_WO_HUB          (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT14 */
#define MCF_USB_ENDPT14_EP_HSHK              (0x01)
#define MCF_USB_ENDPT14_EP_STALL             (0x02)
#define MCF_USB_ENDPT14_EP_EN_TX             (0x04)
#define MCF_USB_ENDPT14_EP_EN_RX             (0x08)
#define MCF_USB_ENDPT14_EP_CTL_DIS           (0x10)
#define MCF_USB_ENDPT14_RETRY_DIS            (0x40)
#define MCF_USB_ENDPT14_HOST_WO_HUB          (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT15 */
#define MCF_USB_ENDPT15_EP_HSHK              (0x01)
#define MCF_USB_ENDPT15_EP_STALL             (0x02)
#define MCF_USB_ENDPT15_EP_EN_TX             (0x04)
#define MCF_USB_ENDPT15_EP_EN_RX             (0x08)
#define MCF_USB_ENDPT15_EP_CTL_DIS           (0x10)
#define MCF_USB_ENDPT15_RETRY_DIS            (0x40)
#define MCF_USB_ENDPT15_HOST_WO_HUB          (0x80)

/* Bit definitions and macros for MCF_USB_USB_CTRL */
#define MCF_USB_USB_CTRL_SUSP                (1<<7)
#define MCF_USB_USB_CTRL_PDE                 (1<<6)
#define MCF_USB_USB_CTRL_CLKSRC_ALT          (0<<0)
//#define MCF_USB_USB_CTRL_CLKSRC_OSC          (1<<0)
#define MCF_USB_USB_CTRL_CLKSRC_SYS          (3<<0)



/*********************************************************************
*
* I2C Module (I2C)
*
*********************************************************************/

/* Register read/write macros */
#define MCF_I2C_I2AR          (*(hcc_reg8 *)(&_IPSBAR[0x001838]))
#define MCF_I2C_I2FDR         (*(hcc_reg8 *)(&_IPSBAR[0x001839]))
#define MCF_I2C_I2CR          (*(hcc_reg8 *)(&_IPSBAR[0x00183A]))
#define MCF_I2C_I2SR          (*(hcc_reg8 *)(&_IPSBAR[0x00183B]))
#define MCF_I2C_I2DR          (*(hcc_reg8 *)(&_IPSBAR[0x00183C]))
#define MCF_I2C_I2CR2         (*(hcc_reg8 *)(&_IPSBAR[0x00183D]))

/* Bit definitions and macros for MCF_I2C_I2AR */
#define MCF_I2C_I2AR_ADR(x)   (((x)&0x7F)<<1)

/* Bit definitions and macros for MCF_I2C_I2FDR */
#define MCF_I2C_I2FDR_IC(x)   (((x)&0x3F)<<0)

/* Bit definitions and macros for MCF_I2C_I2CR */
#define MCF_I2C_I2CR_RSTA     (0x04)
#define MCF_I2C_I2CR_TXAK     (0x08)
#define MCF_I2C_I2CR_MTX      (0x10)
#define MCF_I2C_I2CR_MSTA     (0x20)
#define MCF_I2C_I2CR_IIEN     (0x40)
#define MCF_I2C_I2CR_IEN      (0x80)

/* Bit definitions and macros for MCF_I2C_I2SR */
#define MCF_I2C_I2SR_RXAK     (0x01)
#define MCF_I2C_I2SR_IIF      (0x02)
#define MCF_I2C_I2SR_SRW      (0x04)
#define MCF_I2C_I2SR_IAL      (0x10)
#define MCF_I2C_I2SR_IBB      (0x20)
#define MCF_I2C_I2SR_IAAS     (0x40)
#define MCF_I2C_I2SR_ICF      (0x80)

/* Bit definitions and macros for MCF_I2C_I2DR */
#define MCF_I2C_I2DR_DATA(x)  (((x)&0xFF)<<0)


/*---------- William ------------------------------------------*/
/* SCI1 */
#define MCF_SCI1BDH_REG                (*(hcc_reg8*)(&_IPSBAR[0x38]))
#define MCF_SCI1BDL_REG                (*(hcc_reg8*)(&_IPSBAR[0x39]))
#define MCF_SCI1C1_REG                (*(hcc_reg8*)(&_IPSBAR[0x3A]))
#define MCF_SCI1C2_REG                (*(hcc_reg8*)(&_IPSBAR[0x3B]))
#define MCF_SCI1S1_REG                (*(hcc_reg8*)(&_IPSBAR[0x3C]))
#define MCF_SCI1S2_REG                (*(hcc_reg8*)(&_IPSBAR[0x3D]))
#define MCF_SCI1C3_REG                (*(hcc_reg8*)(&_IPSBAR[0x3E]))
#define MCF_SCI1D_REG                  (*(hcc_reg8*)(&_IPSBAR[0x3F]))
#define MCF_SCI1BD_REG    (*(hcc_reg16*)(&_IPSBAR[0x38]))


/* SCI2 */
#define MCF_SCI2BDH_REG                (*(hcc_reg8*)(&_IPSBAR[0x40]))
#define MCF_SCI2BDL_REG                (*(hcc_reg8*)(&_IPSBAR[0x41]))
#define MCF_SCI2C1_REG                (*(hcc_reg8*)(&_IPSBAR[0x42]))
#define MCF_SCI2C2_REG                (*(hcc_reg8*)(&_IPSBAR[0x43]))
#define MCF_SCI2S1_REG                (*(hcc_reg8*)(&_IPSBAR[0x44]))
#define MCF_SCI2S2_REG                (*(hcc_reg8*)(&_IPSBAR[0x45]))
#define MCF_SCI2C3_REG                (*(hcc_reg8*)(&_IPSBAR[0x46]))
#define MCF_SCI2D_REG                  (*(hcc_reg8*)(&_IPSBAR[0x47]))
#define MCF_SCI2BD_REG    (*(hcc_reg16*)(&_IPSBAR[0x40]))


#define MCF_SCIBDH_REG(portno) (*(hcc_reg8*)(&_IPSBAR[0x38+(portno*8)]))
#define MCF_SCIBDL_REG(portno) (*(hcc_reg8*)(&_IPSBAR[0x39+(portno*8)]))
#define MCF_SCIC1_REG(portno)  (*(hcc_reg8*)(&_IPSBAR[0x3A+(portno*8)]))
#define MCF_SCIC2_REG(portno)  (*(hcc_reg8*)(&_IPSBAR[0x3B+(portno*8)]))
#define MCF_SCIS1_REG(portno)         (*(hcc_reg8*)(&_IPSBAR[0x3C+(portno*8)]))
#define MCF_SCIS2_REG(portno)         (*(hcc_reg8*)(&_IPSBAR[0x3D+(portno*8)]))
#define MCF_SCIC3_REG(portno)  (*(hcc_reg8*)(&_IPSBAR[0x3E+(portno*8)]))
#define MCF_SCID_REG(portno)         (*(hcc_reg8*)(&_IPSBAR[0x3F+(portno*8)]))
#define MCF_SCIBD_REG(portno)  (*(hcc_reg16*)(&_IPSBAR[0x38+(portno*8)]))

#if  (SCI_NO==0)
#define MCF_SCIBDH              MCF_SCI1BDH_REG
#define MCF_SCIBDL              MCF_SCI1BDL_REG
#define MCF_SCIC1               MCF_SCI1C1_REG
#define MCF_SCIC2               MCF_SCI1C2_REG
#define MCF_SCIS1               MCF_SCI1S1_REG
#define MCF_SCIS2               MCF_SCI1S2_REG
#define MCF_SCID                MCF_SCI1D_REG
#define MCF_SCIBD               MCF_SCI1BD_REG
#else
#define MCF_SCIBDH              MCF_SCI2BDH_REG
#define MCF_SCIBDL              MCF_SCI2BDL_REG
#define MCF_SCIC1               MCF_SCI2C1_REG
#define MCF_SCIC2               MCF_SCI2C2_REG
#define MCF_SCIS1               MCF_SCI2S1_REG
#define MCF_SCIS2               MCF_SCI2S2_REG
#define MCF_SCID                MCF_SCI2D_REG
#define MCF_SCIBD               MCF_SCI2BD_REG
#endif

/* Bit definition for SCIBDH register */
#define MCF_SCIBDH_REG_LBKDIE_BIT   (1<<7)
#define MCF_SCIBDH_REG_RXEDGIE_BIT  (1<<6)

/* Bit definition for SCIC1 register */
#define MCF_SCIC1_REG_LOOPS_BIT     (1<<7)
#define MCF_SCIC1_REG_SCISWAI_BIT   (1<<6)
#define MCF_SCIC1_REG_RSRC_BIT      (1<<5)
#define MCF_SCIC1_REG_M_BIT         (1<<4)
#define MCF_SCIC1_REG_WAKE_BIT      (1<<3)
#define MCF_SCIC1_REG_ILT_BIT       (1<<2)
#define MCF_SCIC1_REG_PE_BIT        (1<<1)
#define MCF_SCIC1_REG_PT_BIT        (1<<0)

/* Bit definition for SCIC2 register */
#define MCF_SCIC2_REG_TIE_BIT       (1<<7)
#define MCF_SCIC2_REG_TCIE_BIT      (1<<6)
#define MCF_SCIC2_REG_RIE_BIT       (1<<5)
#define MCF_SCIC2_REG_ILIE_BIT      (1<<4)
#define MCF_SCIC2_REG_TE_BIT        (1<<3)
#define MCF_SCIC2_REG_RE_BIT        (1<<2)
#define MCF_SCIC2_REG_RWU_BIT       (1<<1)
#define MCF_SCIC2_REG_SBK_BIT       (1<<0)

/* Bit definition for SCIC3 register */
#define MCF_SCIC3_REG_R8_BIT        (1<<7)
#define MCF_SCIC3_REG_T8_BIT        (1<<6)
#define MCF_SCIC3_REG_TXDIR_BIT     (1<<5)
#define MCF_SCIC3_REG_TXINV_BIT     (1<<4)
#define MCF_SCIC3_REG_ORIE_BIT      (1<<3)
#define MCF_SCIC3_REG_NEIE_BIT      (1<<2)
#define MCF_SCIC3_REG_FEIE_BIT      (1<<1)
#define MCF_SCIC3_REG_PEIE_BIT      (1<<0)


/* Bit definition for SCIS1 register */
#define MCF_SCIS1_REG_TDRE_BIT      (1<<7)
#define MCF_SCIS1_REG_TC_BIT        (1<<6)
#define MCF_SCIS1_REG_RDRF_BIT      (1<<5)
#define MCF_SCIS1_REG_IDLE_BIT      (1<<4)
#define MCF_SCIS1_REG_OR_BIT        (1<<3)
#define MCF_SCIS1_REG_NF_BIT        (1<<2)
#define MCF_SCIS1_REG_FE_BIT        (1<<1)
#define MCF_SCIS1_REG_PE_BIT        (1<<0)


/* Bit definition for SCIS2 register */
#define MCF_SCIS2_REG_LBKDIF_BIT    (1<<7)
#define MCF_SCIS2_REG_RXEDGIF_BIT   (1<<6)
#define MCF_SCIS2_REG_RXINV_BIT     (1<<4)
#define MCF_SCIS2_REG_RWUID_BIT     (1<<3)
#define MCF_SCIS2_REG_BRK13_BIT     (1<<2)
#define MCF_SCIS2_REG_LBKDE_BIT     (1<<1)
#define MCF_SCIS2_REG_RAF_BIT       (1<<0)


/* MCG */
#define MCF_MCGC1_REG     (*(hcc_reg8*)(&_IPSBAR[0x48]))
#define MCF_MCGC2_REG     (*(hcc_reg8*)(&_IPSBAR[0x49]))
#define MCF_MCGTRM_REG     (*(hcc_reg8*)(&_IPSBAR[0x4A]))
#define MCF_MCGSC_REG     (*(hcc_reg8*)(&_IPSBAR[0x4B]))
#define MCF_MCGC3_REG     (*(hcc_reg8*)(&_IPSBAR[0x4C]))
#define MCF_MCGT_REG     (*(hcc_reg8*)(&_IPSBAR[0x4D]))

/* Bit defintions for MCGC1 register */
#define MCF_MCGC1_REG_CLKS_BIT    (3<<6)
#define MCF_MCGC1_REG_RDIV_BIT    (7<<3)
#define MCF_MCGC1_REG_IREFS_BIT   (1<<2)
#define MCF_MCGC1_REG_IRCLKEN_BIT (1<<1)
#define MCF_MCGC1_REG_IREFSTEN_BIT    (1)


/* Bit defintions for MCGC2 register */
#define MCF_MCGC2_REG_BDIV_BIT    (2<<6)
#define MCF_MCGC2_REG_RANGE_BIT   (1<<5)
#define MCF_MCGC2_REG_HGO_BIT     (1<<4)
#define MCF_MCGC2_REG_LP_BIT      (1<<3)
#define MCF_MCGC2_REG_EREFS_BIT   (1<<2)
#define MCF_MCGC2_REG_ERCLKEN_BIT (1<<1)
#define MCF_MCGC2_REG_EREFSTEN_BIT    (1)


/* Bit defintions for MCGC3 register */
#define MCF_MCGC3_REG_LOLIE_BIT   (1<<7)
#define MCF_MCGC3_REG_PLLS_BIT    (1<<6)
#define MCF_MCGC3_REG_CME_BIT     (1<<5)
#define MCF_MCGC3_REG_DIV32_BIT   (1<<4)
#define MCF_MCGC3_REG_VDIV_BIT    (1)


/* Bit defintions for MCGSC register */
#define MCF_MCGSC_REG_LOLS_BIT    (1<<7)
#define MCF_MCGSC_REG_LOCK_BIT    (1<<6)
#define MCF_MCGSC_REG_PLLST_BIT   (1<<5)
#define MCF_MCGSC_REG_IREFST_BIT  (1<<4)
#define MCF_MCGSC_REG_CLKST_BIT   (3<<2)
#define MCF_MCGSC_REG_OSCINIT_BIT (1<<1)
#define MCF_MCGSC_REG_FTRIM_BIT   (1)


/* Real Time Clock */
#define MCF_RTCSC_REG                  (*(hcc_reg8*)(&_IPSBAR[0x6C]))
#define MCF_RTCCNT_REG                (*(hcc_reg8*)(&_IPSBAR[0x6D]))
#define MCF_RTCMOD_REG                (*(hcc_reg8*)(&_IPSBAR[0x6E]))

/* Bit definitions for RTC */
#define MCF_RTCSC_REG_RTIE_BIT  (1<<4)
#define MCF_RTCSC_REG_RTIF_BIT  (1<<7)

/* Bit values for RTC */
#define MCF_RTC_SOURCE_LPO   0
#define MCF_RTC_SOURCE_EXT   1
#define MCF_RTC_SOURCE_INT   2


/* Timer/PWM */
#define MCF_TPM1SC_REG        (*(hcc_reg8*)(&_IPSBAR[0x20]))
#define MCF_TPM1CNTH_REG      (*(hcc_reg8*)(&_IPSBAR[0x21]))
#define MCF_TPM1CNTL_REG      (*(hcc_reg8*)(&_IPSBAR[0x22]))
#define MCF_TPM1MODH_REG      (*(hcc_reg8*)(&_IPSBAR[0x23]))
#define MCF_TPM1MODL_REG      (*(hcc_reg8*)(&_IPSBAR[0x24]))
#define MCF_TPM1C0SC_REG      (*(hcc_reg8*)(&_IPSBAR[0x25]))
#define MCF_TPM1C0VH_REG      (*(hcc_reg8*)(&_IPSBAR[0x26]))
#define MCF_TPM1C0VL_REG      (*(hcc_reg8*)(&_IPSBAR[0x27]))
#define MCF_TPM1C1SC_REG      (*(hcc_reg8*)(&_IPSBAR[0x28]))
#define MCF_TPM1C1VH_REG      (*(hcc_reg8*)(&_IPSBAR[0x29]))
#define MCF_TPM1C1VL_REG      (*(hcc_reg8*)(&_IPSBAR[0x2A]))
#define MCF_TPM1C2SC_REG      (*(hcc_reg8*)(&_IPSBAR[0x2B]))
#define MCF_TPM1C2VH_REG      (*(hcc_reg8*)(&_IPSBAR[0x2C]))
#define MCF_TPM1C2VL_REG      (*(hcc_reg8*)(&_IPSBAR[0x2D]))
#define MCF_TPM1C3SC_REG      (*(hcc_reg8*)(&_IPSBAR[0x2E]))
#define MCF_TPM1C3VH_REG      (*(hcc_reg8*)(&_IPSBAR[0x2F]))
#define MCF_TPM1C3VL_REG      (*(hcc_reg8*)(&_IPSBAR[0x30]))

/* Timer/PWM word type registers */
#define MCF_TPM1CNT_REG      (*(hcc_reg16*)(&_IPSBAR[0x21]))  /* this may be problem because it is not aligned to word boundary.*/
#define MCF_TPM1MOD_REG      (*(hcc_reg16*)(&_IPSBAR[0x23]))  /* same boundary issue as above */
#define MCF_TPM1C0V_REG      (*(hcc_reg16*)(&_IPSBAR[0x26]))
#define MCF_TPM1C1V_REG      (*(hcc_reg16*)(&_IPSBAR[0x29]))
#define MCF_TPM1C2V_REG      (*(hcc_reg16*)(&_IPSBAR[0x2C]))
#define MCF_TPM1C3V_REG      (*(hcc_reg16*)(&_IPSBAR[0x2F]))

#define MCF_TPMxSC_REG        MCF_TPM1SC_REG
#define MCF_TPMxCNT_REG       MCF_TPM1CNT_REG
#define MCF_TPMxMOD_REG       MCF_TPM1MOD_REG
#define MCF_TPMxMODH_REG      MCF_TPM1MODH_REG
#define MCF_TPMxMODL_REG      MCF_TPM1MODL_REG
#define MCF_TPMxCnSC_REG      MCF_TPM1C0SC_REG
#define MCF_TPMxCnV_REG       MCF_TPM1C0V_REG


/* Bit/Bit mask definitions for TPMxSC register */
#define MCF_TPMSC_REG_TOF_BIT   (1<<7)
#define MCF_TPMSC_REG_TOIE_BIT  (1<<6)
#define MCF_TPMSC_REG_CPWMS_BIT (1<<5)
#define MCF_TPMSC_REG_CLKS_BIT  (3<<3)
#define MCF_TPMSC_REG_CLKS_BIT_POS  (3)
#define MCF_TPMSC_REG_PS_BIT    (7)

/* TPM Prescaler */
#define MCF_TPM_CLK_PRESCALOR_1   0
#define MCF_TPM_CLK_PRESCALOR_2   1
#define MCF_TPM_CLK_PRESCALOR_4   2
#define MCF_TPM_CLK_PRESCALOR_8   3
#define MCF_TPM_CLK_PRESCALOR_16  4
#define MCF_TPM_CLK_PRESCALOR_32  5
#define MCF_TPM_CLK_PRESCALOR_64  6
#define MCF_TPM_CLK_PRESCALOR_128 7


/* Bit/Bit mask definitions for TPMxCnSC register */
#define MCF_TPMCnSC_REG_CHnF_BIT   (1<<7)
#define MCF_TPMCnSC_REG_CHnIE_BIT  (1<<6)
#define MCF_TPMCnSC_REG_MSnBA_BIT_POS 4
#define MCF_TPMCnSC_REG_MSnBA_BIT  (3<<MCF_TPMCnSC_REG_MSnBA_BIT_POS)
#define MCF_TPMCnSC_REG_ELSn_BIT_POS  2
#define MCF_TPMCnSC_REG_ELSn_BIT   (2<<MCF_TPMCnSC_REG_ELSn_BIT_POS)

/* Mode, edge and level selection */
#define MCF_TPM_MODE_INPUT_CAPTURE  0    /* CPWMS = 0 in TPMSC register */
#define MCF_TPM_MODE_OUTPUT_COMPARE (1 << MCF_TPMCnSC_REG_MSnBA_BIT_POS)    /* CPWMS = 0 in TPMSC register */
#define MCF_TPM_MODE_PWM_EDGE       (2 << MCF_TPMCnSC_REG_MSnBA_BIT_POS)    /* CPWMS = 0 in TPMSC register */
#define MCF_TPM_MODE_PWM_CENTER     MCF_TPMSC_REG_CPWMS_BIT    /* CPWMS = 1 in TPMSC register */

#define MCF_TPM_EDGE_RISING         (1 << MCF_TPMCnSC_REG_ELSn_BIT_POS)
#define MCF_TPM_EDGE_FALLING        (2 << MCF_TPMCnSC_REG_ELSn_BIT_POS)
#define MCF_TPM_EDGE_BOTH           (3 << MCF_TPMCnSC_REG_ELSn_BIT_POS)

#define MCF_TPM_OUTPUT_SW           0
#define MCF_TPM_OUTPUT_TOGGLE       (1 << MCF_TPMCnSC_REG_ELSn_BIT_POS)
#define MCF_TPM_OUTPUT_CLEAR        (2 << MCF_TPMCnSC_REG_ELSn_BIT_POS)
#define MCF_TPM_OUTPUT_SET          (3 << MCF_TPMCnSC_REG_ELSn_BIT_POS)

#define MCF_TPM_PWM_OUTPUT_HIGH       MCF_TPM_OUTPUT_CLEAR
#define MCF_TPM_PWM_OUTPUT_LOW        MCF_TPM_OUTPUT_SET

/* Input capture macros */
#define MCF_TPM_MODE_INPUT_CAPTURE_RISING_EDGE  ( MCF_TPM_MODE_INPUT_CAPTURE |  MCF_TPM_EDGE_RISING)
#define MCF_TPM_MODE_INPUT_CAPTURE_FALLING_EDGE  ( MCF_TPM_MODE_INPUT_CAPTURE |  MCF_TPM_EDGE_FALLING)
#define MCF_TPM_MODE_INPUT_CAPTURE_BOTH_EDGE  ( MCF_TPM_MODE_INPUT_CAPTURE |  MCF_TPM_EDGE_BOTH)

/* Output compare macros */
#define MCF_TPM_MODE_OUTPUT_COMPARE_SW        (MCF_TPM_MODE_OUTPUT_COMPARE |  MCF_TPM_OUTPUT_SW)
#define MCF_TPM_MODE_OUTPUT_COMPARE_TOGGLE    (MCF_TPM_MODE_OUTPUT_COMPARE |  MCF_TPM_OUTPUT_TOGGLE)
#define MCF_TPM_MODE_OUTPUT_COMPARE_CLEAR     (MCF_TPM_MODE_OUTPUT_COMPARE |  MCF_TPM_OUTPUT_CLEAR)
#define MCF_TPM_MODE_OUTPUT_COMPARE_SET       (MCF_TPM_MODE_OUTPUT_COMPARE |  MCF_TPM_OUTPUT_SET)

/* Clock source selection */
#define MCF_TPM_CLK_SRC_NO          0
#define MCF_TPM_CLK_SRC_BUS_CLK     (1<<MCF_TPMSC_REG_CLKS_BIT_POS)
#define MCF_TPM_CLK_SRC_FIX_CLK     (2<<MCF_TPMSC_REG_CLKS_BIT_POS)
#define MCF_TPM_CLK_SRC_EXT_CLK     (3<<MCF_TPMSC_REG_CLKS_BIT_POS)

/* Port D register definitions */
#define  MCF_PTDD_REG         (*(hcc_reg8*)(&_IPSBAR[0x6]))
#define  MCF_PTDDD_REG        (*(hcc_reg8*)(&_IPSBAR[0x7]))
#define   MCF_PTDPE_REG        (*(hcc_reg8*)(&_IPSBAR[0x184C]))
#define   MCF_PTDSE_REG        (*(hcc_reg8*)(&_IPSBAR[0x184D]))
#define   MCF_PTDDS_REG        (*(hcc_reg8*)(&_IPSBAR[0x184E]))
#define   MCF_PTDIFE_REG       (*(hcc_reg8*)(&_IPSBAR[0x184F]))


/* System Integration Module (Refer to Chapter 5 of Soc Guide) */
#define MCF_SIMOPT1_REG       (*(hcc_reg8*)(&_IPSBAR[0x1802]))
#define MCF_SIMOPT2_REG       (*(hcc_reg8*)(&_IPSBAR[0x1803]))

#define MCF_SIMOPT1_REG_COPT_BIT  (3<<6)


/* Flash */
#define MCF_FCDIV_REG       (*(hcc_reg8*)(&_IPSBAR[0x1820]))
#define MCF_FOPT_REG        (*(hcc_reg8*)(&_IPSBAR[0x1821]))
#define MCF_FRSV0_REG       (*(hcc_reg8*)(&_IPSBAR[0x1822]))
#define MCF_FCNFG_REG       (*(hcc_reg8*)(&_IPSBAR[0x1823]))
#define MCF_FPROT_REG       (*(hcc_reg8*)(&_IPSBAR[0x1824]))
#define MCF_FSTAT_REG       (*(hcc_reg8*)(&_IPSBAR[0x1825]))
#define MCF_FCMD_REG        (*(hcc_reg8*)(&_IPSBAR[0x1826]))
#define MCF_FRSV1_REG       (*(hcc_reg8*)(&_IPSBAR[0x1827]))
#define MCF_FADDRHI_REG     (*(hcc_reg8*)(&_IPSBAR[0x1828]))
#define MCF_FADDRLO_REG     (*(hcc_reg8*)(&_IPSBAR[0x1829]))
#define MCF_FRSV2_REG       (*(hcc_reg8*)(&_IPSBAR[0x182A]))
#define MCF_FRSV3_REG       (*(hcc_reg8*)(&_IPSBAR[0x182B]))
#define MCF_FDATAHI1_REG    (*(hcc_reg8*)(&_IPSBAR[0x182C]))
#define MCF_FDATALO1_REG       (*(hcc_reg8*)(&_IPSBAR[0x182D]))
#define MCF_FDATAHI0_REG       (*(hcc_reg8*)(&_IPSBAR[0x182E]))
#define MCF_FDATALO0_REG       (*(hcc_reg8*)(&_IPSBAR[0x182F]))




/* Interrupt No. */
#define VectorNumber_VRTC     VectorNumber_Vrtc //29
#define VectorNumber_TPM1Ovf    VectorNumber_Vtpm1ovf
#define VectorNumber_TPM1CH0F    VectorNumber_Vtpm1ch0

#define VectorNumber_TICK1ms  VectorNumber_TPM1CH0F //VectorNumber_TPM1

#endif
/****************************** END OF FILE **********************************/
%endif
/****************************** END OF FILE **********************************/
%if %CPUDerivative='MCF52259'
%-*****************************************************************************************************
%FILE %'DirRel_Code'mcf5222x_reg.h
%-*****************************************************************************************************
/***************************************************************************
 *
 *            Copyright (c) 2006-2007 by CMX Systems, Inc.
 *
 * This software is copyrighted by and is the sole property of
 * CMX.  All rights, title, ownership, or other interests
 * in the software remain the property of CMX.  This
 * software may only be used in accordance with the corresponding
 * license agreement.  Any unauthorized use, duplication, transmission,
 * distribution, or disclosure of this software is expressly forbidden.
 *
 * This Copyright notice may not be removed or modified without prior
 * written consent of CMX.
 *
 * CMX reserves the right to modify this software without notice.
 *
 * CMX Systems, Inc.
 * 12276 San Jose Blvd. #511
 * Jacksonville, FL 32223
 * USA
 *
 * Tel:  (904) 880-1840
 * Fax:  (904) 880-1632
 * http: www.cmx.com
 * email: cmx@cmx.com
 *
 ***************************************************************************/
#ifndef _MCF5222X_REGS_H_
#define _MCF5222X_REGS_H_

#include "hcc_types.h"

#define nop()       asm( nop)

/*
 * Memory map definitions from linker command files
 */
#if 0 /* adaption for Processor Expert */
  extern hcc_u8 _IPSBAR[];
#else
  #define _IPSBAR ((char*)0x40000000)
#endif
extern hcc_u32 _SRAM[];

/*
 * Memory Map Info
 */
//#define IPSBAR_ADDRESS                        (hcc_u32)_IPSBAR

#define SRAM_ADDRESS                        (hcc_u32)_SRAM

#define BITX(x) (1U<<(x))
#define BIT0        BITX(0)
#define BIT1        BITX(1)
#define BIT2        BITX(2)
#define BIT3        BITX(3)
#define BIT4        BITX(4)
#define BIT5        BITX(5)
#define BIT6        BITX(6)
#define BIT7         BITX(7)
#define BIT8        BITX(8)
#define BIT9        BITX(9)
#define BIT10   BITX(10)
#define BIT11        BITX(11)
#define BIT12   BITX(12)
#define BIT13        BITX(13)
#define BIT14   BITX(14)
#define BIT15        BITX(15)
#define BIT16   BITX(16)
#define BIT17        BITX(17)
#define BIT18   BITX(18)
#define BIT19        BITX(19)
#define BIT20   BITX(20)
#define BIT21        BITX(21)
#define BIT22   BITX(22)
#define BIT23        BITX(23)
#define BIT24   BITX(24)
#define BIT25        BITX(25)
#define BIT26   BITX(26)
#define BIT27        BITX(27)
#define BIT28   BITX(28)
#define BIT29        BITX(29)
#define BIT30   BITX(30)
#define BIT31        BITX(31)

/*********************************************************************
*
* Core register bit definitions
*
*********************************************************************/
/* Status Register */
#define MCF5XXX_SR_T        (0x8000)
#define MCF5XXX_SR_S        (0x2000)
#define MCF5XXX_SR_M        (0x1000)
#define MCF5XXX_SR_IPL      (0x0700)
#define MCF5XXX_SR_IPL_0    (0x0000)
#define MCF5XXX_SR_IPL_1    (0x0100)
#define MCF5XXX_SR_IPL_2    (0x0200)
#define MCF5XXX_SR_IPL_3    (0x0300)
#define MCF5XXX_SR_IPL_4    (0x0400)
#define MCF5XXX_SR_IPL_5    (0x0500)
#define MCF5XXX_SR_IPL_6    (0x0600)
#define MCF5XXX_SR_IPL_7    (0x0700)
#define MCF5XXX_SR_X        (0x0010)
#define MCF5XXX_SR_N        (0x0008)
#define MCF5XXX_SR_Z        (0x0004)
#define MCF5XXX_SR_V        (0x0002)
#define MCF5XXX_SR_C        (0x0001)

/* Cache Control Register */
#define MCF5XXX_CACR_CENB       (0x80000000)
#define MCF5XXX_CACR_DEC        (0x80000000)
#define MCF5XXX_CACR_DW         (0x40000000)
#define MCF5XXX_CACR_DESB       (0x20000000)
#define MCF5XXX_CACR_CPDI       (0x10000000)
#define MCF5XXX_CACR_DDPI       (0x10000000)
#define MCF5XXX_CACR_CPD        (0x10000000)
#define MCF5XXX_CACR_CFRZ       (0x08000000)
#define MCF5XXX_CACR_DHLCK      (0x08000000)
#define MCF5XXX_CACR_DDCM_WT    (0x00000000)
#define MCF5XXX_CACR_DDCM_CB    (0x02000000)
#define MCF5XXX_CACR_DDCM_IP    (0x04000000)
#define MCF5XXX_CACR_DDCM_II    (0x06000000)
#define MCF5XXX_CACR_CINV       (0x01000000)
#define MCF5XXX_CACR_DCINVA     (0x01000000)
#define MCF5XXX_CACR_DIDI       (0x00800000)
#define MCF5XXX_CACR_DDSP       (0x00800000)
#define MCF5XXX_CACR_DISD       (0x00400000)
#define MCF5XXX_CACR_INVI       (0x00200000)
#define MCF5XXX_CACR_INVD       (0x00100000)
#define MCF5XXX_CACR_BEC        (0x00080000)
#define MCF5XXX_CACR_BCINVA     (0x00040000)
#define MCF5XXX_CACR_IEC        (0x00008000)
#define MCF5XXX_CACR_DNFB       (0x00002000)
#define MCF5XXX_CACR_IDPI       (0x00001000)
#define MCF5XXX_CACR_IHLCK      (0x00000800)
#define MCF5XXX_CACR_CEIB       (0x00000400)
#define MCF5XXX_CACR_IDCM       (0x00000400)
#define MCF5XXX_CACR_DCM_WR     (0x00000000)
#define MCF5XXX_CACR_DCM_CB     (0x00000100)
#define MCF5XXX_CACR_DCM_IP     (0x00000200)
#define MCF5XXX_CACR_DCM        (0x00000200)
#define MCF5XXX_CACR_DCM_II     (0x00000300)
#define MCF5XXX_CACR_DBWE       (0x00000100)
#define MCF5XXX_CACR_ICINVA     (0x00000100)
#define MCF5XXX_CACR_IDSP       (0x00000080)
#define MCF5XXX_CACR_DWP        (0x00000020)
#define MCF5XXX_CACR_EUSP       (0x00000020)
#define MCF5XXX_CACR_EUST       (0x00000020)
#define MCF5XXX_CACR_DF         (0x00000010)
#define MCF5XXX_CACR_CLNF_00    (0x00000000)
#define MCF5XXX_CACR_CLNF_01    (0x00000002)
#define MCF5XXX_CACR_CLNF_10    (0x00000004)
#define MCF5XXX_CACR_CLNF_11    (0x00000006)

/* Access Control Register */
#define MCF5XXX_ACR_AB(a)       ((a)&0xFF000000)
#define MCF5XXX_ACR_AM(a)       (((a)&0xFF000000) >> 8)
#define MCF5XXX_ACR_AM_4G       (0x00FF0000)
#define MCF5XXX_ACR_AM_2G       (0x007F0000)
#define MCF5XXX_ACR_AM_1G       (0x003F0000)
#define MCF5XXX_ACR_AM_1024M    (0x003F0000)
#define MCF5XXX_ACR_AM_512M     (0x001F0000)
#define MCF5XXX_ACR_AM_256M     (0x000F0000)
#define MCF5XXX_ACR_AM_128M     (0x00070000)
#define MCF5XXX_ACR_AM_64M      (0x00030000)
#define MCF5XXX_ACR_AM_32M      (0x00010000)
#define MCF5XXX_ACR_AM_16M      (0x00000000)
#define MCF5XXX_ACR_EN          (0x00008000)
#define MCF5XXX_ACR_SM_USER     (0x00000000)
#define MCF5XXX_ACR_SM_SUPER    (0x00002000)
#define MCF5XXX_ACR_SM_IGNORE   (0x00006000)
#define MCF5XXX_ACR_ENIB        (0x00000080)
#define MCF5XXX_ACR_CM          (0x00000040)
#define MCF5XXX_ACR_DCM_WR      (0x00000000)
#define MCF5XXX_ACR_DCM_CB      (0x00000020)
#define MCF5XXX_ACR_DCM_IP      (0x00000040)
#define MCF5XXX_ACR_DCM_II      (0x00000060)
#define MCF5XXX_ACR_CM          (0x00000040)
#define MCF5XXX_ACR_BWE         (0x00000020)
#define MCF5XXX_ACR_WP          (0x00000004)

/* RAM Base Address Register */
#define MCF5XXX_RAMBAR_BA(a)    ((a)&0xFFFFC000)
#define MCF5XXX_RAMBAR_PRI_00   (0x00000000)
#define MCF5XXX_RAMBAR_PRI_01   (0x00004000)
#define MCF5XXX_RAMBAR_PRI_10   (0x00008000)
#define MCF5XXX_RAMBAR_PRI_11   (0x0000C000)
#define MCF5XXX_RAMBAR_WP       (0x00000100)
#define MCF5XXX_RAMBAR_CI       (0x00000020)
#define MCF5XXX_RAMBAR_SC       (0x00000010)
#define MCF5XXX_RAMBAR_SD       (0x00000008)
#define MCF5XXX_RAMBAR_UC       (0x00000004)
#define MCF5XXX_RAMBAR_UD       (0x00000002)
#define MCF5XXX_RAMBAR_V        (0x00000001)

/*********************************************************************
*
* System Control Module (SCM)
*
*********************************************************************/

/* Register read/write macros */
#define MCF_SCM_IPSBAR               (*(hcc_reg32*)(&_IPSBAR[0x000000]))
#define MCF_SCM_RAMBAR               (*(hcc_reg32*)(&_IPSBAR[0x000008]))
#define MCF_SCM_CRSR                 (*(hcc_reg8 *)(&_IPSBAR[0x000010]))
#define MCF_SCM_CWCR                 (*(hcc_reg8 *)(&_IPSBAR[0x000011]))
#define MCF_SCM_LPICR                (*(hcc_reg8 *)(&_IPSBAR[0x000012]))
#define MCF_SCM_CWSR                 (*(hcc_reg8 *)(&_IPSBAR[0x000013]))
#define MCF_SCM_PPMRH                (*(hcc_reg32*)(&_IPSBAR[0x00000C]))
#define MCF_SCM_PPMRL                (*(hcc_reg32*)(&_IPSBAR[0x000018]))
#define MCF_SCM_PPMRS                (*(hcc_reg8 *)(&_IPSBAR[0x000021]))
#define MCF_SCM_PPMRC                (*(hcc_reg8 *)(&_IPSBAR[0x000022]))

/* Bit definitions and macros for MCF_SCM_IPSBAR */
#define MCF_SCM_IPSBAR_V             (0x00000001)
#define MCF_SCM_IPSBAR_BA(x)         ((x)&0xC0000000)

/* Bit definitions and macros for MCF_SCM_RAMBAR */
#define MCF_SCM_RAMBAR_BDE           (0x00000200)
#define MCF_SCM_RAMBAR_BA(x)         ((x)&0xFFFF0000)

/* Bit definitions and macros for MCF_SCM_CRSR */
#define MCF_SCM_CRSR_CWDR            (0x20)
#define MCF_SCM_CRSR_EXT             (0x80)

/* Bit definitions and macros for MCF_SCM_CWCR */
#define MCF_SCM_CWCR_CWTIC           (0x01)
#define MCF_SCM_CWCR_CWTAVAL         (0x02)
#define MCF_SCM_CWCR_CWTA            (0x04)
#define MCF_SCM_CWCR_CWT(x)          (((x)&0x07)<<3)
#define MCF_SCM_CWCR_CWRI            (0x40)
#define MCF_SCM_CWCR_CWE             (0x80)

/* Bit definitions and macros for MCF_SCM_LPICR */
#define MCF_SCM_LPICR_XIPL(x)        (((x)&0x07)<<4)
#define MCF_SCM_LPICR_ENBSTOP        (0x80)

/* Bit definitions and macros for MCF_SCM_CWSR */
#define MCF_SCM_CWSR_CWSR(x)         (((x)&0xFF)<<0)

/* Bit definitions and macros for MCF_SCM_PPMRH */
#define MCF_SCM_PPMRH_CDPORTS        (0x00000001)
#define MCF_SCM_PPMRH_CDEPORT        (0x00000002)
#define MCF_SCM_PPMRH_CDPIT0         (0x00000008)
#define MCF_SCM_PPMRH_CDPIT1         (0x00000010)
#define MCF_SCM_PPMRH_CDADC          (0x00000080)
#define MCF_SCM_PPMRH_CDGPT          (0x00000100)
#define MCF_SCM_PPMRH_CDPWN          (0x00000200)
#define MCF_SCM_PPMRH_CDFCAN         (0x00000400)
#define MCF_SCM_PPMRH_CDCFM          (0x00000800)

/* Bit definitions and macros for MCF_SCM_PPMRL */
#define MCF_SCM_PPMRL_CDG            (0x00000002)
#define MCF_SCM_PPMRL_CDEIM          (0x00000008)
#define MCF_SCM_PPMRL_CDDMA          (0x00000010)
#define MCF_SCM_PPMRL_CDUART0        (0x00000020)
#define MCF_SCM_PPMRL_CDUART1        (0x00000040)
#define MCF_SCM_PPMRL_CDUART2        (0x00000080)
#define MCF_SCM_PPMRL_CDI2C          (0x00000200)
#define MCF_SCM_PPMRL_CDQSPI         (0x00000400)
#define MCF_SCM_PPMRL_CDDTIM0        (0x00002000)
#define MCF_SCM_PPMRL_CDDTIM1        (0x00004000)
#define MCF_SCM_PPMRL_CDDTIM2        (0x00008000)
#define MCF_SCM_PPMRL_CDDTIM3        (0x00010000)
#define MCF_SCM_PPMRL_CDINTC0        (0x00020000)

/* Bit definitions and macros for MCF_SCM_PPMRS */
#define MCF_SCM_PPMRS_DISABLE_ALL    (64)
#define MCF_SCM_PPMRS_DISABLE_CFM    (43)
#define MCF_SCM_PPMRS_DISABLE_CAN    (42)
#define MCF_SCM_PPMRS_DISABLE_PWM    (41)
#define MCF_SCM_PPMRS_DISABLE_GPT    (40)
#define MCF_SCM_PPMRS_DISABLE_ADC    (39)
#define MCF_SCM_PPMRS_DISABLE_PIT1   (36)
#define MCF_SCM_PPMRS_DISABLE_PIT0   (35)
#define MCF_SCM_PPMRS_DISABLE_EPORT  (33)
#define MCF_SCM_PPMRS_DISABLE_PORTS  (32)
#define MCF_SCM_PPMRS_DISABLE_INTC   (17)
#define MCF_SCM_PPMRS_DISABLE_DTIM3  (16)
#define MCF_SCM_PPMRS_DISABLE_DTIM2  (15)
#define MCF_SCM_PPMRS_DISABLE_DTIM1  (14)
#define MCF_SCM_PPMRS_DISABLE_DTIM0  (13)
#define MCF_SCM_PPMRS_DISABLE_QSPI   (10)
#define MCF_SCM_PPMRS_DISABLE_I2C    (9)
#define MCF_SCM_PPMRS_DISABLE_UART2  (7)
#define MCF_SCM_PPMRS_DISABLE_UART1  (6)
#define MCF_SCM_PPMRS_DISABLE_UART0  (5)
#define MCF_SCM_PPMRS_DISABLE_DMA    (4)
#define MCF_SCM_PPMRS_SET_CDG        (1)

/* Bit definitions and macros for MCF_SCM_PPMRC */
#define MCF_SCM_PPMRC_ENABLE_ALL     (64)
#define MCF_SCM_PPMRC_ENABLE_CFM     (43)
#define MCF_SCM_PPMRC_ENABLE_CAN     (42)
#define MCF_SCM_PPMRC_ENABLE_PWM     (41)
#define MCF_SCM_PPMRC_ENABLE_GPT     (40)
#define MCF_SCM_PPMRC_ENABLE_ADC     (39)
#define MCF_SCM_PPMRC_ENABLE_PIT1    (36)
#define MCF_SCM_PPMRC_ENABLE_PIT0    (35)
#define MCF_SCM_PPMRC_ENABLE_EPORT   (33)
#define MCF_SCM_PPMRC_ENABLE_PORTS   (32)
#define MCF_SCM_PPMRC_ENABLE_INTC    (17)
#define MCF_SCM_PPMRC_ENABLE_DTIM3   (16)
#define MCF_SCM_PPMRC_ENABLE_DTIM2   (15)
#define MCF_SCM_PPMRC_ENABLE_DTIM1   (14)
#define MCF_SCM_PPMRC_ENABLE_DTIM0   (13)
#define MCF_SCM_PPMRC_ENABLE_QSPI    (10)
#define MCF_SCM_PPMRC_ENABLE_I2C     (9)
#define MCF_SCM_PPMRC_ENABLE_UART2   (7)
#define MCF_SCM_PPMRC_ENABLE_UART1   (6)
#define MCF_SCM_PPMRC_ENABLE_UART0   (5)
#define MCF_SCM_PPMRC_ENABLE_DMA     (4)
#define MCF_SCM_PPMRC_CLEAR_CDG      (1)

/*********************************************************************
*
* Clock Module (CLOCK)
*
*********************************************************************/

/* Register read/write macros */
#define MCF_CLOCK_SYNCR           (*(hcc_reg16*)(&_IPSBAR[0x120000]))
#define MCF_CLOCK_SYNSR           (*(hcc_reg8 *)(&_IPSBAR[0x120002]))
#define MCF_CLOCK_LPCR            (*(hcc_reg8 *)(&_IPSBAR[0x120007]))
#define MCF_CLOCK_CCHR            (*(hcc_reg8 *)(&_IPSBAR[0x120008]))
#define MCF_CLOCK_RTCDR           (*(hcc_reg32*)(&_IPSBAR[0x12000C]))

#define MCF_CLOCK_CCLR            (*(hcc_reg8 *)(0x40120009))
#define MCF_CLOCK_OCHR            (*(hcc_reg8 *)(0x4012000A))
#define MCF_CLOCK_OCLR            (*(hcc_reg8 *)(0x4012000B))

/* Bit definitions and macros for MCF_CLOCK_SYNCR */
#define MCF_CLOCK_SYNCR_PLLEN     (0x0001)
#define MCF_CLOCK_SYNCR_PLLMODE   (0x0002)
#define MCF_CLOCK_SYNCR_CLKSRC    (0x0004)
#define MCF_CLOCK_SYNCR_FWKUP     (0x0020)
#define MCF_CLOCK_SYNCR_DISCLK    (0x0040)
#define MCF_CLOCK_SYNCR_LOCEN     (0x0080)
#define MCF_CLOCK_SYNCR_RFD(x)    (((x)&0x0007)<<8)
#define MCF_CLOCK_SYNCR_LOCRE     (0x0800)
#define MCF_CLOCK_SYNCR_MFD(x)    (((x)&0x0007)<<12)
#define MCF_CLOCK_SYNCR_LOLRE     (0x8000)

/* Bit definitions and macros for MCF_CLOCK_SYNSR */
#define MCF_CLOCK_SYNSR_LOCS      (0x04)
#define MCF_CLOCK_SYNSR_LOCK      (0x08)
#define MCF_CLOCK_SYNSR_LOCKS     (0x10)
#define MCF_CLOCK_SYNSR_CRYOSC    (0x20)
#define MCF_CLOCK_SYNSR_OCOSC     (0x40)
#define MCF_CLOCK_SYNSR_EXTOSC    (0x80)

/* Bit definitions and macros for MCF_CLOCK_LPCR */
#define MCF_CLOCK_LPCR_LPD(x)     (((x)&0x0F)<<0)

/* Bit definitions and macros for MCF_CLOCK_CCHR */
#define MCF_CLOCK_CCHR_PFD(x)     (((x)&0x07)<<0)

/* Bit definitions and macros for MCF_CLOCK_RTCDR */
#define MCF_CLOCK_RTCDR_RTCDF(x)  (((x)&0xFFFFFFFF)<<0)


/*********************************************************************
*
* Universal Serial Bus (USB)
*
*********************************************************************/

/* Register read/write macros */
#define MCF_USB_PER_ID                       (*(hcc_reg8 *)(&_IPSBAR[0x1C0000]))
#define MCF_USB_IP_COMP                      (*(hcc_reg8 *)(&_IPSBAR[0x1C0004]))
#define MCF_USB_REV                          (*(hcc_reg8 *)(&_IPSBAR[0x1C0008]))
#define MCF_USB_ADD_INFO                     (*(hcc_reg8 *)(&_IPSBAR[0x1C000C]))
#define MCF_USB_OTG_INT_STAT                 (*(hcc_reg8 *)(&_IPSBAR[0x1C0010]))
#define MCF_USB_OTG_INT_EN                   (*(hcc_reg8 *)(&_IPSBAR[0x1C0014]))
#define MCF_USB_OTG_STATUS                   (*(hcc_reg8 *)(&_IPSBAR[0x1C0018]))
#define MCF_USB_OTG_CTRL                     (*(hcc_reg8 *)(&_IPSBAR[0x1C001C]))
#define MCF_USB_INT_STAT                     (*(hcc_reg8 *)(&_IPSBAR[0x1C0080]))
#define MCF_USB_INT_ENB                      (*(hcc_reg8 *)(&_IPSBAR[0x1C0084]))
#define MCF_USB_ERR_STAT                     (*(hcc_reg8 *)(&_IPSBAR[0x1C0088]))
#define MCF_USB_ERR_ENB                      (*(hcc_reg8 *)(&_IPSBAR[0x1C008C]))
#define MCF_USB_STAT                         (*(hcc_reg8 *)(&_IPSBAR[0x1C0090]))
#define MCF_USB_CTL                          (*(hcc_reg8 *)(&_IPSBAR[0x1C0094]))
#define MCF_USB_ADDR                         (*(hcc_reg8 *)(&_IPSBAR[0x1C0098]))
#define MCF_USB_BDT_PAGE_01                  (*(hcc_reg8 *)(&_IPSBAR[0x1C009C]))
#define MCF_USB_FRM_NUML                     (*(hcc_reg8 *)(&_IPSBAR[0x1C00A0]))
#define MCF_USB_FRM_NUMH                     (*(hcc_reg8 *)(&_IPSBAR[0x1C00A4]))
#define MCF_USB_FRM_NUM       (MCF_USB_INT_STAT=MCF_USB_INT_STAT_SOF_TOK ,MCF_USB_FRM_NUML | (((hcc_u16)MCF_USB_FRM_NUMH)<<8))
#define MCF_USB_TOKEN                        (*(hcc_reg8 *)(&_IPSBAR[0x1C00A8]))
#define MCF_USB_SOF_THLDL                    (*(hcc_reg8 *)(&_IPSBAR[0x1C00AC]))
#define MCF_USB_BDT_PAGE_02                  (*(hcc_reg8 *)(&_IPSBAR[0x1C00B0]))
#define MCF_USB_BDT_PAGE_03                  (*(hcc_reg8 *)(&_IPSBAR[0x1C00B4]))
#define MCF_USB_ENDPT0                       (*(hcc_reg8 *)(&_IPSBAR[0x1C00C0]))
#define MCF_USB_ENDPT1                       (*(hcc_reg8 *)(&_IPSBAR[0x1C00C4]))
#define MCF_USB_ENDPT2                       (*(hcc_reg8 *)(&_IPSBAR[0x1C00C8]))
#define MCF_USB_ENDPT3                       (*(hcc_reg8 *)(&_IPSBAR[0x1C00CC]))
#define MCF_USB_ENDPT4                       (*(hcc_reg8 *)(&_IPSBAR[0x1C00D0]))
#define MCF_USB_ENDPT5                       (*(hcc_reg8 *)(&_IPSBAR[0x1C00D4]))
#define MCF_USB_ENDPT6                       (*(hcc_reg8 *)(&_IPSBAR[0x1C00D8]))
#define MCF_USB_ENDPT7                       (*(hcc_reg8 *)(&_IPSBAR[0x1C00DC]))
#define MCF_USB_ENDPT8                       (*(hcc_reg8 *)(&_IPSBAR[0x1C00E0]))
#define MCF_USB_ENDPT9                       (*(hcc_reg8 *)(&_IPSBAR[0x1C00E4]))
#define MCF_USB_ENDPT10                      (*(hcc_reg8 *)(&_IPSBAR[0x1C00E8]))
#define MCF_USB_ENDPT11                      (*(hcc_reg8 *)(&_IPSBAR[0x1C00EC]))
#define MCF_USB_ENDPT12                      (*(hcc_reg8 *)(&_IPSBAR[0x1C00F0]))
#define MCF_USB_ENDPT13                      (*(hcc_reg8 *)(&_IPSBAR[0x1C00F4]))
#define MCF_USB_ENDPT14                      (*(hcc_reg8 *)(&_IPSBAR[0x1C00F8]))
#define MCF_USB_ENDPT15                      (*(hcc_reg8 *)(&_IPSBAR[0x1C00FC]))
#define MCF_USB_USB_CTRL                     (*(hcc_reg8 *)(&_IPSBAR[0x1C0100]))
#define MCF_USB_USB_OTG_OBSERVE              (*(hcc_reg8 *)(&_IPSBAR[0x1C0104]))
#define MCF_USB_USB_OTG_CONTROL              (*(hcc_reg8 *)(&_IPSBAR[0x1C0108]))

/* Bit definitions and macros for MCF_USB_PER_ID */
#define MCF_USB_PER_ID_ID(x)                 (((x)&0x3F)<<0)

/* Bit definitions and macros for MCF_USB_IP_COMP */
#define MCF_USB_IP_COMP_NID(x)               (((x)&0x3F)<<0)

/* Bit definitions and macros for MCF_USB_REV */
#define MCF_USB_REV_REV(x)                   (((x)&0xFF)<<0)

/* Bit definitions and macros for MCF_USB_ADD_INFO */
#define MCF_USB_ADD_INFO_HOST                (0x01)
#define MCF_USB_ADD_INFO_IRQ_NUM(x)          (((x)&0x1F)<<3)

/* Bit definitions and macros for MCF_USB_OTG_INT_STAT */
#define MCF_USB_OTG_INT_STAT_A_VBUS_VLD_CHG  (0x01)
#define MCF_USB_OTG_INT_STAT_B_SESS_END_CHG  (0x04)
#define MCF_USB_OTG_INT_STAT_SESS_VLD_CHG    (0x08)
#define MCF_USB_OTG_INT_STAT_LINE_STATE      (0x20)
#define MCF_USB_OTG_INT_STAT_1_MSEC          (0x40)
#define MCF_USB_OTG_INT_STAT_ID_CHG          (0x80)

/* Bit definitions and macros for MCF_USB_OTG_INT_EN */
#define MCF_USB_OTG_INT_EN_A_VBUS_VLD_EN     (0x01)
#define MCF_USB_OTG_INT_EN_B_SESS_END_EN     (0x04)
#define MCF_USB_OTG_INT_EN_SESS_VLD_EN       (0x08)
#define MCF_USB_OTG_INT_EN_LINE_STATE        (0x20)
#define MCF_USB_OTG_INT_EN_1_MSEC_EN         (0x40)
#define MCF_USB_OTG_INT_EN_ID_EN             (0x80)

/* Bit definitions and macros for MCF_USB_OTG_STATUS */
#define MCF_USB_OTG_STATUS_A_VBUS_VLD        (0x01)
#define MCF_USB_OTG_STATUS_B_SESS_END        (0x04)
#define MCF_USB_OTG_STATUS_SESS_VLD          (0x08)
#define MCF_USB_OTG_STATUS_LINE_STATE        (0x20)
#define MCF_USB_OTG_STATUS_1_MSEC            (0x40)
#define MCF_USB_OTG_STATUS_ID                (0x80)

/* Bit definitions and macros for MCF_USB_OTG_CTRL */
#define MCF_USB_OTG_CTRL_VBUS_DSCHG          (0x01)
#define MCF_USB_OTG_CTRL_VBUS_CHG            (0x02)
#define MCF_USB_OTG_CTRL_OTG_EN              (0x04)
#define MCF_USB_OTG_CTRL_VBUS_ON             (0x08)
#define MCF_USB_OTG_CTRL_DM_LOW              (0x10)
#define MCF_USB_OTG_CTRL_DP_LOW              (0x20)
#define MCF_USB_OTG_CTRL_DM_HIGH             (0x40)
#define MCF_USB_OTG_CTRL_DP_HIGH             (0x80)

/* Bit definitions and macros for MCF_USB_INT_STAT */
#define MCF_USB_INT_STAT_USB_RST             (0x01)
#define MCF_USB_INT_STAT_ERROR               (0x02)
#define MCF_USB_INT_STAT_SOF_TOK             (0x04)
#define MCF_USB_INT_STAT_TOK_DNE             (0x08)
#define MCF_USB_INT_STAT_SLEEP               (0x10)
#define MCF_USB_INT_STAT_RESUME              (0x20)
#define MCF_USB_INT_STAT_ATTACH              (0x40)
#define MCF_USB_INT_STAT_STALL               (0x80)

/* Bit definitions and macros for MCF_USB_INT_ENB */
#define MCF_USB_INT_ENB_USB_RST              (0x01)
#define MCF_USB_INT_ENB_ERROR                (0x02)
#define MCF_USB_INT_ENB_SOF_TOK              (0x04)
#define MCF_USB_INT_ENB_TOK_DNE              (0x08)
#define MCF_USB_INT_ENB_SLEEP                (0x10)
#define MCF_USB_INT_ENB_RESUME               (0x20)
#define MCF_USB_INT_ENB_ATTACH               (0x40)
#define MCF_USB_INT_ENB_STALL                (0x80)

/* Bit definitions and macros for MCF_USB_ERR_STAT */
#define MCF_USB_ERR_STAT_PID_ERR             (0x01)
#define MCF_USB_ERR_STAT_CRC5_EOF            (0x02)
#define MCF_USB_ERR_STAT_CRC16               (0x04)
#define MCF_USB_ERR_STAT_DFN8                (0x08)
#define MCF_USB_ERR_STAT_BTO_ERR             (0x10)
#define MCF_USB_ERR_STAT_DMA_ERR             (0x20)
#define MCF_USB_ERR_STAT_BTS_ERR             (0x80)

/* Bit definitions and macros for MCF_USB_ERR_ENB */
#define MCF_USB_ERR_ENB_PID_ERR              (0x01)
#define MCF_USB_ERR_ENB_CRC5_EOF             (0x02)
#define MCF_USB_ERR_ENB_CRC16                (0x04)
#define MCF_USB_ERR_ENB_DFN8                 (0x08)
#define MCF_USB_ERR_ENB_BTO_ERR              (0x10)
#define MCF_USB_ERR_ENB_DMA_ERR              (0x20)
#define MCF_USB_ERR_ENB_BTS_ERR              (0x80)

/* Bit definitions and macros for MCF_USB_STAT */
#define MCF_USB_STAT_ODD                     (0x04)
#define MCF_USB_STAT_TX                      (0x08)
#define MCF_USB_STAT_ENDP(x)                 (((x)&0x0F)<<4)

/* Bit definitions and macros for MCF_USB_CTL */
#define MCF_USB_CTL_USB_EN_SOF_EN            (0x01)
#define MCF_USB_CTL_ODD_RST                  (0x02)
#define MCF_USB_CTL_RESUME                   (0x04)
#define MCF_USB_CTL_HOST_MODE_EN             (0x08)
#define MCF_USB_CTL_RESET                    (0x10)
#define MCF_USB_CTL_TXDSUSPEND_TOKBUSY       (0x20)
#define MCF_USB_CTL_SE0                      (0x40)
#define MCF_USB_CTL_JSTATE                   (0x80)

/* Bit definitions and macros for MCF_USB_ADDR */
#define MCF_USB_ADDR_ADDR(x)                 (((x)&0x7F)<<0)
#define MCF_USB_ADDR_LS_EN                   (0x80)

/* Bit definitions and macros for MCF_USB_BDT_PAGE_01 */
#define MCF_USB_BDT_PAGE_01_BDT_BA9          (0x02)
#define MCF_USB_BDT_PAGE_01_BDT_BA10         (0x04)
#define MCF_USB_BDT_PAGE_01_BDT_BA11         (0x08)
#define MCF_USB_BDT_PAGE_01_BDT_BA12         (0x10)
#define MCF_USB_BDT_PAGE_01_BDT_BA13         (0x20)
#define MCF_USB_BDT_PAGE_01_BDT_BA14         (0x40)
#define MCF_USB_BDT_PAGE_01_BDT_BA15         (0x80)

/* Bit definitions and macros for MCF_USB_FRM_NUM */
#define MCF_USB_FRM_NUM_FRM(x)               (((x)&0xFFFF)<<0)

/* Bit definitions and macros for MCF_USB_FRM_NUML */
#define MCF_USB_FRM_NUML_FRM0                (0x01)
#define MCF_USB_FRM_NUML_FRM1                (0x02)
#define MCF_USB_FRM_NUML_FRM2                (0x04)
#define MCF_USB_FRM_NUML_FRM3                (0x08)
#define MCF_USB_FRM_NUML_FRM4                (0x10)
#define MCF_USB_FRM_NUML_FRM5                (0x20)
#define MCF_USB_FRM_NUML_FRM6                (0x40)
#define MCF_USB_FRM_NUML_FRM7                (0x80)

/* Bit definitions and macros for MCF_USB_FRM_NUMH */
#define MCF_USB_FRM_NUMH_FRM8                (0x01)
#define MCF_USB_FRM_NUMH_FRM9                (0x02)
#define MCF_USB_FRM_NUMH_FRM10               (0x04)
#define MCF_USB_FRM_NUMH_FRM11               (0x08)
#define MCF_USB_FRM_NUMH_FRM12               (0x10)
#define MCF_USB_FRM_NUMH_FRM13               (0x20)
#define MCF_USB_FRM_NUMH_FRM14               (0x40)
#define MCF_USB_FRM_NUMH_FRM15               (0x80)

/* Bit definitions and macros for MCF_USB_TOKEN */
#define MCF_USB_TOKEN_TOKEN_ENDPT(x)         (((x)&0x0F)<<0)
#define MCF_USB_TOKEN_TOKEN_PID(x)           (((x)&0x0F)<<4)

/* Bit definitions and macros for MCF_USB_SOF_THLDL */
#define MCF_USB_SOF_THLDL_CNT(x)             (((x)&0xFF)<<0)

/* Bit definitions and macros for MCF_USB_BDT_PAGE_02 */
#define MCF_USB_BDT_PAGE_02_BDT_BA16         (0x01)
#define MCF_USB_BDT_PAGE_02_BDT_BA17         (0x02)
#define MCF_USB_BDT_PAGE_02_BDT_BA18         (0x04)
#define MCF_USB_BDT_PAGE_02_BDT_BA19         (0x08)
#define MCF_USB_BDT_PAGE_02_BDT_BA20         (0x10)
#define MCF_USB_BDT_PAGE_02_BDT_BA21         (0x20)
#define MCF_USB_BDT_PAGE_02_BDT_BA22         (0x40)
#define MCF_USB_BDT_PAGE_02_BDT_BA23         (0x80)

/* Bit definitions and macros for MCF_USB_BDT_PAGE_03 */
#define MCF_USB_BDT_PAGE_03_BDT_BA24         (0x01)
#define MCF_USB_BDT_PAGE_03_BDT_BA25         (0x02)
#define MCF_USB_BDT_PAGE_03_BDT_BA26         (0x04)
#define MCF_USB_BDT_PAGE_03_BDT_BA27         (0x08)
#define MCF_USB_BDT_PAGE_03_BDT_BA28         (0x10)
#define MCF_USB_BDT_PAGE_03_BDT_BA29         (0x20)
#define MCF_USB_BDT_PAGE_03_BDT_BA30         (0x40)
#define MCF_USB_BDT_PAGE_03_BDT_BA31         (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT0 */
#define MCF_USB_ENDPT0_EP_HSHK               (0x01)
#define MCF_USB_ENDPT0_EP_STALL              (0x02)
#define MCF_USB_ENDPT0_EP_EN_TX              (0x04)
#define MCF_USB_ENDPT0_EP_EN_RX              (0x08)
#define MCF_USB_ENDPT0_EP_CTL_DIS            (0x10)
#define MCF_USB_ENDPT0_RETRY_DIS             (0x40)
#define MCF_USB_ENDPT0_HOST_WO_HUB           (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT1 */
#define MCF_USB_ENDPT1_EP_HSHK               (0x01)
#define MCF_USB_ENDPT1_EP_STALL              (0x02)
#define MCF_USB_ENDPT1_EP_EN_TX              (0x04)
#define MCF_USB_ENDPT1_EP_EN_RX              (0x08)
#define MCF_USB_ENDPT1_EP_CTL_DIS            (0x10)
#define MCF_USB_ENDPT1_RETRY_DIS             (0x40)
#define MCF_USB_ENDPT1_HOST_WO_HUB           (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT2 */
#define MCF_USB_ENDPT2_EP_HSHK               (0x01)
#define MCF_USB_ENDPT2_EP_STALL              (0x02)
#define MCF_USB_ENDPT2_EP_EN_TX              (0x04)
#define MCF_USB_ENDPT2_EP_EN_RX              (0x08)
#define MCF_USB_ENDPT2_EP_CTL_DIS            (0x10)
#define MCF_USB_ENDPT2_RETRY_DIS             (0x40)
#define MCF_USB_ENDPT2_HOST_WO_HUB           (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT3 */
#define MCF_USB_ENDPT3_EP_HSHK               (0x01)
#define MCF_USB_ENDPT3_EP_STALL              (0x02)
#define MCF_USB_ENDPT3_EP_EN_TX              (0x04)
#define MCF_USB_ENDPT3_EP_EN_RX              (0x08)
#define MCF_USB_ENDPT3_EP_CTL_DIS            (0x10)
#define MCF_USB_ENDPT3_RETRY_DIS             (0x40)
#define MCF_USB_ENDPT3_HOST_WO_HUB           (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT4 */
#define MCF_USB_ENDPT4_EP_HSHK               (0x01)
#define MCF_USB_ENDPT4_EP_STALL              (0x02)
#define MCF_USB_ENDPT4_EP_EN_TX              (0x04)
#define MCF_USB_ENDPT4_EP_EN_RX              (0x08)
#define MCF_USB_ENDPT4_EP_CTL_DIS            (0x10)
#define MCF_USB_ENDPT4_RETRY_DIS             (0x40)
#define MCF_USB_ENDPT4_HOST_WO_HUB           (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT5 */
#define MCF_USB_ENDPT5_EP_HSHK               (0x01)
#define MCF_USB_ENDPT5_EP_STALL              (0x02)
#define MCF_USB_ENDPT5_EP_EN_TX              (0x04)
#define MCF_USB_ENDPT5_EP_EN_RX              (0x08)
#define MCF_USB_ENDPT5_EP_CTL_DIS            (0x10)
#define MCF_USB_ENDPT5_RETRY_DIS             (0x40)
#define MCF_USB_ENDPT5_HOST_WO_HUB           (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT6 */
#define MCF_USB_ENDPT6_EP_HSHK               (0x01)
#define MCF_USB_ENDPT6_EP_STALL              (0x02)
#define MCF_USB_ENDPT6_EP_EN_TX              (0x04)
#define MCF_USB_ENDPT6_EP_EN_RX              (0x08)
#define MCF_USB_ENDPT6_EP_CTL_DIS            (0x10)
#define MCF_USB_ENDPT6_RETRY_DIS             (0x40)
#define MCF_USB_ENDPT6_HOST_WO_HUB           (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT7 */
#define MCF_USB_ENDPT7_EP_HSHK               (0x01)
#define MCF_USB_ENDPT7_EP_STALL              (0x02)
#define MCF_USB_ENDPT7_EP_EN_TX              (0x04)
#define MCF_USB_ENDPT7_EP_EN_RX              (0x08)
#define MCF_USB_ENDPT7_EP_CTL_DIS            (0x10)
#define MCF_USB_ENDPT7_RETRY_DIS             (0x40)
#define MCF_USB_ENDPT7_HOST_WO_HUB           (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT8 */
#define MCF_USB_ENDPT8_EP_HSHK               (0x01)
#define MCF_USB_ENDPT8_EP_STALL              (0x02)
#define MCF_USB_ENDPT8_EP_EN_TX              (0x04)
#define MCF_USB_ENDPT8_EP_EN_RX              (0x08)
#define MCF_USB_ENDPT8_EP_CTL_DIS            (0x10)
#define MCF_USB_ENDPT8_RETRY_DIS             (0x40)
#define MCF_USB_ENDPT8_HOST_WO_HUB           (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT9 */
#define MCF_USB_ENDPT9_EP_HSHK               (0x01)
#define MCF_USB_ENDPT9_EP_STALL              (0x02)
#define MCF_USB_ENDPT9_EP_EN_TX              (0x04)
#define MCF_USB_ENDPT9_EP_EN_RX              (0x08)
#define MCF_USB_ENDPT9_EP_CTL_DIS            (0x10)
#define MCF_USB_ENDPT9_RETRY_DIS             (0x40)
#define MCF_USB_ENDPT9_HOST_WO_HUB           (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT10 */
#define MCF_USB_ENDPT10_EP_HSHK              (0x01)
#define MCF_USB_ENDPT10_EP_STALL             (0x02)
#define MCF_USB_ENDPT10_EP_EN_TX             (0x04)
#define MCF_USB_ENDPT10_EP_EN_RX             (0x08)
#define MCF_USB_ENDPT10_EP_CTL_DIS           (0x10)
#define MCF_USB_ENDPT10_RETRY_DIS            (0x40)
#define MCF_USB_ENDPT10_HOST_WO_HUB          (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT11 */
#define MCF_USB_ENDPT11_EP_HSHK              (0x01)
#define MCF_USB_ENDPT11_EP_STALL             (0x02)
#define MCF_USB_ENDPT11_EP_EN_TX             (0x04)
#define MCF_USB_ENDPT11_EP_EN_RX             (0x08)
#define MCF_USB_ENDPT11_EP_CTL_DIS           (0x10)
#define MCF_USB_ENDPT11_RETRY_DIS            (0x40)
#define MCF_USB_ENDPT11_HOST_WO_HUB          (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT12 */
#define MCF_USB_ENDPT12_EP_HSHK              (0x01)
#define MCF_USB_ENDPT12_EP_STALL             (0x02)
#define MCF_USB_ENDPT12_EP_EN_TX             (0x04)
#define MCF_USB_ENDPT12_EP_EN_RX             (0x08)
#define MCF_USB_ENDPT12_EP_CTL_DIS           (0x10)
#define MCF_USB_ENDPT12_RETRY_DIS            (0x40)
#define MCF_USB_ENDPT12_HOST_WO_HUB          (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT13 */
#define MCF_USB_ENDPT13_EP_HSHK              (0x01)
#define MCF_USB_ENDPT13_EP_STALL             (0x02)
#define MCF_USB_ENDPT13_EP_EN_TX             (0x04)
#define MCF_USB_ENDPT13_EP_EN_RX             (0x08)
#define MCF_USB_ENDPT13_EP_CTL_DIS           (0x10)
#define MCF_USB_ENDPT13_RETRY_DIS            (0x40)
#define MCF_USB_ENDPT13_HOST_WO_HUB          (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT14 */
#define MCF_USB_ENDPT14_EP_HSHK              (0x01)
#define MCF_USB_ENDPT14_EP_STALL             (0x02)
#define MCF_USB_ENDPT14_EP_EN_TX             (0x04)
#define MCF_USB_ENDPT14_EP_EN_RX             (0x08)
#define MCF_USB_ENDPT14_EP_CTL_DIS           (0x10)
#define MCF_USB_ENDPT14_RETRY_DIS            (0x40)
#define MCF_USB_ENDPT14_HOST_WO_HUB          (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT15 */
#define MCF_USB_ENDPT15_EP_HSHK              (0x01)
#define MCF_USB_ENDPT15_EP_STALL             (0x02)
#define MCF_USB_ENDPT15_EP_EN_TX             (0x04)
#define MCF_USB_ENDPT15_EP_EN_RX             (0x08)
#define MCF_USB_ENDPT15_EP_CTL_DIS           (0x10)
#define MCF_USB_ENDPT15_RETRY_DIS            (0x40)
#define MCF_USB_ENDPT15_HOST_WO_HUB          (0x80)

/* Bit definitions and macros for MCF_USB_USB_CTRL */
#define MCF_USB_USB_CTRL_SUSP                (1<<7)
#define MCF_USB_USB_CTRL_PDE                 (1<<6)
#define MCF_USB_USB_CTRL_CLKSRC_ALT          (0<<0)
#define MCF_USB_USB_CTRL_CLKSRC_OSC          (1<<0)
#define MCF_USB_USB_CTRL_CLKSRC_SYS          (3<<0)

/*********************************************************************
*
* Queued Serial Peripheral Interface (QSPI)
*
*********************************************************************/

/* Register read/write macros */
#define MCF_QSPI_QMR           (*(hcc_reg16*)(&_IPSBAR[0x000340]))
#define MCF_QSPI_QDLYR         (*(hcc_reg16*)(&_IPSBAR[0x000344]))
#define MCF_QSPI_QWR           (*(hcc_reg16*)(&_IPSBAR[0x000348]))
#define MCF_QSPI_QIR           (*(hcc_reg16*)(&_IPSBAR[0x00034C]))
#define MCF_QSPI_QAR           (*(hcc_reg16*)(&_IPSBAR[0x000350]))
#define MCF_QSPI_QDR           (*(hcc_reg16*)(&_IPSBAR[0x000354]))

/* Bit definitions and macros for MCF_QSPI_QMR */
#define MCF_QSPI_QMR_BAUD(x)   (((x)&0x00FF)<<0)
#define MCF_QSPI_QMR_CPHA      (0x0100)
#define MCF_QSPI_QMR_CPOL      (0x0200)
#define MCF_QSPI_QMR_BITS(x)   (((x)&0x000F)<<10)
#define MCF_QSPI_QMR_DOHIE     (0x4000)
#define MCF_QSPI_QMR_MSTR      (0x8000)

/* Bit definitions and macros for MCF_QSPI_QDLYR */
#define MCF_QSPI_QDLYR_DTL(x)  (((x)&0x00FF)<<0)
#define MCF_QSPI_QDLYR_QCD(x)  (((x)&0x007F)<<8)
#define MCF_QSPI_QDLYR_SPE     (0x8000)

/* Bit definitions and macros for MCF_QSPI_QWR */
#define MCF_QSPI_QWR_NEWQP(x)  (((x)&0x000F)<<0)
#define MCF_QSPI_QWR_ENDQP(x)  (((x)&0x000F)<<8)
#define MCF_QSPI_QWR_CSIV      (0x1000)
#define MCF_QSPI_QWR_WRTO      (0x2000)
#define MCF_QSPI_QWR_WREN      (0x4000)
#define MCF_QSPI_QWR_HALT      (0x8000)

/* Bit definitions and macros for MCF_QSPI_QIR */
#define MCF_QSPI_QIR_SPIF      (0x0001)
#define MCF_QSPI_QIR_ABRT      (0x0004)
#define MCF_QSPI_QIR_WCEF      (0x0008)
#define MCF_QSPI_QIR_SPIFE     (0x0100)
#define MCF_QSPI_QIR_ABRTE     (0x0400)
#define MCF_QSPI_QIR_WCEFE     (0x0800)
#define MCF_QSPI_QIR_ABRTL     (0x1000)
#define MCF_QSPI_QIR_ABRTB     (0x4000)
#define MCF_QSPI_QIR_WCEFB     (0x8000)

/* Bit definitions and macros for MCF_QSPI_QAR */
#define MCF_QSPI_QAR_ADDR(x)   (((x)&0x003F)<<0)

/* Bit definitions and macros for MCF_QSPI_QDR */
#define MCF_QSPI_QDR_DATA(x)   (((x)&0xFFFF)<<0)

/*********************************************************************
*
* interrupt Controller (INTC)
*
*********************************************************************/

/* Register read/write macros */
#define MCF_INTC0_IPRH             (*(hcc_reg32*)(&_IPSBAR[0x000C00]))
#define MCF_INTC0_IPRL             (*(hcc_reg32*)(&_IPSBAR[0x000C04]))
#define MCF_INTC0_IMRH             (*(hcc_reg32*)(&_IPSBAR[0x000C08]))
#define MCF_INTC0_IMRL             (*(hcc_reg32*)(&_IPSBAR[0x000C0C]))
#define MCF_INTC0_INTFRCH          (*(hcc_reg32*)(&_IPSBAR[0x000C10]))
#define MCF_INTC0_INTFRCL          (*(hcc_reg32*)(&_IPSBAR[0x000C14]))
#define MCF_INTC0_IRLR             (*(hcc_reg8 *)(&_IPSBAR[0x000C18]))
#define MCF_INTC0_IACKLPR          (*(hcc_reg8 *)(&_IPSBAR[0x000C19]))
#define MCF_INTC0_ICR1             (*(hcc_reg8 *)(&_IPSBAR[0x000C41]))
#define MCF_INTC0_ICR2             (*(hcc_reg8 *)(&_IPSBAR[0x000C42]))
#define MCF_INTC0_ICR3             (*(hcc_reg8 *)(&_IPSBAR[0x000C43]))
#define MCF_INTC0_ICR4             (*(hcc_reg8 *)(&_IPSBAR[0x000C44]))
#define MCF_INTC0_ICR5             (*(hcc_reg8 *)(&_IPSBAR[0x000C45]))
#define MCF_INTC0_ICR6             (*(hcc_reg8 *)(&_IPSBAR[0x000C46]))
#define MCF_INTC0_ICR7             (*(hcc_reg8 *)(&_IPSBAR[0x000C47]))
#define MCF_INTC0_ICR8             (*(hcc_reg8 *)(&_IPSBAR[0x000C48]))
#define MCF_INTC0_ICR9             (*(hcc_reg8 *)(&_IPSBAR[0x000C49]))
#define MCF_INTC0_ICR10            (*(hcc_reg8 *)(&_IPSBAR[0x000C4A]))
#define MCF_INTC0_ICR11            (*(hcc_reg8 *)(&_IPSBAR[0x000C4B]))
#define MCF_INTC0_ICR12            (*(hcc_reg8 *)(&_IPSBAR[0x000C4C]))
#define MCF_INTC0_ICR13            (*(hcc_reg8 *)(&_IPSBAR[0x000C4D]))
#define MCF_INTC0_ICR14            (*(hcc_reg8 *)(&_IPSBAR[0x000C4E]))
#define MCF_INTC0_ICR15            (*(hcc_reg8 *)(&_IPSBAR[0x000C4F]))
#define MCF_INTC0_ICR16            (*(hcc_reg8 *)(&_IPSBAR[0x000C50]))
#define MCF_INTC0_ICR17            (*(hcc_reg8 *)(&_IPSBAR[0x000C51]))
#define MCF_INTC0_ICR18            (*(hcc_reg8 *)(&_IPSBAR[0x000C52]))
#define MCF_INTC0_ICR19            (*(hcc_reg8 *)(&_IPSBAR[0x000C53]))
#define MCF_INTC0_ICR20            (*(hcc_reg8 *)(&_IPSBAR[0x000C54]))
#define MCF_INTC0_ICR21            (*(hcc_reg8 *)(&_IPSBAR[0x000C55]))
#define MCF_INTC0_ICR22            (*(hcc_reg8 *)(&_IPSBAR[0x000C56]))
#define MCF_INTC0_ICR23            (*(hcc_reg8 *)(&_IPSBAR[0x000C57]))
#define MCF_INTC0_ICR24            (*(hcc_reg8 *)(&_IPSBAR[0x000C58]))
#define MCF_INTC0_ICR25            (*(hcc_reg8 *)(&_IPSBAR[0x000C59]))
#define MCF_INTC0_ICR26            (*(hcc_reg8 *)(&_IPSBAR[0x000C5A]))
#define MCF_INTC0_ICR27            (*(hcc_reg8 *)(&_IPSBAR[0x000C5B]))
#define MCF_INTC0_ICR28            (*(hcc_reg8 *)(&_IPSBAR[0x000C5C]))
#define MCF_INTC0_ICR29            (*(hcc_reg8 *)(&_IPSBAR[0x000C5D]))
#define MCF_INTC0_ICR30            (*(hcc_reg8 *)(&_IPSBAR[0x000C5E]))
#define MCF_INTC0_ICR31            (*(hcc_reg8 *)(&_IPSBAR[0x000C5F]))
#define MCF_INTC0_ICR32            (*(hcc_reg8 *)(&_IPSBAR[0x000C60]))
#define MCF_INTC0_ICR33            (*(hcc_reg8 *)(&_IPSBAR[0x000C61]))
#define MCF_INTC0_ICR34            (*(hcc_reg8 *)(&_IPSBAR[0x000C62]))
#define MCF_INTC0_ICR35            (*(hcc_reg8 *)(&_IPSBAR[0x000C63]))
#define MCF_INTC0_ICR36            (*(hcc_reg8 *)(&_IPSBAR[0x000C64]))
#define MCF_INTC0_ICR37            (*(hcc_reg8 *)(&_IPSBAR[0x000C65]))
#define MCF_INTC0_ICR38            (*(hcc_reg8 *)(&_IPSBAR[0x000C66]))
#define MCF_INTC0_ICR39            (*(hcc_reg8 *)(&_IPSBAR[0x000C67]))
#define MCF_INTC0_ICR40            (*(hcc_reg8 *)(&_IPSBAR[0x000C68]))
#define MCF_INTC0_ICR41            (*(hcc_reg8 *)(&_IPSBAR[0x000C69]))
#define MCF_INTC0_ICR42            (*(hcc_reg8 *)(&_IPSBAR[0x000C6A]))
#define MCF_INTC0_ICR43            (*(hcc_reg8 *)(&_IPSBAR[0x000C6B]))
#define MCF_INTC0_ICR44            (*(hcc_reg8 *)(&_IPSBAR[0x000C6C]))
#define MCF_INTC0_ICR45            (*(hcc_reg8 *)(&_IPSBAR[0x000C6D]))
#define MCF_INTC0_ICR46            (*(hcc_reg8 *)(&_IPSBAR[0x000C6E]))
#define MCF_INTC0_ICR47            (*(hcc_reg8 *)(&_IPSBAR[0x000C6F]))
#define MCF_INTC0_ICR48            (*(hcc_reg8 *)(&_IPSBAR[0x000C70]))
#define MCF_INTC0_ICR49            (*(hcc_reg8 *)(&_IPSBAR[0x000C71]))
#define MCF_INTC0_ICR50            (*(hcc_reg8 *)(&_IPSBAR[0x000C72]))
#define MCF_INTC0_ICR51            (*(hcc_reg8 *)(&_IPSBAR[0x000C73]))
#define MCF_INTC0_ICR52            (*(hcc_reg8 *)(&_IPSBAR[0x000C74]))
#define MCF_INTC0_ICR53            (*(hcc_reg8 *)(&_IPSBAR[0x000C75]))
#define MCF_INTC0_ICR54            (*(hcc_reg8 *)(&_IPSBAR[0x000C76]))
#define MCF_INTC0_ICR55            (*(hcc_reg8 *)(&_IPSBAR[0x000C77]))
#define MCF_INTC0_ICR56            (*(hcc_reg8 *)(&_IPSBAR[0x000C78]))
#define MCF_INTC0_ICR57            (*(hcc_reg8 *)(&_IPSBAR[0x000C79]))
#define MCF_INTC0_ICR58            (*(hcc_reg8 *)(&_IPSBAR[0x000C7A]))
#define MCF_INTC0_ICR59            (*(hcc_reg8 *)(&_IPSBAR[0x000C7B]))
#define MCF_INTC0_ICR60            (*(hcc_reg8 *)(&_IPSBAR[0x000C7C]))
#define MCF_INTC0_ICR61            (*(hcc_reg8 *)(&_IPSBAR[0x000C7D]))
#define MCF_INTC0_ICR62            (*(hcc_reg8 *)(&_IPSBAR[0x000C7E]))
#define MCF_INTC0_ICR63            (*(hcc_reg8 *)(&_IPSBAR[0x000C7F]))
#define MCF_INTC0_ICR(x)           (*(hcc_reg8 *)(&_IPSBAR[0x000C41+((x-1)*0x001)]))
#define MCF_INTC0_SWIACK           (*(hcc_reg8 *)(&_IPSBAR[0x000CE0]))
#define MCF_INTC0_L1IACK           (*(hcc_reg8 *)(&_IPSBAR[0x000CE4]))
#define MCF_INTC0_L2IACK           (*(hcc_reg8 *)(&_IPSBAR[0x000CE8]))
#define MCF_INTC0_L3IACK           (*(hcc_reg8 *)(&_IPSBAR[0x000CEC]))
#define MCF_INTC0_L4IACK           (*(hcc_reg8 *)(&_IPSBAR[0x000CF0]))
#define MCF_INTC0_L5IACK           (*(hcc_reg8 *)(&_IPSBAR[0x000CF4]))
#define MCF_INTC0_L6IACK           (*(hcc_reg8 *)(&_IPSBAR[0x000CF8]))
#define MCF_INTC0_L7IACK           (*(hcc_reg8 *)(&_IPSBAR[0x000CFC]))
#define MCF_INTC0_LIACK(x)         (*(hcc_reg8 *)(&_IPSBAR[0x000CE4+((x-1)*0x004)]))
#define MCF_INTC1_IPRH             (*(hcc_reg32*)(&_IPSBAR[0x000D00]))
#define MCF_INTC1_IPRL             (*(hcc_reg32*)(&_IPSBAR[0x000D04]))
#define MCF_INTC1_IMRH             (*(hcc_reg32*)(&_IPSBAR[0x000D08]))
#define MCF_INTC1_IMRL             (*(hcc_reg32*)(&_IPSBAR[0x000D0C]))
#define MCF_INTC1_INTFRCH          (*(hcc_reg32*)(&_IPSBAR[0x000D10]))
#define MCF_INTC1_INTFRCL          (*(hcc_reg32*)(&_IPSBAR[0x000D14]))
#define MCF_INTC1_IRLR             (*(hcc_reg8 *)(&_IPSBAR[0x000D18]))
#define MCF_INTC1_IACKLPR          (*(hcc_reg8 *)(&_IPSBAR[0x000D19]))
#define MCF_INTC1_ICR1             (*(hcc_reg8 *)(&_IPSBAR[0x000D41]))
#define MCF_INTC1_ICR2             (*(hcc_reg8 *)(&_IPSBAR[0x000D42]))
#define MCF_INTC1_ICR3             (*(hcc_reg8 *)(&_IPSBAR[0x000D43]))
#define MCF_INTC1_ICR4             (*(hcc_reg8 *)(&_IPSBAR[0x000D44]))
#define MCF_INTC1_ICR5             (*(hcc_reg8 *)(&_IPSBAR[0x000D45]))
#define MCF_INTC1_ICR6             (*(hcc_reg8 *)(&_IPSBAR[0x000D46]))
#define MCF_INTC1_ICR7             (*(hcc_reg8 *)(&_IPSBAR[0x000D47]))
#define MCF_INTC1_ICR8             (*(hcc_reg8 *)(&_IPSBAR[0x000D48]))
#define MCF_INTC1_ICR9             (*(hcc_reg8 *)(&_IPSBAR[0x000D49]))
#define MCF_INTC1_ICR10            (*(hcc_reg8 *)(&_IPSBAR[0x000D4A]))
#define MCF_INTC1_ICR11            (*(hcc_reg8 *)(&_IPSBAR[0x000D4B]))
#define MCF_INTC1_ICR12            (*(hcc_reg8 *)(&_IPSBAR[0x000D4C]))
#define MCF_INTC1_ICR13            (*(hcc_reg8 *)(&_IPSBAR[0x000D4D]))
#define MCF_INTC1_ICR14            (*(hcc_reg8 *)(&_IPSBAR[0x000D4E]))
#define MCF_INTC1_ICR15            (*(hcc_reg8 *)(&_IPSBAR[0x000D4F]))
#define MCF_INTC1_ICR16            (*(hcc_reg8 *)(&_IPSBAR[0x000D50]))
#define MCF_INTC1_ICR17            (*(hcc_reg8 *)(&_IPSBAR[0x000D51]))
#define MCF_INTC1_ICR18            (*(hcc_reg8 *)(&_IPSBAR[0x000D52]))
#define MCF_INTC1_ICR19            (*(hcc_reg8 *)(&_IPSBAR[0x000D53]))
#define MCF_INTC1_ICR20            (*(hcc_reg8 *)(&_IPSBAR[0x000D54]))
#define MCF_INTC1_ICR21            (*(hcc_reg8 *)(&_IPSBAR[0x000D55]))
#define MCF_INTC1_ICR22            (*(hcc_reg8 *)(&_IPSBAR[0x000D56]))
#define MCF_INTC1_ICR23            (*(hcc_reg8 *)(&_IPSBAR[0x000D57]))
#define MCF_INTC1_ICR24            (*(hcc_reg8 *)(&_IPSBAR[0x000D58]))
#define MCF_INTC1_ICR25            (*(hcc_reg8 *)(&_IPSBAR[0x000D59]))
#define MCF_INTC1_ICR26            (*(hcc_reg8 *)(&_IPSBAR[0x000D5A]))
#define MCF_INTC1_ICR27            (*(hcc_reg8 *)(&_IPSBAR[0x000D5B]))
#define MCF_INTC1_ICR28            (*(hcc_reg8 *)(&_IPSBAR[0x000D5C]))
#define MCF_INTC1_ICR29            (*(hcc_reg8 *)(&_IPSBAR[0x000D5D]))
#define MCF_INTC1_ICR30            (*(hcc_reg8 *)(&_IPSBAR[0x000D5E]))
#define MCF_INTC1_ICR31            (*(hcc_reg8 *)(&_IPSBAR[0x000D5F]))
#define MCF_INTC1_ICR32            (*(hcc_reg8 *)(&_IPSBAR[0x000D60]))
#define MCF_INTC1_ICR33            (*(hcc_reg8 *)(&_IPSBAR[0x000D61]))
#define MCF_INTC1_ICR34            (*(hcc_reg8 *)(&_IPSBAR[0x000D62]))
#define MCF_INTC1_ICR35            (*(hcc_reg8 *)(&_IPSBAR[0x000D63]))
#define MCF_INTC1_ICR36            (*(hcc_reg8 *)(&_IPSBAR[0x000D64]))
#define MCF_INTC1_ICR37            (*(hcc_reg8 *)(&_IPSBAR[0x000D65]))
#define MCF_INTC1_ICR38            (*(hcc_reg8 *)(&_IPSBAR[0x000D66]))
#define MCF_INTC1_ICR39            (*(hcc_reg8 *)(&_IPSBAR[0x000D67]))
#define MCF_INTC1_ICR40            (*(hcc_reg8 *)(&_IPSBAR[0x000D68]))
#define MCF_INTC1_ICR41            (*(hcc_reg8 *)(&_IPSBAR[0x000D69]))
#define MCF_INTC1_ICR42            (*(hcc_reg8 *)(&_IPSBAR[0x000D6A]))
#define MCF_INTC1_ICR43            (*(hcc_reg8 *)(&_IPSBAR[0x000D6B]))
#define MCF_INTC1_ICR44            (*(hcc_reg8 *)(&_IPSBAR[0x000D6C]))
#define MCF_INTC1_ICR45            (*(hcc_reg8 *)(&_IPSBAR[0x000D6D]))
#define MCF_INTC1_ICR46            (*(hcc_reg8 *)(&_IPSBAR[0x000D6E]))
#define MCF_INTC1_ICR47            (*(hcc_reg8 *)(&_IPSBAR[0x000D6F]))
#define MCF_INTC1_ICR48            (*(hcc_reg8 *)(&_IPSBAR[0x000D70]))
#define MCF_INTC1_ICR49            (*(hcc_reg8 *)(&_IPSBAR[0x000D71]))
#define MCF_INTC1_ICR50            (*(hcc_reg8 *)(&_IPSBAR[0x000D72]))
#define MCF_INTC1_ICR51            (*(hcc_reg8 *)(&_IPSBAR[0x000D73]))
#define MCF_INTC1_ICR52            (*(hcc_reg8 *)(&_IPSBAR[0x000D74]))
#define MCF_INTC1_ICR53            (*(hcc_reg8 *)(&_IPSBAR[0x000D75]))
#define MCF_INTC1_ICR54            (*(hcc_reg8 *)(&_IPSBAR[0x000D76]))
#define MCF_INTC1_ICR55            (*(hcc_reg8 *)(&_IPSBAR[0x000D77]))
#define MCF_INTC1_ICR56            (*(hcc_reg8 *)(&_IPSBAR[0x000D78]))
#define MCF_INTC1_ICR57            (*(hcc_reg8 *)(&_IPSBAR[0x000D79]))
#define MCF_INTC1_ICR58            (*(hcc_reg8 *)(&_IPSBAR[0x000D7A]))
#define MCF_INTC1_ICR59            (*(hcc_reg8 *)(&_IPSBAR[0x000D7B]))
#define MCF_INTC1_ICR60            (*(hcc_reg8 *)(&_IPSBAR[0x000D7C]))
#define MCF_INTC1_ICR61            (*(hcc_reg8 *)(&_IPSBAR[0x000D7D]))
#define MCF_INTC1_ICR62            (*(hcc_reg8 *)(&_IPSBAR[0x000D7E]))
#define MCF_INTC1_ICR63            (*(hcc_reg8 *)(&_IPSBAR[0x000D7F]))
#define MCF_INTC1_ICR(x)           (*(hcc_reg8 *)(&_IPSBAR[0x000D41+((x-1)*0x001)]))
#define MCF_INTC1_SWIACK           (*(hcc_reg8 *)(&_IPSBAR[0x000DE0]))
#define MCF_INTC1_L1IACK           (*(hcc_reg8 *)(&_IPSBAR[0x000DE4]))
#define MCF_INTC1_L2IACK           (*(hcc_reg8 *)(&_IPSBAR[0x000DE8]))
#define MCF_INTC1_L3IACK           (*(hcc_reg8 *)(&_IPSBAR[0x000DEC]))
#define MCF_INTC1_L4IACK           (*(hcc_reg8 *)(&_IPSBAR[0x000DF0]))
#define MCF_INTC1_L5IACK           (*(hcc_reg8 *)(&_IPSBAR[0x000DF4]))
#define MCF_INTC1_L6IACK           (*(hcc_reg8 *)(&_IPSBAR[0x000DF8]))
#define MCF_INTC1_L7IACK           (*(hcc_reg8 *)(&_IPSBAR[0x000DFC]))
#define MCF_INTC1_LIACK(x)         (*(hcc_reg8 *)(&_IPSBAR[0x000DE4+((x-1)*0x004)]))
#define MCF_INTC_IPRH(x)           (*(hcc_reg32*)(&_IPSBAR[0x000C00+((x)*0x100)]))
#define MCF_INTC_IPRL(x)           (*(hcc_reg32*)(&_IPSBAR[0x000C04+((x)*0x100)]))
#define MCF_INTC_IMRH(x)           (*(hcc_reg32*)(&_IPSBAR[0x000C08+((x)*0x100)]))
#define MCF_INTC_IMRL(x)           (*(hcc_reg32*)(&_IPSBAR[0x000C0C+((x)*0x100)]))
#define MCF_INTC_INTFRCH(x)        (*(hcc_reg32*)(&_IPSBAR[0x000C10+((x)*0x100)]))
#define MCF_INTC_INTFRCL(x)        (*(hcc_reg32*)(&_IPSBAR[0x000C14+((x)*0x100)]))
#define MCF_INTC_IRLR(x)           (*(hcc_reg8 *)(&_IPSBAR[0x000C18+((x)*0x100)]))
#define MCF_INTC_IACKLPR(x)        (*(hcc_reg8 *)(&_IPSBAR[0x000C19+((x)*0x100)]))
#define MCF_INTC_ICR1(x)           (*(hcc_reg8 *)(&_IPSBAR[0x000C41+((x)*0x100)]))
#define MCF_INTC_ICR2(x)           (*(hcc_reg8 *)(&_IPSBAR[0x000C42+((x)*0x100)]))
#define MCF_INTC_ICR3(x)           (*(hcc_reg8 *)(&_IPSBAR[0x000C43+((x)*0x100)]))
#define MCF_INTC_ICR4(x)           (*(hcc_reg8 *)(&_IPSBAR[0x000C44+((x)*0x100)]))
#define MCF_INTC_ICR5(x)           (*(hcc_reg8 *)(&_IPSBAR[0x000C45+((x)*0x100)]))
#define MCF_INTC_ICR6(x)           (*(hcc_reg8 *)(&_IPSBAR[0x000C46+((x)*0x100)]))
#define MCF_INTC_ICR7(x)           (*(hcc_reg8 *)(&_IPSBAR[0x000C47+((x)*0x100)]))
#define MCF_INTC_ICR8(x)           (*(hcc_reg8 *)(&_IPSBAR[0x000C48+((x)*0x100)]))
#define MCF_INTC_ICR9(x)           (*(hcc_reg8 *)(&_IPSBAR[0x000C49+((x)*0x100)]))
#define MCF_INTC_ICR10(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C4A+((x)*0x100)]))
#define MCF_INTC_ICR11(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C4B+((x)*0x100)]))
#define MCF_INTC_ICR12(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C4C+((x)*0x100)]))
#define MCF_INTC_ICR13(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C4D+((x)*0x100)]))
#define MCF_INTC_ICR14(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C4E+((x)*0x100)]))
#define MCF_INTC_ICR15(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C4F+((x)*0x100)]))
#define MCF_INTC_ICR16(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C50+((x)*0x100)]))
#define MCF_INTC_ICR17(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C51+((x)*0x100)]))
#define MCF_INTC_ICR18(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C52+((x)*0x100)]))
#define MCF_INTC_ICR19(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C53+((x)*0x100)]))
#define MCF_INTC_ICR20(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C54+((x)*0x100)]))
#define MCF_INTC_ICR21(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C55+((x)*0x100)]))
#define MCF_INTC_ICR22(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C56+((x)*0x100)]))
#define MCF_INTC_ICR23(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C57+((x)*0x100)]))
#define MCF_INTC_ICR24(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C58+((x)*0x100)]))
#define MCF_INTC_ICR25(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C59+((x)*0x100)]))
#define MCF_INTC_ICR26(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C5A+((x)*0x100)]))
#define MCF_INTC_ICR27(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C5B+((x)*0x100)]))
#define MCF_INTC_ICR28(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C5C+((x)*0x100)]))
#define MCF_INTC_ICR29(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C5D+((x)*0x100)]))
#define MCF_INTC_ICR30(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C5E+((x)*0x100)]))
#define MCF_INTC_ICR31(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C5F+((x)*0x100)]))
#define MCF_INTC_ICR32(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C60+((x)*0x100)]))
#define MCF_INTC_ICR33(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C61+((x)*0x100)]))
#define MCF_INTC_ICR34(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C62+((x)*0x100)]))
#define MCF_INTC_ICR35(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C63+((x)*0x100)]))
#define MCF_INTC_ICR36(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C64+((x)*0x100)]))
#define MCF_INTC_ICR37(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C65+((x)*0x100)]))
#define MCF_INTC_ICR38(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C66+((x)*0x100)]))
#define MCF_INTC_ICR39(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C67+((x)*0x100)]))
#define MCF_INTC_ICR40(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C68+((x)*0x100)]))
#define MCF_INTC_ICR41(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C69+((x)*0x100)]))
#define MCF_INTC_ICR42(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C6A+((x)*0x100)]))
#define MCF_INTC_ICR43(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C6B+((x)*0x100)]))
#define MCF_INTC_ICR44(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C6C+((x)*0x100)]))
#define MCF_INTC_ICR45(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C6D+((x)*0x100)]))
#define MCF_INTC_ICR46(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C6E+((x)*0x100)]))
#define MCF_INTC_ICR47(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C6F+((x)*0x100)]))
#define MCF_INTC_ICR48(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C70+((x)*0x100)]))
#define MCF_INTC_ICR49(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C71+((x)*0x100)]))
#define MCF_INTC_ICR50(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C72+((x)*0x100)]))
#define MCF_INTC_ICR51(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C73+((x)*0x100)]))
#define MCF_INTC_ICR52(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C74+((x)*0x100)]))
#define MCF_INTC_ICR53(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C75+((x)*0x100)]))
#define MCF_INTC_ICR54(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C76+((x)*0x100)]))
#define MCF_INTC_ICR55(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C77+((x)*0x100)]))
#define MCF_INTC_ICR56(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C78+((x)*0x100)]))
#define MCF_INTC_ICR57(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C79+((x)*0x100)]))
#define MCF_INTC_ICR58(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C7A+((x)*0x100)]))
#define MCF_INTC_ICR59(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C7B+((x)*0x100)]))
#define MCF_INTC_ICR60(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C7C+((x)*0x100)]))
#define MCF_INTC_ICR61(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C7D+((x)*0x100)]))
#define MCF_INTC_ICR62(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C7E+((x)*0x100)]))
#define MCF_INTC_ICR63(x)          (*(hcc_reg8 *)(&_IPSBAR[0x000C7F+((x)*0x100)]))
#define MCF_INTC_SWIACK(x)         (*(hcc_reg8 *)(&_IPSBAR[0x000CE0+((x)*0x100)]))
#define MCF_INTC_L1IACK(x)         (*(hcc_reg8 *)(&_IPSBAR[0x000CE4+((x)*0x100)]))
#define MCF_INTC_L2IACK(x)         (*(hcc_reg8 *)(&_IPSBAR[0x000CE8+((x)*0x100)]))
#define MCF_INTC_L3IACK(x)         (*(hcc_reg8 *)(&_IPSBAR[0x000CEC+((x)*0x100)]))
#define MCF_INTC_L4IACK(x)         (*(hcc_reg8 *)(&_IPSBAR[0x000CF0+((x)*0x100)]))
#define MCF_INTC_L5IACK(x)         (*(hcc_reg8 *)(&_IPSBAR[0x000CF4+((x)*0x100)]))
#define MCF_INTC_L6IACK(x)         (*(hcc_reg8 *)(&_IPSBAR[0x000CF8+((x)*0x100)]))
#define MCF_INTC_L7IACK(x)         (*(hcc_reg8 *)(&_IPSBAR[0x000CFC+((x)*0x100)]))

/* Bit definitions and macros for MCF_INTC_IPRH */
#define MCF_INTC_IPRH_INT32        (0x00000001)
#define MCF_INTC_IPRH_INT33        (0x00000002)
#define MCF_INTC_IPRH_INT34        (0x00000004)
#define MCF_INTC_IPRH_INT35        (0x00000008)
#define MCF_INTC_IPRH_INT36        (0x00000010)
#define MCF_INTC_IPRH_INT37        (0x00000020)
#define MCF_INTC_IPRH_INT38        (0x00000040)
#define MCF_INTC_IPRH_INT39        (0x00000080)
#define MCF_INTC_IPRH_INT40        (0x00000100)
#define MCF_INTC_IPRH_INT41        (0x00000200)
#define MCF_INTC_IPRH_INT42        (0x00000400)
#define MCF_INTC_IPRH_INT43        (0x00000800)
#define MCF_INTC_IPRH_INT44        (0x00001000)
#define MCF_INTC_IPRH_INT45        (0x00002000)
#define MCF_INTC_IPRH_INT46        (0x00004000)
#define MCF_INTC_IPRH_INT47        (0x00008000)
#define MCF_INTC_IPRH_INT48        (0x00010000)
#define MCF_INTC_IPRH_INT49        (0x00020000)
#define MCF_INTC_IPRH_INT50        (0x00040000)
#define MCF_INTC_IPRH_INT51        (0x00080000)
#define MCF_INTC_IPRH_INT52        (0x00100000)
#define MCF_INTC_IPRH_INT53        (0x00200000)
#define MCF_INTC_IPRH_INT54        (0x00400000)
#define MCF_INTC_IPRH_INT55        (0x00800000)
#define MCF_INTC_IPRH_INT56        (0x01000000)
#define MCF_INTC_IPRH_INT57        (0x02000000)
#define MCF_INTC_IPRH_INT58        (0x04000000)
#define MCF_INTC_IPRH_INT59        (0x08000000)
#define MCF_INTC_IPRH_INT60        (0x10000000)
#define MCF_INTC_IPRH_INT61        (0x20000000)
#define MCF_INTC_IPRH_INT62        (0x40000000)
#define MCF_INTC_IPRH_INT63        (0x80000000)

/* Bit definitions and macros for MCF_INTC_IPRL */
#define MCF_INTC_IPRL_INT1         (0x00000002)
#define MCF_INTC_IPRL_INT2         (0x00000004)
#define MCF_INTC_IPRL_INT3         (0x00000008)
#define MCF_INTC_IPRL_INT4         (0x00000010)
#define MCF_INTC_IPRL_INT5         (0x00000020)
#define MCF_INTC_IPRL_INT6         (0x00000040)
#define MCF_INTC_IPRL_INT7         (0x00000080)
#define MCF_INTC_IPRL_INT8         (0x00000100)
#define MCF_INTC_IPRL_INT9         (0x00000200)
#define MCF_INTC_IPRL_INT10        (0x00000400)
#define MCF_INTC_IPRL_INT11        (0x00000800)
#define MCF_INTC_IPRL_INT12        (0x00001000)
#define MCF_INTC_IPRL_INT13        (0x00002000)
#define MCF_INTC_IPRL_INT14        (0x00004000)
#define MCF_INTC_IPRL_INT15        (0x00008000)
#define MCF_INTC_IPRL_INT16        (0x00010000)
#define MCF_INTC_IPRL_INT17        (0x00020000)
#define MCF_INTC_IPRL_INT18        (0x00040000)
#define MCF_INTC_IPRL_INT19        (0x00080000)
#define MCF_INTC_IPRL_INT20        (0x00100000)
#define MCF_INTC_IPRL_INT21        (0x00200000)
#define MCF_INTC_IPRL_INT22        (0x00400000)
#define MCF_INTC_IPRL_INT23        (0x00800000)
#define MCF_INTC_IPRL_INT24        (0x01000000)
#define MCF_INTC_IPRL_INT25        (0x02000000)
#define MCF_INTC_IPRL_INT26        (0x04000000)
#define MCF_INTC_IPRL_INT27        (0x08000000)
#define MCF_INTC_IPRL_INT28        (0x10000000)
#define MCF_INTC_IPRL_INT29        (0x20000000)
#define MCF_INTC_IPRL_INT30        (0x40000000)
#define MCF_INTC_IPRL_INT31        (0x80000000)

/* Bit definitions and macros for MCF_INTC_IMRH */
#define MCF_INTC_IMRH_MASK32       (0x00000001)
#define MCF_INTC_IMRH_MASK33       (0x00000002)
#define MCF_INTC_IMRH_MASK34       (0x00000004)
#define MCF_INTC_IMRH_MASK35       (0x00000008)
#define MCF_INTC_IMRH_MASK36       (0x00000010)
#define MCF_INTC_IMRH_MASK37       (0x00000020)
#define MCF_INTC_IMRH_MASK38       (0x00000040)
#define MCF_INTC_IMRH_MASK39       (0x00000080)
#define MCF_INTC_IMRH_MASK40       (0x00000100)
#define MCF_INTC_IMRH_MASK41       (0x00000200)
#define MCF_INTC_IMRH_MASK42       (0x00000400)
#define MCF_INTC_IMRH_MASK43       (0x00000800)
#define MCF_INTC_IMRH_MASK44       (0x00001000)
#define MCF_INTC_IMRH_MASK45       (0x00002000)
#define MCF_INTC_IMRH_MASK46       (0x00004000)
#define MCF_INTC_IMRH_MASK47       (0x00008000)
#define MCF_INTC_IMRH_MASK48       (0x00010000)
#define MCF_INTC_IMRH_MASK49       (0x00020000)
#define MCF_INTC_IMRH_MASK50       (0x00040000)
#define MCF_INTC_IMRH_MASK51       (0x00080000)
#define MCF_INTC_IMRH_MASK52       (0x00100000)
#define MCF_INTC_IMRH_MASK53       (0x00200000)
#define MCF_INTC_IMRH_MASK54       (0x00400000)
#define MCF_INTC_IMRH_MASK55       (0x00800000)
#define MCF_INTC_IMRH_MASK56       (0x01000000)
#define MCF_INTC_IMRH_MASK57       (0x02000000)
#define MCF_INTC_IMRH_MASK58       (0x04000000)
#define MCF_INTC_IMRH_MASK59       (0x08000000)
#define MCF_INTC_IMRH_MASK60       (0x10000000)
#define MCF_INTC_IMRH_MASK61       (0x20000000)
#define MCF_INTC_IMRH_MASK62       (0x40000000)
#define MCF_INTC_IMRH_MASK63       (0x80000000)

/* Bit definitions and macros for MCF_INTC_IMRL */
#define MCF_INTC_IMRL_MASKALL      (0x00000001)
#define MCF_INTC_IMRL_MASK1        (0x00000002)
#define MCF_INTC_IMRL_MASK2        (0x00000004)
#define MCF_INTC_IMRL_MASK3        (0x00000008)
#define MCF_INTC_IMRL_MASK4        (0x00000010)
#define MCF_INTC_IMRL_MASK5        (0x00000020)
#define MCF_INTC_IMRL_MASK6        (0x00000040)
#define MCF_INTC_IMRL_MASK7        (0x00000080)
#define MCF_INTC_IMRL_MASK8        (0x00000100)
#define MCF_INTC_IMRL_MASK9        (0x00000200)
#define MCF_INTC_IMRL_MASK10       (0x00000400)
#define MCF_INTC_IMRL_MASK11       (0x00000800)
#define MCF_INTC_IMRL_MASK12       (0x00001000)
#define MCF_INTC_IMRL_MASK13       (0x00002000)
#define MCF_INTC_IMRL_MASK14       (0x00004000)
#define MCF_INTC_IMRL_MASK15       (0x00008000)
#define MCF_INTC_IMRL_MASK16       (0x00010000)
#define MCF_INTC_IMRL_MASK17       (0x00020000)
#define MCF_INTC_IMRL_MASK18       (0x00040000)
#define MCF_INTC_IMRL_MASK19       (0x00080000)
#define MCF_INTC_IMRL_MASK20       (0x00100000)
#define MCF_INTC_IMRL_MASK21       (0x00200000)
#define MCF_INTC_IMRL_MASK22       (0x00400000)
#define MCF_INTC_IMRL_MASK23       (0x00800000)
#define MCF_INTC_IMRL_MASK24       (0x01000000)
#define MCF_INTC_IMRL_MASK25       (0x02000000)
#define MCF_INTC_IMRL_MASK26       (0x04000000)
#define MCF_INTC_IMRL_MASK27       (0x08000000)
#define MCF_INTC_IMRL_MASK28       (0x10000000)
#define MCF_INTC_IMRL_MASK29       (0x20000000)
#define MCF_INTC_IMRL_MASK30       (0x40000000)
#define MCF_INTC_IMRL_MASK31       (0x80000000)

/* Bit definitions and macros for MCF_INTC_INTFRCH */
#define MCF_INTC_INTFRCH_INTFRC32  (0x00000001)
#define MCF_INTC_INTFRCH_INTFRC33  (0x00000002)
#define MCF_INTC_INTFRCH_INTFRC34  (0x00000004)
#define MCF_INTC_INTFRCH_INTFRC35  (0x00000008)
#define MCF_INTC_INTFRCH_INTFRC36  (0x00000010)
#define MCF_INTC_INTFRCH_INTFRC37  (0x00000020)
#define MCF_INTC_INTFRCH_INTFRC38  (0x00000040)
#define MCF_INTC_INTFRCH_INTFRC39  (0x00000080)
#define MCF_INTC_INTFRCH_INTFRC40  (0x00000100)
#define MCF_INTC_INTFRCH_INTFRC41  (0x00000200)
#define MCF_INTC_INTFRCH_INTFRC42  (0x00000400)
#define MCF_INTC_INTFRCH_INTFRC43  (0x00000800)
#define MCF_INTC_INTFRCH_INTFRC44  (0x00001000)
#define MCF_INTC_INTFRCH_INTFRC45  (0x00002000)
#define MCF_INTC_INTFRCH_INTFRC46  (0x00004000)
#define MCF_INTC_INTFRCH_INTFRC47  (0x00008000)
#define MCF_INTC_INTFRCH_INTFRC48  (0x00010000)
#define MCF_INTC_INTFRCH_INTFRC49  (0x00020000)
#define MCF_INTC_INTFRCH_INTFRC50  (0x00040000)
#define MCF_INTC_INTFRCH_INTFRC51  (0x00080000)
#define MCF_INTC_INTFRCH_INTFRC52  (0x00100000)
#define MCF_INTC_INTFRCH_INTFRC53  (0x00200000)
#define MCF_INTC_INTFRCH_INTFRC54  (0x00400000)
#define MCF_INTC_INTFRCH_INTFRC55  (0x00800000)
#define MCF_INTC_INTFRCH_INTFRC56  (0x01000000)
#define MCF_INTC_INTFRCH_INTFRC57  (0x02000000)
#define MCF_INTC_INTFRCH_INTFRC58  (0x04000000)
#define MCF_INTC_INTFRCH_INTFRC59  (0x08000000)
#define MCF_INTC_INTFRCH_INTFRC60  (0x10000000)
#define MCF_INTC_INTFRCH_INTFRC61  (0x20000000)
#define MCF_INTC_INTFRCH_INTFRC62  (0x40000000)
#define MCF_INTC_INTFRCH_INTFRC63  (0x80000000)

/* Bit definitions and macros for MCF_INTC_INTFRCL */
#define MCF_INTC_INTFRCL_INTFRC1   (0x00000002)
#define MCF_INTC_INTFRCL_INTFRC2   (0x00000004)
#define MCF_INTC_INTFRCL_INTFRC3   (0x00000008)
#define MCF_INTC_INTFRCL_INTFRC4   (0x00000010)
#define MCF_INTC_INTFRCL_INTFRC5   (0x00000020)
#define MCF_INTC_INTFRCL_INTFRC6   (0x00000040)
#define MCF_INTC_INTFRCL_INTFRC7   (0x00000080)
#define MCF_INTC_INTFRCL_INTFRC8   (0x00000100)
#define MCF_INTC_INTFRCL_INTFRC9   (0x00000200)
#define MCF_INTC_INTFRCL_INTFRC10  (0x00000400)
#define MCF_INTC_INTFRCL_INTFRC11  (0x00000800)
#define MCF_INTC_INTFRCL_INTFRC12  (0x00001000)
#define MCF_INTC_INTFRCL_INTFRC13  (0x00002000)
#define MCF_INTC_INTFRCL_INTFRC14  (0x00004000)
#define MCF_INTC_INTFRCL_INTFRC15  (0x00008000)
#define MCF_INTC_INTFRCL_INTFRC16  (0x00010000)
#define MCF_INTC_INTFRCL_INTFRC17  (0x00020000)
#define MCF_INTC_INTFRCL_INTFRC18  (0x00040000)
#define MCF_INTC_INTFRCL_INTFRC19  (0x00080000)
#define MCF_INTC_INTFRCL_INTFRC20  (0x00100000)
#define MCF_INTC_INTFRCL_INTFRC21  (0x00200000)
#define MCF_INTC_INTFRCL_INTFRC22  (0x00400000)
#define MCF_INTC_INTFRCL_INTFRC23  (0x00800000)
#define MCF_INTC_INTFRCL_INTFRC24  (0x01000000)
#define MCF_INTC_INTFRCL_INTFRC25  (0x02000000)
#define MCF_INTC_INTFRCL_INTFRC26  (0x04000000)
#define MCF_INTC_INTFRCL_INTFRC27  (0x08000000)
#define MCF_INTC_INTFRCL_INTFRC28  (0x10000000)
#define MCF_INTC_INTFRCL_INTFRC29  (0x20000000)
#define MCF_INTC_INTFRCL_INTFRC30  (0x40000000)
#define MCF_INTC_INTFRCL_INTFRC31  (0x80000000)

/* Bit definitions and macros for MCF_INTC_IRLR */
#define MCF_INTC_IRLR_IRQ(x)       (((x)&0x7F)<<1)

/* Bit definitions and macros for MCF_INTC_IACKLPR */
#define MCF_INTC_IACKLPR_PRI(x)    (((x)&0x0F)<<0)
#define MCF_INTC_IACKLPR_LEVEL(x)  (((x)&0x07)<<4)

/* Bit definitions and macros for MCF_INTC_ICR */
#define MCF_INTC_ICR_IP(x)         (((x)&0x07)<<0)
#define MCF_INTC_ICR_IL(x)         (((x)&0x07)<<3)

/* Bit definitions and macros for MCF_INTC_SWIACK */
#define MCF_INTC_SWIACK_VECTOR(x)  (((x)&0xFF)<<0)

/* Bit definitions and macros for MCF_INTC_LIACK */
#define MCF_INTC_LIACK_VECTOR(x)   (((x)&0xFF)<<0)

/*********************************************************************
*
* General Purpose I/O (GPIO)
*
*********************************************************************/

/* Register read/write macros */
#define MCF_GPIO_PORTNQ                   (*(hcc_reg8 *)(&_IPSBAR[0x100008]))
#define MCF_GPIO_PORTAN                   (*(hcc_reg8 *)(&_IPSBAR[0x10000A]))
#define MCF_GPIO_PORTAS                   (*(hcc_reg8 *)(&_IPSBAR[0x10000B]))
#define MCF_GPIO_PORTQS                   (*(hcc_reg8 *)(&_IPSBAR[0x10000C]))
#define MCF_GPIO_PORTTA                   (*(hcc_reg8 *)(&_IPSBAR[0x10000E]))
#define MCF_GPIO_PORTTC                   (*(hcc_reg8 *)(&_IPSBAR[0x10000F]))
#define MCF_GPIO_PORTUA                   (*(hcc_reg8 *)(&_IPSBAR[0x100011]))
#define MCF_GPIO_PORTUB                   (*(hcc_reg8 *)(&_IPSBAR[0x100012]))
#define MCF_GPIO_PORTUC                   (*(hcc_reg8 *)(&_IPSBAR[0x100013]))
#define MCF_GPIO_PORTDD                   (*(hcc_reg8 *)(&_IPSBAR[0x100014]))
#define MCF_GPIO_DDRNQ                    (*(hcc_reg8 *)(&_IPSBAR[0x100020]))
#define MCF_GPIO_DDRAN                    (*(hcc_reg8 *)(&_IPSBAR[0x100022]))
#define MCF_GPIO_DDRAS                    (*(hcc_reg8 *)(&_IPSBAR[0x100023]))
#define MCF_GPIO_DDRQS                    (*(hcc_reg8 *)(&_IPSBAR[0x100024]))
#define MCF_GPIO_DDRTA                    (*(hcc_reg8 *)(&_IPSBAR[0x100026]))
#define MCF_GPIO_DDRTC                    (*(hcc_reg8 *)(&_IPSBAR[0x100027]))
#define MCF_GPIO_DDRUA                    (*(hcc_reg8 *)(&_IPSBAR[0x100029]))
#define MCF_GPIO_DDRUB                    (*(hcc_reg8 *)(&_IPSBAR[0x10002A]))
#define MCF_GPIO_DDRUC                    (*(hcc_reg8 *)(&_IPSBAR[0x10002B]))
#define MCF_GPIO_DDRDD                    (*(hcc_reg8 *)(&_IPSBAR[0x10002C]))
#define MCF_GPIO_SETNQ                    (*(hcc_reg8 *)(&_IPSBAR[0x100038]))
#define MCF_GPIO_SETAN                    (*(hcc_reg8 *)(&_IPSBAR[0x10003A]))
#define MCF_GPIO_SETAS                    (*(hcc_reg8 *)(&_IPSBAR[0x10003B]))
#define MCF_GPIO_SETQS                    (*(hcc_reg8 *)(&_IPSBAR[0x10003C]))
#define MCF_GPIO_SETTA                    (*(hcc_reg8 *)(&_IPSBAR[0x10003E]))
#define MCF_GPIO_SETTC                    (*(hcc_reg8 *)(&_IPSBAR[0x10003F]))
#define MCF_GPIO_SETUA                    (*(hcc_reg8 *)(&_IPSBAR[0x100041]))
#define MCF_GPIO_SETUB                    (*(hcc_reg8 *)(&_IPSBAR[0x100042]))
#define MCF_GPIO_SETUC                    (*(hcc_reg8 *)(&_IPSBAR[0x100043]))
#define MCF_GPIO_SETDD                    (*(hcc_reg8 *)(&_IPSBAR[0x100044]))
#define MCF_GPIO_CLRNQ                    (*(hcc_reg8 *)(&_IPSBAR[0x100050]))
#define MCF_GPIO_CLRAN                    (*(hcc_reg8 *)(&_IPSBAR[0x100052]))
#define MCF_GPIO_CLRAS                    (*(hcc_reg8 *)(&_IPSBAR[0x100053]))
#define MCF_GPIO_CLRQS                    (*(hcc_reg8 *)(&_IPSBAR[0x100054]))
#define MCF_GPIO_CLRTA                    (*(hcc_reg8 *)(&_IPSBAR[0x100056]))
#define MCF_GPIO_CLRTC                    (*(hcc_reg8 *)(&_IPSBAR[0x100057]))
#define MCF_GPIO_CLRUA                    (*(hcc_reg8 *)(&_IPSBAR[0x100059]))
#define MCF_GPIO_CLRUB                    (*(hcc_reg8 *)(&_IPSBAR[0x10005A]))
#define MCF_GPIO_CLRUC                    (*(hcc_reg8 *)(&_IPSBAR[0x10005B]))
#define MCF_GPIO_CLRDD                    (*(hcc_reg8 *)(&_IPSBAR[0x10005C]))
#define MCF_GPIO_PNQPAR                   (*(hcc_reg16*)(&_IPSBAR[0x100068]))
#define MCF_GPIO_PANPAR                   (*(hcc_reg8 *)(&_IPSBAR[0x10006A]))
#define MCF_GPIO_PASPAR                   (*(hcc_reg8 *)(&_IPSBAR[0x10006B]))
#define MCF_GPIO_PQSPAR                   (*(hcc_reg16*)(&_IPSBAR[0x10006C]))
#define MCF_GPIO_PTAPAR                   (*(hcc_reg8 *)(&_IPSBAR[0x10006E]))
#define MCF_GPIO_PTCPAR                   (*(hcc_reg8 *)(&_IPSBAR[0x10006F]))
#define MCF_GPIO_PUAPAR                   (*(hcc_reg8 *)(&_IPSBAR[0x100071]))
#define MCF_GPIO_PUBPAR                   (*(hcc_reg8 *)(&_IPSBAR[0x100072]))
#define MCF_GPIO_PUCPAR                   (*(hcc_reg8 *)(&_IPSBAR[0x100073]))
#define MCF_GPIO_PDDPAR                   (*(hcc_reg8 *)(&_IPSBAR[0x100074]))
#define MCF_GPIO_PSSR                     (*(hcc_reg32*)(&_IPSBAR[0x100078]))
#define MCF_GPIO_PDSR                     (*(hcc_reg32*)(&_IPSBAR[0x10007C]))

/* Bit definitions and macros for MCF_GPIO_PORTNQ */
#define MCF_GPIO_PORTNQ_PORTNQ0           (0x01)
#define MCF_GPIO_PORTNQ_PORTNQ1           (0x02)
#define MCF_GPIO_PORTNQ_PORTNQ2           (0x04)
#define MCF_GPIO_PORTNQ_PORTNQ3           (0x08)
#define MCF_GPIO_PORTNQ_PORTNQ4           (0x10)
#define MCF_GPIO_PORTNQ_PORTNQ5           (0x20)
#define MCF_GPIO_PORTNQ_PORTNQ6           (0x40)
#define MCF_GPIO_PORTNQ_PORTNQ7           (0x80)

/* Bit definitions and macros for MCF_GPIO_PORTAN */
#define MCF_GPIO_PORTAN_PORTAN0           (0x01)
#define MCF_GPIO_PORTAN_PORTAN1           (0x02)
#define MCF_GPIO_PORTAN_PORTAN2           (0x04)
#define MCF_GPIO_PORTAN_PORTAN3           (0x08)
#define MCF_GPIO_PORTAN_PORTAN4           (0x10)
#define MCF_GPIO_PORTAN_PORTAN5           (0x20)
#define MCF_GPIO_PORTAN_PORTAN6           (0x40)
#define MCF_GPIO_PORTAN_PORTAN7           (0x80)

/* Bit definitions and macros for MCF_GPIO_PORTAS */
#define MCF_GPIO_PORTAS_PORTAS0           (0x01)
#define MCF_GPIO_PORTAS_PORTAS1           (0x02)
#define MCF_GPIO_PORTAS_PORTAS2           (0x04)
#define MCF_GPIO_PORTAS_PORTAS3           (0x08)
#define MCF_GPIO_PORTAS_PORTAS4           (0x10)
#define MCF_GPIO_PORTAS_PORTAS5           (0x20)
#define MCF_GPIO_PORTAS_PORTAS6           (0x40)
#define MCF_GPIO_PORTAS_PORTAS7           (0x80)

/* Bit definitions and macros for MCF_GPIO_PORTQS */
#define MCF_GPIO_PORTQS_PORTQS0           (0x01)
#define MCF_GPIO_PORTQS_PORTQS1           (0x02)
#define MCF_GPIO_PORTQS_PORTQS2           (0x04)
#define MCF_GPIO_PORTQS_PORTQS3           (0x08)
#define MCF_GPIO_PORTQS_PORTQS4           (0x10)
#define MCF_GPIO_PORTQS_PORTQS5           (0x20)
#define MCF_GPIO_PORTQS_PORTQS6           (0x40)
#define MCF_GPIO_PORTQS_PORTQS7           (0x80)

/* Bit definitions and macros for MCF_GPIO_PORTTA */
#define MCF_GPIO_PORTTA_PORTTA0           (0x01)
#define MCF_GPIO_PORTTA_PORTTA1           (0x02)
#define MCF_GPIO_PORTTA_PORTTA2           (0x04)
#define MCF_GPIO_PORTTA_PORTTA3           (0x08)
#define MCF_GPIO_PORTTA_PORTTA4           (0x10)
#define MCF_GPIO_PORTTA_PORTTA5           (0x20)
#define MCF_GPIO_PORTTA_PORTTA6           (0x40)
#define MCF_GPIO_PORTTA_PORTTA7           (0x80)

/* Bit definitions and macros for MCF_GPIO_PORTTC */
#define MCF_GPIO_PORTTC_PORTTC0           (0x01)
#define MCF_GPIO_PORTTC_PORTTC1           (0x02)
#define MCF_GPIO_PORTTC_PORTTC2           (0x04)
#define MCF_GPIO_PORTTC_PORTTC3           (0x08)
#define MCF_GPIO_PORTTC_PORTTC4           (0x10)
#define MCF_GPIO_PORTTC_PORTTC5           (0x20)
#define MCF_GPIO_PORTTC_PORTTC6           (0x40)
#define MCF_GPIO_PORTTC_PORTTC7           (0x80)

/* Bit definitions and macros for MCF_GPIO_PORTUA */
#define MCF_GPIO_PORTUA_PORTUA0           (0x01)
#define MCF_GPIO_PORTUA_PORTUA1           (0x02)
#define MCF_GPIO_PORTUA_PORTUA2           (0x04)
#define MCF_GPIO_PORTUA_PORTUA3           (0x08)
#define MCF_GPIO_PORTUA_PORTUA4           (0x10)
#define MCF_GPIO_PORTUA_PORTUA5           (0x20)
#define MCF_GPIO_PORTUA_PORTUA6           (0x40)
#define MCF_GPIO_PORTUA_PORTUA7           (0x80)

/* Bit definitions and macros for MCF_GPIO_PORTUB */
#define MCF_GPIO_PORTUB_PORTUB0           (0x01)
#define MCF_GPIO_PORTUB_PORTUB1           (0x02)
#define MCF_GPIO_PORTUB_PORTUB2           (0x04)
#define MCF_GPIO_PORTUB_PORTUB3           (0x08)
#define MCF_GPIO_PORTUB_PORTUB4           (0x10)
#define MCF_GPIO_PORTUB_PORTUB5           (0x20)
#define MCF_GPIO_PORTUB_PORTUB6           (0x40)
#define MCF_GPIO_PORTUB_PORTUB7           (0x80)

/* Bit definitions and macros for MCF_GPIO_PORTUC */
#define MCF_GPIO_PORTUC_PORTUC0           (0x01)
#define MCF_GPIO_PORTUC_PORTUC1           (0x02)
#define MCF_GPIO_PORTUC_PORTUC2           (0x04)
#define MCF_GPIO_PORTUC_PORTUC3           (0x08)
#define MCF_GPIO_PORTUC_PORTUC4           (0x10)
#define MCF_GPIO_PORTUC_PORTUC5           (0x20)
#define MCF_GPIO_PORTUC_PORTUC6           (0x40)
#define MCF_GPIO_PORTUC_PORTUC7           (0x80)

/* Bit definitions and macros for MCF_GPIO_PORTDD */
#define MCF_GPIO_PORTDD_PORTDD0           (0x01)
#define MCF_GPIO_PORTDD_PORTDD1           (0x02)
#define MCF_GPIO_PORTDD_PORTDD2           (0x04)
#define MCF_GPIO_PORTDD_PORTDD3           (0x08)
#define MCF_GPIO_PORTDD_PORTDD4           (0x10)
#define MCF_GPIO_PORTDD_PORTDD5           (0x20)
#define MCF_GPIO_PORTDD_PORTDD6           (0x40)
#define MCF_GPIO_PORTDD_PORTDD7           (0x80)

/* Bit definitions and macros for MCF_GPIO_DDRNQ */
#define MCF_GPIO_DDRNQ_DDRNQ0             (0x01)
#define MCF_GPIO_DDRNQ_DDRNQ1             (0x02)
#define MCF_GPIO_DDRNQ_DDRNQ2             (0x04)
#define MCF_GPIO_DDRNQ_DDRNQ3             (0x08)
#define MCF_GPIO_DDRNQ_DDRNQ4             (0x10)
#define MCF_GPIO_DDRNQ_DDRNQ5             (0x20)
#define MCF_GPIO_DDRNQ_DDRNQ6             (0x40)
#define MCF_GPIO_DDRNQ_DDRNQ7             (0x80)

/* Bit definitions and macros for MCF_GPIO_DDRAN */
#define MCF_GPIO_DDRAN_DDRAN0             (0x01)
#define MCF_GPIO_DDRAN_DDRAN1             (0x02)
#define MCF_GPIO_DDRAN_DDRAN2             (0x04)
#define MCF_GPIO_DDRAN_DDRAN3             (0x08)
#define MCF_GPIO_DDRAN_DDRAN4             (0x10)
#define MCF_GPIO_DDRAN_DDRAN5             (0x20)
#define MCF_GPIO_DDRAN_DDRAN6             (0x40)
#define MCF_GPIO_DDRAN_DDRAN7             (0x80)

/* Bit definitions and macros for MCF_GPIO_DDRAS */
#define MCF_GPIO_DDRAS_DDRAS0             (0x01)
#define MCF_GPIO_DDRAS_DDRAS1             (0x02)
#define MCF_GPIO_DDRAS_DDRAS2             (0x04)
#define MCF_GPIO_DDRAS_DDRAS3             (0x08)
#define MCF_GPIO_DDRAS_DDRAS4             (0x10)
#define MCF_GPIO_DDRAS_DDRAS5             (0x20)
#define MCF_GPIO_DDRAS_DDRAS6             (0x40)
#define MCF_GPIO_DDRAS_DDRAS7             (0x80)

/* Bit definitions and macros for MCF_GPIO_DDRQS */
#define MCF_GPIO_DDRQS_DDRQS0             (0x01)
#define MCF_GPIO_DDRQS_DDRQS1             (0x02)
#define MCF_GPIO_DDRQS_DDRQS2             (0x04)
#define MCF_GPIO_DDRQS_DDRQS3             (0x08)
#define MCF_GPIO_DDRQS_DDRQS4             (0x10)
#define MCF_GPIO_DDRQS_DDRQS5             (0x20)
#define MCF_GPIO_DDRQS_DDRQS6             (0x40)
#define MCF_GPIO_DDRQS_DDRQS7             (0x80)

/* Bit definitions and macros for MCF_GPIO_DDRTA */
#define MCF_GPIO_DDRTA_DDRTA0             (0x01)
#define MCF_GPIO_DDRTA_DDRTA1             (0x02)
#define MCF_GPIO_DDRTA_DDRTA2             (0x04)
#define MCF_GPIO_DDRTA_DDRTA3             (0x08)
#define MCF_GPIO_DDRTA_DDRTA4             (0x10)
#define MCF_GPIO_DDRTA_DDRTA5             (0x20)
#define MCF_GPIO_DDRTA_DDRTA6             (0x40)
#define MCF_GPIO_DDRTA_DDRTA7             (0x80)

/* Bit definitions and macros for MCF_GPIO_DDRTC */
#define MCF_GPIO_DDRTC_DDRTC0             (0x01)
#define MCF_GPIO_DDRTC_DDRTC1             (0x02)
#define MCF_GPIO_DDRTC_DDRTC2             (0x04)
#define MCF_GPIO_DDRTC_DDRTC3             (0x08)
#define MCF_GPIO_DDRTC_DDRTC4             (0x10)
#define MCF_GPIO_DDRTC_DDRTC5             (0x20)
#define MCF_GPIO_DDRTC_DDRTC6             (0x40)
#define MCF_GPIO_DDRTC_DDRTC7             (0x80)

/* Bit definitions and macros for MCF_GPIO_DDRUA */
#define MCF_GPIO_DDRUA_DDRUA0             (0x01)
#define MCF_GPIO_DDRUA_DDRUA1             (0x02)
#define MCF_GPIO_DDRUA_DDRUA2             (0x04)
#define MCF_GPIO_DDRUA_DDRUA3             (0x08)
#define MCF_GPIO_DDRUA_DDRUA4             (0x10)
#define MCF_GPIO_DDRUA_DDRUA5             (0x20)
#define MCF_GPIO_DDRUA_DDRUA6             (0x40)
#define MCF_GPIO_DDRUA_DDRUA7             (0x80)

/* Bit definitions and macros for MCF_GPIO_DDRUB */
#define MCF_GPIO_DDRUB_DDRUB0             (0x01)
#define MCF_GPIO_DDRUB_DDRUB1             (0x02)
#define MCF_GPIO_DDRUB_DDRUB2             (0x04)
#define MCF_GPIO_DDRUB_DDRUB3             (0x08)
#define MCF_GPIO_DDRUB_DDRUB4             (0x10)
#define MCF_GPIO_DDRUB_DDRUB5             (0x20)
#define MCF_GPIO_DDRUB_DDRUB6             (0x40)
#define MCF_GPIO_DDRUB_DDRUB7             (0x80)

/* Bit definitions and macros for MCF_GPIO_DDRUC */
#define MCF_GPIO_DDRUC_DDRUC0             (0x01)
#define MCF_GPIO_DDRUC_DDRUC1             (0x02)
#define MCF_GPIO_DDRUC_DDRUC2             (0x04)
#define MCF_GPIO_DDRUC_DDRUC3             (0x08)
#define MCF_GPIO_DDRUC_DDRUC4             (0x10)
#define MCF_GPIO_DDRUC_DDRUC5             (0x20)
#define MCF_GPIO_DDRUC_DDRUC6             (0x40)
#define MCF_GPIO_DDRUC_DDRUC7             (0x80)

/* Bit definitions and macros for MCF_GPIO_DDRDD */
#define MCF_GPIO_DDRDD_DDRDD0             (0x01)
#define MCF_GPIO_DDRDD_DDRDD1             (0x02)
#define MCF_GPIO_DDRDD_DDRDD2             (0x04)
#define MCF_GPIO_DDRDD_DDRDD3             (0x08)
#define MCF_GPIO_DDRDD_DDRDD4             (0x10)
#define MCF_GPIO_DDRDD_DDRDD5             (0x20)
#define MCF_GPIO_DDRDD_DDRDD6             (0x40)
#define MCF_GPIO_DDRDD_DDRDD7             (0x80)

/* Bit definitions and macros for MCF_GPIO_SETNQ */
#define MCF_GPIO_SETNQ_SETNQ0             (0x01)
#define MCF_GPIO_SETNQ_SETNQ1             (0x02)
#define MCF_GPIO_SETNQ_SETNQ2             (0x04)
#define MCF_GPIO_SETNQ_SETNQ3             (0x08)
#define MCF_GPIO_SETNQ_SETNQ4             (0x10)
#define MCF_GPIO_SETNQ_SETNQ5             (0x20)
#define MCF_GPIO_SETNQ_SETNQ6             (0x40)
#define MCF_GPIO_SETNQ_SETNQ7             (0x80)

/* Bit definitions and macros for MCF_GPIO_SETAN */
#define MCF_GPIO_SETAN_SETAN0             (0x01)
#define MCF_GPIO_SETAN_SETAN1             (0x02)
#define MCF_GPIO_SETAN_SETAN2             (0x04)
#define MCF_GPIO_SETAN_SETAN3             (0x08)
#define MCF_GPIO_SETAN_SETAN4             (0x10)
#define MCF_GPIO_SETAN_SETAN5             (0x20)
#define MCF_GPIO_SETAN_SETAN6             (0x40)
#define MCF_GPIO_SETAN_SETAN7             (0x80)

/* Bit definitions and macros for MCF_GPIO_SETAS */
#define MCF_GPIO_SETAS_SETAS0             (0x01)
#define MCF_GPIO_SETAS_SETAS1             (0x02)
#define MCF_GPIO_SETAS_SETAS2             (0x04)
#define MCF_GPIO_SETAS_SETAS3             (0x08)
#define MCF_GPIO_SETAS_SETAS4             (0x10)
#define MCF_GPIO_SETAS_SETAS5             (0x20)
#define MCF_GPIO_SETAS_SETAS6             (0x40)
#define MCF_GPIO_SETAS_SETAS7             (0x80)

/* Bit definitions and macros for MCF_GPIO_SETQS */
#define MCF_GPIO_SETQS_SETQS0             (0x01)
#define MCF_GPIO_SETQS_SETQS1             (0x02)
#define MCF_GPIO_SETQS_SETQS2             (0x04)
#define MCF_GPIO_SETQS_SETQS3             (0x08)
#define MCF_GPIO_SETQS_SETQS4             (0x10)
#define MCF_GPIO_SETQS_SETQS5             (0x20)
#define MCF_GPIO_SETQS_SETQS6             (0x40)
#define MCF_GPIO_SETQS_SETQS7             (0x80)

/* Bit definitions and macros for MCF_GPIO_SETTA */
#define MCF_GPIO_SETTA_SETTA0             (0x01)
#define MCF_GPIO_SETTA_SETTA1             (0x02)
#define MCF_GPIO_SETTA_SETTA2             (0x04)
#define MCF_GPIO_SETTA_SETTA3             (0x08)
#define MCF_GPIO_SETTA_SETTA4             (0x10)
#define MCF_GPIO_SETTA_SETTA5             (0x20)
#define MCF_GPIO_SETTA_SETTA6             (0x40)
#define MCF_GPIO_SETTA_SETTA7             (0x80)

/* Bit definitions and macros for MCF_GPIO_SETTC */
#define MCF_GPIO_SETTC_SETTC0             (0x01)
#define MCF_GPIO_SETTC_SETTC1             (0x02)
#define MCF_GPIO_SETTC_SETTC2             (0x04)
#define MCF_GPIO_SETTC_SETTC3             (0x08)
#define MCF_GPIO_SETTC_SETTC4             (0x10)
#define MCF_GPIO_SETTC_SETTC5             (0x20)
#define MCF_GPIO_SETTC_SETTC6             (0x40)
#define MCF_GPIO_SETTC_SETTC7             (0x80)

/* Bit definitions and macros for MCF_GPIO_SETUA */
#define MCF_GPIO_SETUA_SETUA0             (0x01)
#define MCF_GPIO_SETUA_SETUA1             (0x02)
#define MCF_GPIO_SETUA_SETUA2             (0x04)
#define MCF_GPIO_SETUA_SETUA3             (0x08)
#define MCF_GPIO_SETUA_SETUA4             (0x10)
#define MCF_GPIO_SETUA_SETUA5             (0x20)
#define MCF_GPIO_SETUA_SETUA6             (0x40)
#define MCF_GPIO_SETUA_SETUA7             (0x80)

/* Bit definitions and macros for MCF_GPIO_SETUB */
#define MCF_GPIO_SETUB_SETUB0             (0x01)
#define MCF_GPIO_SETUB_SETUB1             (0x02)
#define MCF_GPIO_SETUB_SETUB2             (0x04)
#define MCF_GPIO_SETUB_SETUB3             (0x08)
#define MCF_GPIO_SETUB_SETUB4             (0x10)
#define MCF_GPIO_SETUB_SETUB5             (0x20)
#define MCF_GPIO_SETUB_SETUB6             (0x40)
#define MCF_GPIO_SETUB_SETUB7             (0x80)

/* Bit definitions and macros for MCF_GPIO_SETUC */
#define MCF_GPIO_SETUC_SETUC0             (0x01)
#define MCF_GPIO_SETUC_SETUC1             (0x02)
#define MCF_GPIO_SETUC_SETUC2             (0x04)
#define MCF_GPIO_SETUC_SETUC3             (0x08)
#define MCF_GPIO_SETUC_SETUC4             (0x10)
#define MCF_GPIO_SETUC_SETUC5             (0x20)
#define MCF_GPIO_SETUC_SETUC6             (0x40)
#define MCF_GPIO_SETUC_SETUC7             (0x80)

/* Bit definitions and macros for MCF_GPIO_SETDD */
#define MCF_GPIO_SETDD_SETDD0             (0x01)
#define MCF_GPIO_SETDD_SETDD1             (0x02)
#define MCF_GPIO_SETDD_SETDD2             (0x04)
#define MCF_GPIO_SETDD_SETDD3             (0x08)
#define MCF_GPIO_SETDD_SETDD4             (0x10)
#define MCF_GPIO_SETDD_SETDD5             (0x20)
#define MCF_GPIO_SETDD_SETDD6             (0x40)
#define MCF_GPIO_SETDD_SETDD7             (0x80)

/* Bit definitions and macros for MCF_GPIO_CLRNQ */
#define MCF_GPIO_CLRNQ_CLRNQ0             (0x01)
#define MCF_GPIO_CLRNQ_CLRNQ1             (0x02)
#define MCF_GPIO_CLRNQ_CLRNQ2             (0x04)
#define MCF_GPIO_CLRNQ_CLRNQ3             (0x08)
#define MCF_GPIO_CLRNQ_CLRNQ4             (0x10)
#define MCF_GPIO_CLRNQ_CLRNQ5             (0x20)
#define MCF_GPIO_CLRNQ_CLRNQ6             (0x40)
#define MCF_GPIO_CLRNQ_CLRNQ7             (0x80)

/* Bit definitions and macros for MCF_GPIO_CLRAN */
#define MCF_GPIO_CLRAN_CLRAN0             (0x01)
#define MCF_GPIO_CLRAN_CLRAN1             (0x02)
#define MCF_GPIO_CLRAN_CLRAN2             (0x04)
#define MCF_GPIO_CLRAN_CLRAN3             (0x08)
#define MCF_GPIO_CLRAN_CLRAN4             (0x10)
#define MCF_GPIO_CLRAN_CLRAN5             (0x20)
#define MCF_GPIO_CLRAN_CLRAN6             (0x40)
#define MCF_GPIO_CLRAN_CLRAN7             (0x80)

/* Bit definitions and macros for MCF_GPIO_CLRAS */
#define MCF_GPIO_CLRAS_CLRAS0             (0x01)
#define MCF_GPIO_CLRAS_CLRAS1             (0x02)
#define MCF_GPIO_CLRAS_CLRAS2             (0x04)
#define MCF_GPIO_CLRAS_CLRAS3             (0x08)
#define MCF_GPIO_CLRAS_CLRAS4             (0x10)
#define MCF_GPIO_CLRAS_CLRAS5             (0x20)
#define MCF_GPIO_CLRAS_CLRAS6             (0x40)
#define MCF_GPIO_CLRAS_CLRAS7             (0x80)

/* Bit definitions and macros for MCF_GPIO_CLRQS */
#define MCF_GPIO_CLRQS_CLRQS0             (0x01)
#define MCF_GPIO_CLRQS_CLRQS1             (0x02)
#define MCF_GPIO_CLRQS_CLRQS2             (0x04)
#define MCF_GPIO_CLRQS_CLRQS3             (0x08)
#define MCF_GPIO_CLRQS_CLRQS4             (0x10)
#define MCF_GPIO_CLRQS_CLRQS5             (0x20)
#define MCF_GPIO_CLRQS_CLRQS6             (0x40)
#define MCF_GPIO_CLRQS_CLRQS7             (0x80)

/* Bit definitions and macros for MCF_GPIO_CLRTA */
#define MCF_GPIO_CLRTA_CLRTA0             (0x01)
#define MCF_GPIO_CLRTA_CLRTA1             (0x02)
#define MCF_GPIO_CLRTA_CLRTA2             (0x04)
#define MCF_GPIO_CLRTA_CLRTA3             (0x08)
#define MCF_GPIO_CLRTA_CLRTA4             (0x10)
#define MCF_GPIO_CLRTA_CLRTA5             (0x20)
#define MCF_GPIO_CLRTA_CLRTA6             (0x40)
#define MCF_GPIO_CLRTA_CLRTA7             (0x80)

/* Bit definitions and macros for MCF_GPIO_CLRTC */
#define MCF_GPIO_CLRTC_CLRTC0             (0x01)
#define MCF_GPIO_CLRTC_CLRTC1             (0x02)
#define MCF_GPIO_CLRTC_CLRTC2             (0x04)
#define MCF_GPIO_CLRTC_CLRTC3             (0x08)
#define MCF_GPIO_CLRTC_CLRTC4             (0x10)
#define MCF_GPIO_CLRTC_CLRTC5             (0x20)
#define MCF_GPIO_CLRTC_CLRTC6             (0x40)
#define MCF_GPIO_CLRTC_CLRTC7             (0x80)

/* Bit definitions and macros for MCF_GPIO_CLRUA */
#define MCF_GPIO_CLRUA_CLRUA0             (0x01)
#define MCF_GPIO_CLRUA_CLRUA1             (0x02)
#define MCF_GPIO_CLRUA_CLRUA2             (0x04)
#define MCF_GPIO_CLRUA_CLRUA3             (0x08)
#define MCF_GPIO_CLRUA_CLRUA4             (0x10)
#define MCF_GPIO_CLRUA_CLRUA5             (0x20)
#define MCF_GPIO_CLRUA_CLRUA6             (0x40)
#define MCF_GPIO_CLRUA_CLRUA7             (0x80)

/* Bit definitions and macros for MCF_GPIO_CLRUB */
#define MCF_GPIO_CLRUB_CLRUB0             (0x01)
#define MCF_GPIO_CLRUB_CLRUB1             (0x02)
#define MCF_GPIO_CLRUB_CLRUB2             (0x04)
#define MCF_GPIO_CLRUB_CLRUB3             (0x08)
#define MCF_GPIO_CLRUB_CLRUB4             (0x10)
#define MCF_GPIO_CLRUB_CLRUB5             (0x20)
#define MCF_GPIO_CLRUB_CLRUB6             (0x40)
#define MCF_GPIO_CLRUB_CLRUB7             (0x80)

/* Bit definitions and macros for MCF_GPIO_CLRUC */
#define MCF_GPIO_CLRUC_CLRUC0             (0x01)
#define MCF_GPIO_CLRUC_CLRUC1             (0x02)
#define MCF_GPIO_CLRUC_CLRUC2             (0x04)
#define MCF_GPIO_CLRUC_CLRUC3             (0x08)
#define MCF_GPIO_CLRUC_CLRUC4             (0x10)
#define MCF_GPIO_CLRUC_CLRUC5             (0x20)
#define MCF_GPIO_CLRUC_CLRUC6             (0x40)
#define MCF_GPIO_CLRUC_CLRUC7             (0x80)

/* Bit definitions and macros for MCF_GPIO_CLRDD */
#define MCF_GPIO_CLRDD_CLRDD0             (0x01)
#define MCF_GPIO_CLRDD_CLRDD1             (0x02)
#define MCF_GPIO_CLRDD_CLRDD2             (0x04)
#define MCF_GPIO_CLRDD_CLRDD3             (0x08)
#define MCF_GPIO_CLRDD_CLRDD4             (0x10)
#define MCF_GPIO_CLRDD_CLRDD5             (0x20)
#define MCF_GPIO_CLRDD_CLRDD6             (0x40)
#define MCF_GPIO_CLRDD_CLRDD7             (0x80)

/* Bit definitions and macros for MCF_GPIO_PNQPAR */
#define MCF_GPIO_PNQPAR_PNQPAR1(x)        (((x)&0x0003)<<2)
#define MCF_GPIO_PNQPAR_PNQPAR2(x)        (((x)&0x0003)<<4)
#define MCF_GPIO_PNQPAR_PNQPAR3(x)        (((x)&0x0003)<<6)
#define MCF_GPIO_PNQPAR_PNQPAR4(x)        (((x)&0x0003)<<8)
#define MCF_GPIO_PNQPAR_PNQPAR5(x)        (((x)&0x0003)<<10)
#define MCF_GPIO_PNQPAR_PNQPAR6(x)        (((x)&0x0003)<<12)
#define MCF_GPIO_PNQPAR_PNQPAR7(x)        (((x)&0x0003)<<14)
#define MCF_GPIO_PNQPAR_IRQ1_GPIO         (0x0000)
#define MCF_GPIO_PNQPAR_IRQ2_GPIO         (0x0000)
#define MCF_GPIO_PNQPAR_IRQ3_GPIO         (0x0000)
#define MCF_GPIO_PNQPAR_IRQ4_GPIO         (0x0000)
#define MCF_GPIO_PNQPAR_IRQ5_GPIO         (0x0000)
#define MCF_GPIO_PNQPAR_IRQ6_GPIO         (0x0000)
#define MCF_GPIO_PNQPAR_IRQ7_GPIO         (0x0000)
#define MCF_GPIO_PNQPAR_IRQ1_IRQ1         (0x0004)
#define MCF_GPIO_PNQPAR_IRQ2_IRQ2         (0x0010)
#define MCF_GPIO_PNQPAR_IRQ3_IRQ3         (0x0040)
#define MCF_GPIO_PNQPAR_IRQ4_IRQ4         (0x0100)
#define MCF_GPIO_PNQPAR_IRQ5_IRQ5         (0x0400)
#define MCF_GPIO_PNQPAR_IRQ6_IRQ6         (0x1000)
#define MCF_GPIO_PNQPAR_IRQ7_IRQ7         (0x4000)
#define MCF_GPIO_PNQPAR_IRQ1_SYNCA        (0x0008)
#define MCF_GPIO_PNQPAR_IRQ1_USB_ALT_CLK  (0x000C)
#define MCF_GPIO_PNQPAR_IRQ2_USB_SESSVLD  (0x0020)
#define MCF_GPIO_PNQPAR_IRQ3_USB_SESSEND  (0x0080)
#define MCF_GPIO_PNQPAR_IRQ4_USB_PULLUP   (0x0200)
#define MCF_GPIO_PNQPAR_IRQ5_USB_VBUSVLD  (0x0800)
#define MCF_GPIO_PNQPAR_IRQ6_USB_ID       (0x2000)

/* Bit definitions and macros for MCF_GPIO_PANPAR */
#define MCF_GPIO_PANPAR_PANPAR0           (0x01)
#define MCF_GPIO_PANPAR_PANPAR1           (0x02)
#define MCF_GPIO_PANPAR_PANPAR2           (0x04)
#define MCF_GPIO_PANPAR_PANPAR3           (0x08)
#define MCF_GPIO_PANPAR_PANPAR4           (0x10)
#define MCF_GPIO_PANPAR_PANPAR5           (0x20)
#define MCF_GPIO_PANPAR_PANPAR6           (0x40)
#define MCF_GPIO_PANPAR_PANPAR7           (0x80)
#define MCF_GPIO_PANPAR_AN0_GPIO          (0x00)
#define MCF_GPIO_PANPAR_AN1_GPIO          (0x00)
#define MCF_GPIO_PANPAR_AN2_GPIO          (0x00)
#define MCF_GPIO_PANPAR_AN3_GPIO          (0x00)
#define MCF_GPIO_PANPAR_AN4_GPIO          (0x00)
#define MCF_GPIO_PANPAR_AN5_GPIO          (0x00)
#define MCF_GPIO_PANPAR_AN6_GPIO          (0x00)
#define MCF_GPIO_PANPAR_AN7_GPIO          (0x00)
#define MCF_GPIO_PANPAR_AN0_AN0           (0x02)
#define MCF_GPIO_PANPAR_AN1_AN1           (0x03)
#define MCF_GPIO_PANPAR_AN2_AN2           (0x04)
#define MCF_GPIO_PANPAR_AN3_AN3           (0x08)
#define MCF_GPIO_PANPAR_AN4_AN4           (0x10)
#define MCF_GPIO_PANPAR_AN5_AN5           (0x20)
#define MCF_GPIO_PANPAR_AN6_AN6           (0x40)
#define MCF_GPIO_PANPAR_AN7_AN7           (0x80)

/* Bit definitions and macros for MCF_GPIO_PASPAR */
#define MCF_GPIO_PASPAR_PASPAR0(x)        (((x)&0x03)<<0)
#define MCF_GPIO_PASPAR_PASPAR1(x)        (((x)&0x03)<<2)
#define MCF_GPIO_PASPAR_PASPAR2(x)        (((x)&0x03)<<4)
#define MCF_GPIO_PASPAR_PASPAR3(x)        (((x)&0x03)<<6)
#define MCF_GPIO_PASPAR_SCL_GPIO          (0x00)
#define MCF_GPIO_PASPAR_SDA_GPIO          (0x00)
#define MCF_GPIO_PASPAR_SCL_SCL           (0x01)
#define MCF_GPIO_PASPAR_SDA_SDA           (0x04)
#define MCF_GPIO_PASPAR_SCL_TXD2          (0x03)
#define MCF_GPIO_PASPAR_SDA_RXD2          (0x0c)

/* Bit definitions and macros for MCF_GPIO_PQSPAR */
#define MCF_GPIO_PQSPAR_PQSPAR0(x)        (((x)&0x0003)<<0)
#define MCF_GPIO_PQSPAR_PQSPAR1(x)        (((x)&0x0003)<<2)
#define MCF_GPIO_PQSPAR_PQSPAR2(x)        (((x)&0x0003)<<4)
#define MCF_GPIO_PQSPAR_PQSPAR3(x)        (((x)&0x0003)<<6)
#define MCF_GPIO_PQSPAR_PQSPAR4(x)        (((x)&0x0003)<<8)
#define MCF_GPIO_PQSPAR_PQSPAR5(x)        (((x)&0x0003)<<10)
#define MCF_GPIO_PQSPAR_PQSPAR6(x)        (((x)&0x0003)<<12)
#define MCF_GPIO_PQSPAR_DOUT_GPIO         (0x0000)
#define MCF_GPIO_PQSPAR_DIN_GPIO          (0x0000)
#define MCF_GPIO_PQSPAR_SCK_GPIO          (0x0000)
#define MCF_GPIO_PQSPAR_CS0_GPIO          (0x0000)
#define MCF_GPIO_PQSPAR_CS1_GPIO          (0x0000)
#define MCF_GPIO_PQSPAR_CS2_GPIO          (0x0000)
#define MCF_GPIO_PQSPAR_CS3_GPIO          (0x0000)
#define MCF_GPIO_PQSPAR_DOUT_DOUT         (0x0001)
#define MCF_GPIO_PQSPAR_DIN_DIN           (0x0004)
#define MCF_GPIO_PQSPAR_SCK_SCK           (0x0010)
#define MCF_GPIO_PQSPAR_CS0_CS0           (0x0040)
#define MCF_GPIO_PQSPAR_CS1_CS1           (0x0100)
#define MCF_GPIO_PQSPAR_CS2_CS2           (0x0400)
#define MCF_GPIO_PQSPAR_CS3_CS3           (0x1000)
#define MCF_GPIO_PQSPAR_SCK_SCL           (0x0020)
#define MCF_GPIO_PQSPAR_CS0_SDA           (0x0080)
#define MCF_GPIO_PQSPAR_CS3_SYNCA         (0x2000)
#define MCF_GPIO_PQSPAR_DOUT_TXD1         (0x0003)
#define MCF_GPIO_PQSPAR_DIN_RXD1          (0x000C)
#define MCF_GPIO_PQSPAR_SCK_RTS1          (0x0030)
#define MCF_GPIO_PQSPAR_CS0_CTS1          (0x00C0)
#define MCF_GPIO_PQSPAR_CS3_USB_DP_PD     (0xc000)
#define MCF_GPIO_PQSPAR_CS2_USB_DM_PD     (0x0800)
#define MCF_GPIO_PQSPAR_CS1_USB_PULLUP    (0x0200)

/* Bit definitions and macros for MCF_GPIO_PTAPAR */
#define MCF_GPIO_PTAPAR_PTAPAR0(x)        (((x)&0x03)<<0)
#define MCF_GPIO_PTAPAR_PTAPAR1(x)        (((x)&0x03)<<2)
#define MCF_GPIO_PTAPAR_PTAPAR2(x)        (((x)&0x03)<<4)
#define MCF_GPIO_PTAPAR_PTAPAR3(x)        (((x)&0x03)<<6)
#define MCF_GPIO_PTAPAR_ICOC0_GPIO        (0x00)
#define MCF_GPIO_PTAPAR_ICOC1_GPIO        (0x00)
#define MCF_GPIO_PTAPAR_ICOC2_GPIO        (0x00)
#define MCF_GPIO_PTAPAR_ICOC3_GPIO        (0x00)
#define MCF_GPIO_PTAPAR_ICOC0_ICOC0       (0x01)
#define MCF_GPIO_PTAPAR_ICOC1_ICOC1       (0x04)
#define MCF_GPIO_PTAPAR_ICOC2_ICOC2       (0x10)
#define MCF_GPIO_PTAPAR_ICOC3_ICOC3       (0x40)
#define MCF_GPIO_PTAPAR_ICOC0_PWM1        (0x02)
#define MCF_GPIO_PTAPAR_ICOC1_PWM3        (0x08)
#define MCF_GPIO_PTAPAR_ICOC2_PWM5        (0x20)
#define MCF_GPIO_PTAPAR_ICOC3_PWM7        (0x80)

/* Bit definitions and macros for MCF_GPIO_PTCPAR */
#define MCF_GPIO_PTCPAR_PTCPAR0(x)        (((x)&0x03)<<0)
#define MCF_GPIO_PTCPAR_PTCPAR1(x)        (((x)&0x03)<<2)
#define MCF_GPIO_PTCPAR_PTCPAR2(x)        (((x)&0x03)<<4)
#define MCF_GPIO_PTCPAR_PTCPAR3(x)        (((x)&0x03)<<6)
#define MCF_GPIO_PTCPAR_TIN0_GPIO         (0x00)
#define MCF_GPIO_PTCPAR_TIN1_GPIO         (0x00)
#define MCF_GPIO_PTCPAR_TIN2_GPIO         (0x00)
#define MCF_GPIO_PTCPAR_TIN3_GPIO         (0x00)
#define MCF_GPIO_PTCPAR_TIN0_TIN0         (0x01)
#define MCF_GPIO_PTCPAR_TIN1_TIN1         (0x04)
#define MCF_GPIO_PTCPAR_TIN2_TIN2         (0x10)
#define MCF_GPIO_PTCPAR_TIN3_TIN3         (0x40)
#define MCF_GPIO_PTCPAR_TIN0_TOUT0        (0x02)
#define MCF_GPIO_PTCPAR_TIN1_TOUT1        (0x08)
#define MCF_GPIO_PTCPAR_TIN2_TOUT2        (0x20)
#define MCF_GPIO_PTCPAR_TIN3_TOUT3        (0x80)
#define MCF_GPIO_PTCPAR_TIN0_PWM0         (0x03)
#define MCF_GPIO_PTCPAR_TIN1_PWM2         (0x0C)
#define MCF_GPIO_PTCPAR_TIN2_PWM4         (0x30)
#define MCF_GPIO_PTCPAR_TIN3_PWM6         (0xC0)

/* Bit definitions and macros for MCF_GPIO_PUAPAR */
#define MCF_GPIO_PUAPAR_PUAPAR0(x)        (((x)&0x03)<<0)
#define MCF_GPIO_PUAPAR_PUAPAR1(x)        (((x)&0x03)<<2)
#define MCF_GPIO_PUAPAR_PUAPAR2(x)        (((x)&0x03)<<4)
#define MCF_GPIO_PUAPAR_PUAPAR3(x)        (((x)&0x03)<<6)
#define MCF_GPIO_PUAPAR_TXD0_GPIO         (0x00)
#define MCF_GPIO_PUAPAR_RXD0_GPIO         (0x00)
#define MCF_GPIO_PUAPAR_RTS0_GPIO         (0x00)
#define MCF_GPIO_PUAPAR_CTS0_GPIO         (0x00)
#define MCF_GPIO_PUAPAR_TXD0_TXD0         (0x01)
#define MCF_GPIO_PUAPAR_RXD0_RXD0         (0x04)
#define MCF_GPIO_PUAPAR_RTS0_RTS0         (0x10)
#define MCF_GPIO_PUAPAR_CTS0_CTS0         (0x40)
#define MCF_GPIO_PUAPAR_RTS0_USB_VBUSD    (0x20)
#define MCF_GPIO_PUAPAR_CTS0_USB_VBUSE    (0x80)

/* Bit definitions and macros for MCF_GPIO_PUBPAR */
#define MCF_GPIO_PUBPAR_PUBPAR0(x)        (((x)&0x03)<<0)
#define MCF_GPIO_PUBPAR_PUBPAR1(x)        (((x)&0x03)<<2)
#define MCF_GPIO_PUBPAR_PUBPAR2(x)        (((x)&0x03)<<4)
#define MCF_GPIO_PUBPAR_PUBPAR3(x)        (((x)&0x03)<<6)
#define MCF_GPIO_PUBPAR_TXD1_GPIO         (0x00)
#define MCF_GPIO_PUBPAR_RXD1_GPIO         (0x00)
#define MCF_GPIO_PUBPAR_RTS1_GPIO         (0x00)
#define MCF_GPIO_PUBPAR_CTS1_GPIO         (0x00)
#define MCF_GPIO_PUBPAR_TXD1_TXD1         (0x01)
#define MCF_GPIO_PUBPAR_RXD1_RXD1         (0x04)
#define MCF_GPIO_PUBPAR_RTS1_RTS1         (0x10)
#define MCF_GPIO_PUBPAR_CTS1_CTS1         (0x40)
#define MCF_GPIO_PUBPAR_RTS1_SYNCB        (0x20)
#define MCF_GPIO_PUBPAR_CTS1_SYNCA        (0x80)
#define MCF_GPIO_PUBPAR_RTS1_TXD2         (0x30)
#define MCF_GPIO_PUBPAR_CTS1_RXD2         (0xC0)

/* Bit definitions and macros for MCF_GPIO_PUCPAR */
#define MCF_GPIO_PUCPAR_PUCPAR0           (0x01)
#define MCF_GPIO_PUCPAR_PUCPAR1           (0x02)
#define MCF_GPIO_PUCPAR_PUCPAR2           (0x04)
#define MCF_GPIO_PUCPAR_PUCPAR3           (0x08)
#define MCF_GPIO_PUCPAR_TXD2_GPIO         (0x00)
#define MCF_GPIO_PUCPAR_RXD2_GPIO         (0x00)
#define MCF_GPIO_PUCPAR_RTS2_GPIO         (0x00)
#define MCF_GPIO_PUCPAR_CTS2_GPIO         (0x00)
#define MCF_GPIO_PUCPAR_TXD2_TXD2         (0x01)
#define MCF_GPIO_PUCPAR_RXD2_RXD2         (0x04)
#define MCF_GPIO_PUCPAR_RTS2_RTS2         (0x10)
#define MCF_GPIO_PUCPAR_CTS2_CTS2         (0x40)
#define MCF_GPIO_PUCPAR_RTS2_USB_VBUSDIS  (0x02)
#define MCF_GPIO_PUCPAR_CTS2_USB_VBUSCHG  (0x08)

/* Bit definitions and macros for MCF_GPIO_PDDPAR */
#define MCF_GPIO_PDDPAR_PDDPAR0           (0x01)
#define MCF_GPIO_PDDPAR_PDDPAR1           (0x02)
#define MCF_GPIO_PDDPAR_PDDPAR2           (0x04)
#define MCF_GPIO_PDDPAR_PDDPAR3           (0x08)
#define MCF_GPIO_PDDPAR_PDDPAR4           (0x10)
#define MCF_GPIO_PDDPAR_PDDPAR5           (0x20)
#define MCF_GPIO_PDDPAR_PDDPAR6           (0x40)
#define MCF_GPIO_PDDPAR_PDDPAR7           (0x80)
#define MCF_GPIO_PDDPAR_PDD0_GPIO         (0x00)
#define MCF_GPIO_PDDPAR_PDD1_GPIO         (0x00)
#define MCF_GPIO_PDDPAR_PDD2_GPIO         (0x00)
#define MCF_GPIO_PDDPAR_PDD3_GPIO         (0x00)
#define MCF_GPIO_PDDPAR_PDD4_GPIO         (0x00)
#define MCF_GPIO_PDDPAR_PDD5_GPIO         (0x00)
#define MCF_GPIO_PDDPAR_PDD6_GPIO         (0x00)
#define MCF_GPIO_PDDPAR_PDD7_GPIO         (0x00)
#define MCF_GPIO_PDDPAR_PDD0_PST0         (0x01)
#define MCF_GPIO_PDDPAR_PDD1_PST1         (0x02)
#define MCF_GPIO_PDDPAR_PDD2_PST2         (0x04)
#define MCF_GPIO_PDDPAR_PDD3_PST3         (0x08)
#define MCF_GPIO_PDDPAR_PDD4_DDATA0       (0x10)
#define MCF_GPIO_PDDPAR_PDD5_DDATA1       (0x20)
#define MCF_GPIO_PDDPAR_PDD6_DDATA2       (0x40)
#define MCF_GPIO_PDDPAR_PDD7_DDATA3       (0x80)

/* Bit definitions and macros for MCF_GPIO_PSSR */
#define MCF_GPIO_PSSR_PSSR0               (0x00000001)
#define MCF_GPIO_PSSR_PSSR1               (0x00000002)
#define MCF_GPIO_PSSR_PSSR2               (0x00000004)
#define MCF_GPIO_PSSR_PSSR3               (0x00000008)
#define MCF_GPIO_PSSR_PSSR4               (0x00000010)
#define MCF_GPIO_PSSR_PSSR5               (0x00000020)
#define MCF_GPIO_PSSR_PSSR6               (0x00000040)
#define MCF_GPIO_PSSR_PSSR7               (0x00000080)
#define MCF_GPIO_PSSR_PSSR8               (0x00000100)
#define MCF_GPIO_PSSR_PSSR9               (0x00000200)
#define MCF_GPIO_PSSR_PSSR10              (0x00000400)
#define MCF_GPIO_PSSR_PSSR11              (0x00000800)
#define MCF_GPIO_PSSR_PSSR12              (0x00001000)
#define MCF_GPIO_PSSR_PSSR13              (0x00002000)
#define MCF_GPIO_PSSR_PSSR14              (0x00004000)
#define MCF_GPIO_PSSR_PSSR15              (0x00008000)
#define MCF_GPIO_PSSR_PSSR16              (0x00010000)
#define MCF_GPIO_PSSR_PSSR17              (0x00020000)
#define MCF_GPIO_PSSR_PSSR18              (0x00040000)
#define MCF_GPIO_PSSR_PSSR19              (0x00080000)
#define MCF_GPIO_PSSR_PSSR20              (0x00100000)
#define MCF_GPIO_PSSR_PSSR21              (0x00200000)
#define MCF_GPIO_PSSR_PSSR22              (0x00400000)
#define MCF_GPIO_PSSR_PSSR23              (0x00800000)
#define MCF_GPIO_PSSR_PSSR24              (0x01000000)
#define MCF_GPIO_PSSR_PSSR25              (0x02000000)
#define MCF_GPIO_PSSR_PDSR26              (0x04000000)
#define MCF_GPIO_PSSR_PSSR27              (0x08000000)
#define MCF_GPIO_PSSR_PSSR28              (0x10000000)
#define MCF_GPIO_PSSR_PSSR29              (0x20000000)
#define MCF_GPIO_PSSR_PSSR30              (0x40000000)
#define MCF_GPIO_PSSR_PSSR31              (0x80000000)

/* Bit definitions and macros for MCF_GPIO_PDSR */
#define MCF_GPIO_PDSR_PDSR0               (0x00000001)
#define MCF_GPIO_PDSR_PDSR1               (0x00000002)
#define MCF_GPIO_PDSR_PDSR2               (0x00000004)
#define MCF_GPIO_PDSR_PDSR3               (0x00000008)
#define MCF_GPIO_PDSR_PDSR4               (0x00000010)
#define MCF_GPIO_PDSR_PDSR5               (0x00000020)
#define MCF_GPIO_PDSR_PDSR6               (0x00000040)
#define MCF_GPIO_PDSR_PDSR7               (0x00000080)
#define MCF_GPIO_PDSR_PDSR8               (0x00000100)
#define MCF_GPIO_PDSR_PDSR9               (0x00000200)
#define MCF_GPIO_PDSR_PDSR10              (0x00000400)
#define MCF_GPIO_PDSR_PDSR11              (0x00000800)
#define MCF_GPIO_PDSR_PDSR12              (0x00001000)
#define MCF_GPIO_PDSR_PDSR13              (0x00002000)
#define MCF_GPIO_PDSR_PDSR14              (0x00004000)
#define MCF_GPIO_PDSR_PDSR15              (0x00008000)
#define MCF_GPIO_PDSR_PDSR16              (0x00010000)
#define MCF_GPIO_PDSR_PDSR17              (0x00020000)
#define MCF_GPIO_PDSR_PDSR18              (0x00040000)
#define MCF_GPIO_PDSR_PDSR19              (0x00080000)
#define MCF_GPIO_PDSR_PDSR20              (0x00100000)
#define MCF_GPIO_PDSR_PDSR21              (0x00200000)
#define MCF_GPIO_PDSR_PDSR22              (0x00400000)
#define MCF_GPIO_PDSR_PDSR23              (0x00800000)
#define MCF_GPIO_PDSR_PDSR24              (0x01000000)
#define MCF_GPIO_PDSR_PDSR25              (0x02000000)
#define MCF_GPIO_PDSR_PDSR26              (0x04000000)
#define MCF_GPIO_PDSR_PDSR27              (0x08000000)
#define MCF_GPIO_PDSR_PDSR28              (0x10000000)
#define MCF_GPIO_PDSR_PDSR29              (0x20000000)
#define MCF_GPIO_PDSR_PDSR30              (0x40000000)
#define MCF_GPIO_PDSR_PDSR31              (0x80000000)

/*********************************************************************
*
* I2C Module (I2C)
*
*********************************************************************/

/* Register read/write macros */
#define MCF_I2C_I2AR          (*(hcc_reg8 *)(&_IPSBAR[0x000300]))
#define MCF_I2C_I2FDR         (*(hcc_reg8 *)(&_IPSBAR[0x000304]))
#define MCF_I2C_I2CR          (*(hcc_reg8 *)(&_IPSBAR[0x000308]))
#define MCF_I2C_I2SR          (*(hcc_reg8 *)(&_IPSBAR[0x00030C]))
#define MCF_I2C_I2DR          (*(hcc_reg8 *)(&_IPSBAR[0x000310]))

/* Bit definitions and macros for MCF_I2C_I2AR */
#define MCF_I2C_I2AR_ADR(x)   (((x)&0x7F)<<1)

/* Bit definitions and macros for MCF_I2C_I2FDR */
#define MCF_I2C_I2FDR_IC(x)   (((x)&0x3F)<<0)

/* Bit definitions and macros for MCF_I2C_I2CR */
#define MCF_I2C_I2CR_RSTA     (0x04)
#define MCF_I2C_I2CR_TXAK     (0x08)
#define MCF_I2C_I2CR_MTX      (0x10)
#define MCF_I2C_I2CR_MSTA     (0x20)
#define MCF_I2C_I2CR_IIEN     (0x40)
#define MCF_I2C_I2CR_IEN      (0x80)

/* Bit definitions and macros for MCF_I2C_I2SR */
#define MCF_I2C_I2SR_RXAK     (0x01)
#define MCF_I2C_I2SR_IIF      (0x02)
#define MCF_I2C_I2SR_SRW      (0x04)
#define MCF_I2C_I2SR_IAL      (0x10)
#define MCF_I2C_I2SR_IBB      (0x20)
#define MCF_I2C_I2SR_IAAS     (0x40)
#define MCF_I2C_I2SR_ICF      (0x80)

/* Bit definitions and macros for MCF_I2C_I2DR */
#define MCF_I2C_I2DR_DATA(x)  (((x)&0xFF)<<0)

/*********************************************************************
*
* Edge Port Module (EPORT)
*
*********************************************************************/

/* Register read/write macros */
#define MCF_EPORT_EPPAR0                (*(hcc_reg16*)(&_IPSBAR[0x130000]))
#define MCF_EPORT_EPPAR1                (*(hcc_reg16*)(&_IPSBAR[0x140000]))
#define MCF_EPORT_EPDDR0                (*(hcc_reg8 *)(&_IPSBAR[0x130002]))
#define MCF_EPORT_EPDDR1                (*(hcc_reg8 *)(&_IPSBAR[0x140002]))
#define MCF_EPORT_EPIER0                (*(hcc_reg8 *)(&_IPSBAR[0x130003]))
#define MCF_EPORT_EPIER1                (*(hcc_reg8 *)(&_IPSBAR[0x140003]))
#define MCF_EPORT_EPDR0                 (*(hcc_reg8 *)(&_IPSBAR[0x130004]))
#define MCF_EPORT_EPDR1                 (*(hcc_reg8 *)(&_IPSBAR[0x140004]))
#define MCF_EPORT_EPPDR0                (*(hcc_reg8 *)(&_IPSBAR[0x130005]))
#define MCF_EPORT_EPPDR1                (*(hcc_reg8 *)(&_IPSBAR[0x140005]))
#define MCF_EPORT_EPFR0                 (*(hcc_reg8 *)(&_IPSBAR[0x130006]))
#define MCF_EPORT_EPFR1                 (*(hcc_reg8 *)(&_IPSBAR[0x140006]))

/* Bit definitions and macros for MCF_EPORT_EPPAR */
#define MCF_EPORT_EPPAR_EPPA1(x)        (((x)&0x0003)<<2)
#define MCF_EPORT_EPPAR_EPPA2(x)        (((x)&0x0003)<<4)
#define MCF_EPORT_EPPAR_EPPA3(x)        (((x)&0x0003)<<6)
#define MCF_EPORT_EPPAR_EPPA4(x)        (((x)&0x0003)<<8)
#define MCF_EPORT_EPPAR_EPPA5(x)        (((x)&0x0003)<<10)
#define MCF_EPORT_EPPAR_EPPA6(x)        (((x)&0x0003)<<12)
#define MCF_EPORT_EPPAR_EPPA7(x)        (((x)&0x0003)<<14)
#define MCF_EPORT_EPPAR_EPPA8(x)        (((x)&0x0003)<<0)
#define MCF_EPORT_EPPAR_EPPA9(x)        (((x)&0x0003)<<2)
#define MCF_EPORT_EPPAR_EPPA10(x)       (((x)&0x0003)<<4)
#define MCF_EPORT_EPPAR_EPPA11(x)       (((x)&0x0003)<<6)
#define MCF_EPORT_EPPAR_EPPA12(x)       (((x)&0x0003)<<8)
#define MCF_EPORT_EPPAR_EPPA13(x)       (((x)&0x0003)<<10)
#define MCF_EPORT_EPPAR_EPPA14(x)       (((x)&0x0003)<<12)
#define MCF_EPORT_EPPAR_EPPA15(x)       (((x)&0x0003)<<14)
#define MCF_EPORT_EPPAR_LEVEL           (0)
#define MCF_EPORT_EPPAR_RISING          (1)
#define MCF_EPORT_EPPAR_FALLING         (2)
#define MCF_EPORT_EPPAR_BOTH            (3)
#define MCF_EPORT_EPPAR_EPPA15_LEVEL    (0x0000)
#define MCF_EPORT_EPPAR_EPPA15_RISING   (0x4000)
#define MCF_EPORT_EPPAR_EPPA15_FALLING  (0x8000)
#define MCF_EPORT_EPPAR_EPPA15_BOTH     (0xC000)
#define MCF_EPORT_EPPAR_EPPA14_LEVEL    (0x0000)
#define MCF_EPORT_EPPAR_EPPA14_RISING   (0x1000)
#define MCF_EPORT_EPPAR_EPPA14_FALLING  (0x2000)
#define MCF_EPORT_EPPAR_EPPA14_BOTH     (0x3000)
#define MCF_EPORT_EPPAR_EPPA13_LEVEL    (0x0000)
#define MCF_EPORT_EPPAR_EPPA13_RISING   (0x0400)
#define MCF_EPORT_EPPAR_EPPA13_FALLING  (0x0800)
#define MCF_EPORT_EPPAR_EPPA13_BOTH     (0x0C00)
#define MCF_EPORT_EPPAR_EPPA12_LEVEL    (0x0000)
#define MCF_EPORT_EPPAR_EPPA12_RISING   (0x0100)
#define MCF_EPORT_EPPAR_EPPA12_FALLING  (0x0200)
#define MCF_EPORT_EPPAR_EPPA12_BOTH     (0x0300)
#define MCF_EPORT_EPPAR_EPPA11_LEVEL    (0x0000)
#define MCF_EPORT_EPPAR_EPPA11_RISING   (0x0040)
#define MCF_EPORT_EPPAR_EPPA11_FALLING  (0x0080)
#define MCF_EPORT_EPPAR_EPPA11_BOTH     (0x00C0)
#define MCF_EPORT_EPPAR_EPPA10_LEVEL    (0x0000)
#define MCF_EPORT_EPPAR_EPPA10_RISING   (0x0010)
#define MCF_EPORT_EPPAR_EPPA10_FALLING  (0x0020)
#define MCF_EPORT_EPPAR_EPPA10_BOTH     (0x0030)
#define MCF_EPORT_EPPAR_EPPA9_LEVEL     (0x0000)
#define MCF_EPORT_EPPAR_EPPA9_RISING    (0x0004)
#define MCF_EPORT_EPPAR_EPPA9_FALLING   (0x0008)
#define MCF_EPORT_EPPAR_EPPA9_BOTH      (0x000C)
#define MCF_EPORT_EPPAR_EPPA8_LEVEL     (0x0000)
#define MCF_EPORT_EPPAR_EPPA8_RISING    (0x0001)
#define MCF_EPORT_EPPAR_EPPA8_FALLING   (0x0002)
#define MCF_EPORT_EPPAR_EPPA8_BOTH      (0x0003)
#define MCF_EPORT_EPPAR_EPPA7_LEVEL     (0x0000)
#define MCF_EPORT_EPPAR_EPPA7_RISING    (0x4000)
#define MCF_EPORT_EPPAR_EPPA7_FALLING   (0x8000)
#define MCF_EPORT_EPPAR_EPPA7_BOTH      (0xC000)
#define MCF_EPORT_EPPAR_EPPA6_LEVEL     (0x0000)
#define MCF_EPORT_EPPAR_EPPA6_RISING    (0x1000)
#define MCF_EPORT_EPPAR_EPPA6_FALLING   (0x2000)
#define MCF_EPORT_EPPAR_EPPA6_BOTH      (0x3000)
#define MCF_EPORT_EPPAR_EPPA5_LEVEL     (0x0000)
#define MCF_EPORT_EPPAR_EPPA5_RISING    (0x0400)
#define MCF_EPORT_EPPAR_EPPA5_FALLING   (0x0800)
#define MCF_EPORT_EPPAR_EPPA5_BOTH      (0x0C00)
#define MCF_EPORT_EPPAR_EPPA4_LEVEL     (0x0000)
#define MCF_EPORT_EPPAR_EPPA4_RISING    (0x0100)
#define MCF_EPORT_EPPAR_EPPA4_FALLING   (0x0200)
#define MCF_EPORT_EPPAR_EPPA4_BOTH      (0x0300)
#define MCF_EPORT_EPPAR_EPPA3_LEVEL     (0x0000)
#define MCF_EPORT_EPPAR_EPPA3_RISING    (0x0040)
#define MCF_EPORT_EPPAR_EPPA3_FALLING   (0x0080)
#define MCF_EPORT_EPPAR_EPPA3_BOTH      (0x00C0)
#define MCF_EPORT_EPPAR_EPPA2_LEVEL     (0x0000)
#define MCF_EPORT_EPPAR_EPPA2_RISING    (0x0010)
#define MCF_EPORT_EPPAR_EPPA2_FALLING   (0x0020)
#define MCF_EPORT_EPPAR_EPPA2_BOTH      (0x0030)
#define MCF_EPORT_EPPAR_EPPA1_LEVEL     (0x0000)
#define MCF_EPORT_EPPAR_EPPA1_RISING    (0x0004)
#define MCF_EPORT_EPPAR_EPPA1_FALLING   (0x0008)
#define MCF_EPORT_EPPAR_EPPA1_BOTH      (0x000C)

/* Bit definitions and macros for MCF_EPORT_EPDDR */
#define MCF_EPORT_EPDDR_EPDD1           (0x02)
#define MCF_EPORT_EPDDR_EPDD2           (0x04)
#define MCF_EPORT_EPDDR_EPDD3           (0x08)
#define MCF_EPORT_EPDDR_EPDD4           (0x10)
#define MCF_EPORT_EPDDR_EPDD5           (0x20)
#define MCF_EPORT_EPDDR_EPDD6           (0x40)
#define MCF_EPORT_EPDDR_EPDD7           (0x80)
#define MCF_EPORT_EPDDR_EPDD8           (0x01)
#define MCF_EPORT_EPDDR_EPDD9           (0x02)
#define MCF_EPORT_EPDDR_EPDD10          (0x04)
#define MCF_EPORT_EPDDR_EPDD11          (0x08)
#define MCF_EPORT_EPDDR_EPDD12          (0x10)
#define MCF_EPORT_EPDDR_EPDD13          (0x20)
#define MCF_EPORT_EPDDR_EPDD14          (0x40)
#define MCF_EPORT_EPDDR_EPDD15          (0x80)

/* Bit definitions and macros for MCF_EPORT_EPIER */
#define MCF_EPORT_EPIER_EPIE1           (0x02)
#define MCF_EPORT_EPIER_EPIE2           (0x04)
#define MCF_EPORT_EPIER_EPIE3           (0x08)
#define MCF_EPORT_EPIER_EPIE4           (0x10)
#define MCF_EPORT_EPIER_EPIE5           (0x20)
#define MCF_EPORT_EPIER_EPIE6           (0x40)
#define MCF_EPORT_EPIER_EPIE7           (0x80)
#define MCF_EPORT_EPIER_EPIE8           (0x01)
#define MCF_EPORT_EPIER_EPIE9           (0x02)
#define MCF_EPORT_EPIER_EPIE10          (0x04)
#define MCF_EPORT_EPIER_EPIE11          (0x08)
#define MCF_EPORT_EPIER_EPIE12          (0x10)
#define MCF_EPORT_EPIER_EPIE13          (0x20)
#define MCF_EPORT_EPIER_EPIE14          (0x40)
#define MCF_EPORT_EPIER_EPIE15          (0x80)

/* Bit definitions and macros for MCF_EPORT_EPDR */
#define MCF_EPORT_EPDR_EPD1             (0x02)
#define MCF_EPORT_EPDR_EPD2             (0x04)
#define MCF_EPORT_EPDR_EPD3             (0x08)
#define MCF_EPORT_EPDR_EPD4             (0x10)
#define MCF_EPORT_EPDR_EPD5             (0x20)
#define MCF_EPORT_EPDR_EPD6             (0x40)
#define MCF_EPORT_EPDR_EPD7             (0x80)
#define MCF_EPORT_EPDR_EPD8             (0x01)
#define MCF_EPORT_EPDR_EPD9             (0x02)
#define MCF_EPORT_EPDR_EPD10            (0x04)
#define MCF_EPORT_EPDR_EPD11            (0x08)
#define MCF_EPORT_EPDR_EPD12            (0x10)
#define MCF_EPORT_EPDR_EPD13            (0x20)
#define MCF_EPORT_EPDR_EPD14            (0x40)
#define MCF_EPORT_EPDR_EPD15            (0x80)

/* Bit definitions and macros for MCF_EPORT_EPPDR */
#define MCF_EPORT_EPPDR_EPPD1           (0x02)
#define MCF_EPORT_EPPDR_EPPD2           (0x04)
#define MCF_EPORT_EPPDR_EPPD3           (0x08)
#define MCF_EPORT_EPPDR_EPPD4           (0x10)
#define MCF_EPORT_EPPDR_EPPD5           (0x20)
#define MCF_EPORT_EPPDR_EPPD6           (0x40)
#define MCF_EPORT_EPPDR_EPPD7           (0x80)
#define MCF_EPORT_EPPDR_EPPD8           (0x01)
#define MCF_EPORT_EPPDR_EPPD9           (0x02)
#define MCF_EPORT_EPPDR_EPPD10          (0x04)
#define MCF_EPORT_EPPDR_EPPD11          (0x08)
#define MCF_EPORT_EPPDR_EPPD12          (0x10)
#define MCF_EPORT_EPPDR_EPPD13          (0x20)
#define MCF_EPORT_EPPDR_EPPD14          (0x40)
#define MCF_EPORT_EPPDR_EPPD15          (0x80)

/* Bit definitions and macros for MCF_EPORT_EPFR */
#define MCF_EPORT_EPFR_EPF1             (0x02)
#define MCF_EPORT_EPFR_EPF2             (0x04)
#define MCF_EPORT_EPFR_EPF3             (0x08)
#define MCF_EPORT_EPFR_EPF4             (0x10)
#define MCF_EPORT_EPFR_EPF5             (0x20)
#define MCF_EPORT_EPFR_EPF6             (0x40)
#define MCF_EPORT_EPFR_EPF7             (0x80)
#define MCF_EPORT_EPFR_EPF8             (0x01)
#define MCF_EPORT_EPFR_EPF9             (0x02)
#define MCF_EPORT_EPFR_EPF10            (0x04)
#define MCF_EPORT_EPFR_EPF11            (0x08)
#define MCF_EPORT_EPFR_EPF12            (0x10)
#define MCF_EPORT_EPFR_EPF13            (0x20)
#define MCF_EPORT_EPFR_EPF14            (0x40)
#define MCF_EPORT_EPFR_EPF15            (0x80)

/*********************************************************************
*
* Universal Asynchronous Receiver Transmitter (UART)
*
*********************************************************************/

/* Register read/write macros */
#define MCF_UART0_UMR                 (*(hcc_reg8 *)(&_IPSBAR[0x000200]))
#define MCF_UART0_USR                 (*(hcc_reg8 *)(&_IPSBAR[0x000204]))
#define MCF_UART0_UCSR                (*(hcc_reg8 *)(&_IPSBAR[0x000204]))
#define MCF_UART0_UCR                 (*(hcc_reg8 *)(&_IPSBAR[0x000208]))
#define MCF_UART0_URB                 (*(hcc_reg8 *)(&_IPSBAR[0x00020C]))
#define MCF_UART0_UTB                 (*(hcc_reg8 *)(&_IPSBAR[0x00020C]))
#define MCF_UART0_UIPCR               (*(hcc_reg8 *)(&_IPSBAR[0x000210]))
#define MCF_UART0_UACR                (*(hcc_reg8 *)(&_IPSBAR[0x000210]))
#define MCF_UART0_UISR                (*(hcc_reg8 *)(&_IPSBAR[0x000214]))
#define MCF_UART0_UIMR                (*(hcc_reg8 *)(&_IPSBAR[0x000214]))
#define MCF_UART0_UBG1                (*(hcc_reg8 *)(&_IPSBAR[0x000218]))
#define MCF_UART0_UBG2                (*(hcc_reg8 *)(&_IPSBAR[0x00021C]))
#define MCF_UART0_UIP                 (*(hcc_reg8 *)(&_IPSBAR[0x000234]))
#define MCF_UART0_UOP1                (*(hcc_reg8 *)(&_IPSBAR[0x000238]))
#define MCF_UART0_UOP0                (*(hcc_reg8 *)(&_IPSBAR[0x00023C]))
#define MCF_UART1_UMR                 (*(hcc_reg8 *)(&_IPSBAR[0x000240]))
#define MCF_UART1_USR                 (*(hcc_reg8 *)(&_IPSBAR[0x000244]))
#define MCF_UART1_UCSR                (*(hcc_reg8 *)(&_IPSBAR[0x000244]))
#define MCF_UART1_UCR                 (*(hcc_reg8 *)(&_IPSBAR[0x000248]))
#define MCF_UART1_URB                 (*(hcc_reg8 *)(&_IPSBAR[0x00024C]))
#define MCF_UART1_UTB                 (*(hcc_reg8 *)(&_IPSBAR[0x00024C]))
#define MCF_UART1_UIPCR               (*(hcc_reg8 *)(&_IPSBAR[0x000250]))
#define MCF_UART1_UACR                (*(hcc_reg8 *)(&_IPSBAR[0x000250]))
#define MCF_UART1_UISR                (*(hcc_reg8 *)(&_IPSBAR[0x000254]))
#define MCF_UART1_UIMR                (*(hcc_reg8 *)(&_IPSBAR[0x000254]))
#define MCF_UART1_UBG1                (*(hcc_reg8 *)(&_IPSBAR[0x000258]))
#define MCF_UART1_UBG2                (*(hcc_reg8 *)(&_IPSBAR[0x00025C]))
#define MCF_UART1_UIP                 (*(hcc_reg8 *)(&_IPSBAR[0x000274]))
#define MCF_UART1_UOP1                (*(hcc_reg8 *)(&_IPSBAR[0x000278]))
#define MCF_UART1_UOP0                (*(hcc_reg8 *)(&_IPSBAR[0x00027C]))
#define MCF_UART2_UMR                 (*(hcc_reg8 *)(&_IPSBAR[0x000280]))
#define MCF_UART2_USR                 (*(hcc_reg8 *)(&_IPSBAR[0x000284]))
#define MCF_UART2_UCSR                (*(hcc_reg8 *)(&_IPSBAR[0x000284]))
#define MCF_UART2_UCR                 (*(hcc_reg8 *)(&_IPSBAR[0x000288]))
#define MCF_UART2_URB                 (*(hcc_reg8 *)(&_IPSBAR[0x00028C]))
#define MCF_UART2_UTB                 (*(hcc_reg8 *)(&_IPSBAR[0x00028C]))
#define MCF_UART2_UIPCR               (*(hcc_reg8 *)(&_IPSBAR[0x000290]))
#define MCF_UART2_UACR                (*(hcc_reg8 *)(&_IPSBAR[0x000290]))
#define MCF_UART2_UISR                (*(hcc_reg8 *)(&_IPSBAR[0x000294]))
#define MCF_UART2_UIMR                (*(hcc_reg8 *)(&_IPSBAR[0x000294]))
#define MCF_UART2_UBG1                (*(hcc_reg8 *)(&_IPSBAR[0x000298]))
#define MCF_UART2_UBG2                (*(hcc_reg8 *)(&_IPSBAR[0x00029C]))
#define MCF_UART2_UIP                 (*(hcc_reg8 *)(&_IPSBAR[0x0002B4]))
#define MCF_UART2_UOP1                (*(hcc_reg8 *)(&_IPSBAR[0x0002B8]))
#define MCF_UART2_UOP0                (*(hcc_reg8 *)(&_IPSBAR[0x0002BC]))
#define MCF_UART_UMR(x)               (*(hcc_reg8 *)(&_IPSBAR[0x000200+((x)*0x040)]))
#define MCF_UART_USR(x)               (*(hcc_reg8 *)(&_IPSBAR[0x000204+((x)*0x040)]))
#define MCF_UART_UCSR(x)              (*(hcc_reg8 *)(&_IPSBAR[0x000204+((x)*0x040)]))
#define MCF_UART_UCR(x)               (*(hcc_reg8 *)(&_IPSBAR[0x000208+((x)*0x040)]))
#define MCF_UART_URB(x)               (*(hcc_reg8 *)(&_IPSBAR[0x00020C+((x)*0x040)]))
#define MCF_UART_UTB(x)               (*(hcc_reg8 *)(&_IPSBAR[0x00020C+((x)*0x040)]))
#define MCF_UART_UIPCR(x)             (*(hcc_reg8 *)(&_IPSBAR[0x000210+((x)*0x040)]))
#define MCF_UART_UACR(x)              (*(hcc_reg8 *)(&_IPSBAR[0x000210+((x)*0x040)]))
#define MCF_UART_UISR(x)              (*(hcc_reg8 *)(&_IPSBAR[0x000214+((x)*0x040)]))
#define MCF_UART_UIMR(x)              (*(hcc_reg8 *)(&_IPSBAR[0x000214+((x)*0x040)]))
#define MCF_UART_UBG1(x)              (*(hcc_reg8 *)(&_IPSBAR[0x000218+((x)*0x040)]))
#define MCF_UART_UBG2(x)              (*(hcc_reg8 *)(&_IPSBAR[0x00021C+((x)*0x040)]))
#define MCF_UART_UIP(x)               (*(hcc_reg8 *)(&_IPSBAR[0x000234+((x)*0x040)]))
#define MCF_UART_UOP1(x)              (*(hcc_reg8 *)(&_IPSBAR[0x000238+((x)*0x040)]))
#define MCF_UART_UOP0(x)              (*(hcc_reg8 *)(&_IPSBAR[0x00023C+((x)*0x040)]))

/* Bit definitions and macros for MCF_UART_UMR */
#define MCF_UART_UMR_BC(x)            (((x)&0x03)<<0)
#define MCF_UART_UMR_PT               (0x04)
#define MCF_UART_UMR_PM(x)            (((x)&0x03)<<3)
#define MCF_UART_UMR_ERR              (0x20)
#define MCF_UART_UMR_RXIRQ            (0x40)
#define MCF_UART_UMR_RXRTS            (0x80)
#define MCF_UART_UMR_SB(x)            (((x)&0x0F)<<0)
#define MCF_UART_UMR_TXCTS            (0x10)
#define MCF_UART_UMR_TXRTS            (0x20)
#define MCF_UART_UMR_CM(x)            (((x)&0x03)<<6)
#define MCF_UART_UMR_PM_MULTI_ADDR    (0x1C)
#define MCF_UART_UMR_PM_MULTI_DATA    (0x18)
#define MCF_UART_UMR_PM_NONE          (0x10)
#define MCF_UART_UMR_PM_FORCE_HI      (0x0C)
#define MCF_UART_UMR_PM_FORCE_LO      (0x08)
#define MCF_UART_UMR_PM_ODD           (0x04)
#define MCF_UART_UMR_PM_EVEN          (0x00)
#define MCF_UART_UMR_BC_5             (0x00)
#define MCF_UART_UMR_BC_6             (0x01)
#define MCF_UART_UMR_BC_7             (0x02)
#define MCF_UART_UMR_BC_8             (0x03)
#define MCF_UART_UMR_CM_NORMAL        (0x00)
#define MCF_UART_UMR_CM_ECHO          (0x40)
#define MCF_UART_UMR_CM_LOCAL_LOOP    (0x80)
#define MCF_UART_UMR_CM_REMOTE_LOOP   (0xC0)
#define MCF_UART_UMR_SB_STOP_BITS_1   (0x07)
#define MCF_UART_UMR_SB_STOP_BITS_15  (0x08)
#define MCF_UART_UMR_SB_STOP_BITS_2   (0x0F)

/* Bit definitions and macros for MCF_UART_USR */
#define MCF_UART_USR_RXRDY            (0x01)
#define MCF_UART_USR_FFULL            (0x02)
#define MCF_UART_USR_TXRDY            (0x04)
#define MCF_UART_USR_TXEMP            (0x08)
#define MCF_UART_USR_OE               (0x10)
#define MCF_UART_USR_PE               (0x20)
#define MCF_UART_USR_FE               (0x40)
#define MCF_UART_USR_RB               (0x80)

/* Bit definitions and macros for MCF_UART_UCSR */
#define MCF_UART_UCSR_TCS(x)          (((x)&0x0F)<<0)
#define MCF_UART_UCSR_RCS(x)          (((x)&0x0F)<<4)
#define MCF_UART_UCSR_RCS_SYS_CLK     (0xD0)
#define MCF_UART_UCSR_RCS_CTM16       (0xE0)
#define MCF_UART_UCSR_RCS_CTM         (0xF0)
#define MCF_UART_UCSR_TCS_SYS_CLK     (0x0D)
#define MCF_UART_UCSR_TCS_CTM16       (0x0E)
#define MCF_UART_UCSR_TCS_CTM         (0x0F)

/* Bit definitions and macros for MCF_UART_UCR */
#define MCF_UART_UCR_RXC(x)           (((x)&0x03)<<0)
#define MCF_UART_UCR_TXC(x)           (((x)&0x03)<<2)
#define MCF_UART_UCR_MISC(x)          (((x)&0x07)<<4)
#define MCF_UART_UCR_NONE             (0x00)
#define MCF_UART_UCR_STOP_BREAK       (0x70)
#define MCF_UART_UCR_START_BREAK      (0x60)
#define MCF_UART_UCR_BKCHGINT         (0x50)
#define MCF_UART_UCR_RESET_ERROR      (0x40)
#define MCF_UART_UCR_RESET_TX         (0x30)
#define MCF_UART_UCR_RESET_RX         (0x20)
#define MCF_UART_UCR_RESET_MR         (0x10)
#define MCF_UART_UCR_TX_DISABLED      (0x08)
#define MCF_UART_UCR_TX_ENABLED       (0x04)
#define MCF_UART_UCR_RX_DISABLED      (0x02)
#define MCF_UART_UCR_RX_ENABLED       (0x01)

/* Bit definitions and macros for MCF_UART_UIPCR */
#define MCF_UART_UIPCR_CTS            (0x01)
#define MCF_UART_UIPCR_COS            (0x10)

/* Bit definitions and macros for MCF_UART_UACR */
#define MCF_UART_UACR_IEC             (0x01)

/* Bit definitions and macros for MCF_UART_UISR */
#define MCF_UART_UISR_TXRDY           (0x01)
#define MCF_UART_UISR_RXRDY_FU        (0x02)
#define MCF_UART_UISR_DB              (0x04)
#define MCF_UART_UISR_RXFTO           (0x08)
#define MCF_UART_UISR_TXFIFO          (0x10)
#define MCF_UART_UISR_RXFIFO          (0x20)
#define MCF_UART_UISR_COS             (0x80)

/* Bit definitions and macros for MCF_UART_UIMR */
#define MCF_UART_UIMR_TXRDY           (0x01)
#define MCF_UART_UIMR_RXRDY_FU        (0x02)
#define MCF_UART_UIMR_DB              (0x04)
#define MCF_UART_UIMR_COS             (0x80)

/* Bit definitions and macros for MCF_UART_UIP */
#define MCF_UART_UIP_CTS              (0x01)

/* Bit definitions and macros for MCF_UART_UOP1 */
#define MCF_UART_UOP1_RTS             (0x01)

/* Bit definitions and macros for MCF_UART_UOP0 */
#define MCF_UART_UOP0_RTS             (0x01)

/*********************************************************************
*
* ColdFire Integration Module (CIM)
*
*********************************************************************/

/* Register read/write macros */
#define MCF_CIM_RCR             (*(hcc_reg8 *)(&_IPSBAR[0x110000]))
#define MCF_CIM_RSR             (*(hcc_reg8 *)(&_IPSBAR[0x110001]))
#define MCF_CIM_CCR             (*(hcc_reg16*)(&_IPSBAR[0x110004]))
#define MCF_CIM_LPCR            (*(hcc_reg8 *)(&_IPSBAR[0x110007]))
#define MCF_CIM_RCON            (*(hcc_reg16*)(&_IPSBAR[0x110008]))
#define MCF_CIM_CIR             (*(hcc_reg16*)(&_IPSBAR[0x11000A]))

/* Bit definitions and macros for MCF_CIM_RCR */
#define MCF_CIM_RCR_LVDE        (0x01)
#define MCF_CIM_RCR_LVDRE       (0x04)
#define MCF_CIM_RCR_LVDIE       (0x08)
#define MCF_CIM_RCR_LVDF        (0x10)
#define MCF_CIM_RCR_FRCRSTOUT   (0x40)
#define MCF_CIM_RCR_SOFTRST     (0x80)

/* Bit definitions and macros for MCF_CIM_RSR */
#define MCF_CIM_RSR_LOL         (0x01)
#define MCF_CIM_RSR_LOC         (0x02)
#define MCF_CIM_RSR_EXT         (0x04)
#define MCF_CIM_RSR_POR         (0x08)
#define MCF_CIM_RSR_WDR         (0x10)
#define MCF_CIM_RSR_SOFT        (0x20)
#define MCF_CIM_RSR_LVD         (0x40)

/* Bit definitions and macros for MCF_CIM_CCR */
#define MCF_CIM_CCR_LOAD        (0x8000)

/* Bit definitions and macros for MCF_CIM_LPCR */
#define MCF_CIM_LPCR_LVDSE      (0x02)
#define MCF_CIM_LPCR_STPMD(x)   (((x)&0x03)<<3)
#define MCF_CIM_LPCR_LPMD(x)    (((x)&0x03)<<6)
#define MCF_CIM_LPCR_LPMD_STOP  (0xC0)
#define MCF_CIM_LPCR_LPMD_WAIT  (0x80)
#define MCF_CIM_LPCR_LPMD_DOZE  (0x40)
#define MCF_CIM_LPCR_LPMD_RUN   (0x00)

/* Bit definitions and macros for MCF_CIM_RCON */
#define MCF_CIM_RCON_RLOAD      (0x0020)

/*********************************************************************
*
* ColdFire Flash Module (CFM)
*
*********************************************************************/

/* Register read/write macros */
#define MCF_CFM_CFMMCR           (*(hcc_reg16*)(_IPSBAR+0x1D0000))
#define MCF_CFM_CFMCLKD          (*(hcc_reg8 *)(_IPSBAR+0x1D0002))
#define MCF_CFM_CFMSEC           (*(hcc_reg32*)(_IPSBAR+0x1D0008))
#define MCF_CFM_CFMPROT          (*(hcc_reg32*)(_IPSBAR+0x1D0010))
#define MCF_CFM_CFMSACC          (*(hcc_reg32*)(_IPSBAR+0x1D0014))
#define MCF_CFM_CFMDACC          (*(hcc_reg32*)(_IPSBAR+0x1D0018))
#define MCF_CFM_CFMUSTAT         (*(hcc_reg8 *)(_IPSBAR+0x1D0020))
#define MCF_CFM_CFMCMD           (*(hcc_reg8 *)(_IPSBAR+0x1D0024))

/* Bit definitions and macros for MCF_CFM_CFMMCR */
#define MCF_CFM_CFMMCR_KEYACC    (0x0020)
#define MCF_CFM_CFMMCR_CCIE      (0x0040)
#define MCF_CFM_CFMMCR_CBEIE     (0x0080)
#define MCF_CFM_CFMMCR_AEIE      (0x0100)
#define MCF_CFM_CFMMCR_PVIE      (0x0200)
#define MCF_CFM_CFMMCR_LOCK      (0x0400)

/* Bit definitions and macros for MCF_CFM_CFMCLKD */
#define MCF_CFM_CFMCLKD_DIV(x)   (((x)&0x3F)<<0)
#define MCF_CFM_CFMCLKD_PRDIV8   (0x40)
#define MCF_CFM_CFMCLKD_DIVLD    (0x80)

/* Bit definitions and macros for MCF_CFM_CFMSEC */
#define MCF_CFM_CFMSEC_SEC(x)    (((x)&0x0000FFFF)<<0)
#define MCF_CFM_CFMSEC_SECSTAT   (0x40000000)
#define MCF_CFM_CFMSEC_KEYEN     (0x80000000)

/* Bit definitions and macros for MCF_CFM_CFMUSTAT */
#define MCF_CFM_CFMUSTAT_BLANK   (0x04)
#define MCF_CFM_CFMUSTAT_ACCERR  (0x10)
#define MCF_CFM_CFMUSTAT_PVIOL   (0x20)
#define MCF_CFM_CFMUSTAT_CCIF    (0x40)
#define MCF_CFM_CFMUSTAT_CBEIF   (0x80)

/* Bit definitions and macros for MCF_CFM_CFMCMD */
#define MCF_CFM_CFMCMD_CMD(x)    (((x)&0x7F)<<0)
#define MCF_CFM_CFMCMD_RDARY1    (0x05)
#define MCF_CFM_CFMCMD_PGM       (0x20)
#define MCF_CFM_CFMCMD_PGERS     (0x40)
#define MCF_CFM_CFMCMD_MASERS    (0x41)
#define MCF_CFM_CFMCMD_PGERSVER  (0x06)

/*********************************************************************
*
* Programmable Interrupt Timer Modules (PIT)
*
*********************************************************************/

/* Register read/write macros */
#define MCF_PIT0_PCSR        (*(hcc_reg16*)(&_IPSBAR[0x150000]))
#define MCF_PIT0_PMR         (*(hcc_reg16*)(&_IPSBAR[0x150002]))
#define MCF_PIT0_PCNTR       (*(hcc_reg16*)(&_IPSBAR[0x150004]))
#define MCF_PIT1_PCSR        (*(hcc_reg16*)(&_IPSBAR[0x160000]))
#define MCF_PIT1_PMR         (*(hcc_reg16*)(&_IPSBAR[0x160002]))
#define MCF_PIT1_PCNTR       (*(hcc_reg16*)(&_IPSBAR[0x160004]))
#define MCF_PIT_PCSR(x)      (*(hcc_reg16*)(&_IPSBAR[0x150000+((x)*0x10000)]))
#define MCF_PIT_PMR(x)       (*(hcc_reg16*)(&_IPSBAR[0x150002+((x)*0x10000)]))
#define MCF_PIT_PCNTR(x)     (*(hcc_reg16*)(&_IPSBAR[0x150004+((x)*0x10000)]))

/* Bit definitions and macros for MCF_PIT_PCSR */
#define MCF_PIT_PCSR_EN      (0x0001)
#define MCF_PIT_PCSR_RLD     (0x0002)
#define MCF_PIT_PCSR_PIF     (0x0004)
#define MCF_PIT_PCSR_PIE     (0x0008)
#define MCF_PIT_PCSR_OVW     (0x0010)
#define MCF_PIT_PCSR_HALTED  (0x0020)
#define MCF_PIT_PCSR_DOZE    (0x0040)
#define MCF_PIT_PCSR_PRE(x)  (((x)&0x000F)<<8)

/* Bit definitions and macros for MCF_PIT_PMR */
#define MCF_PIT_PMR_PM(x)    (((x)&0xFFFF)<<0)

/* Bit definitions and macros for MCF_PIT_PCNTR */
#define MCF_PIT_PCNTR_PC(x)  (((x)&0xFFFF)<<0)

#endif
/****************************** END OF FILE **********************************/
%endif
%-*****************************************************************************************************
%FILE %'DirRel_Code'host_hid_kbd.h
%-*****************************************************************************************************
/***************************************************************************
 *
 *            Copyright (c) 2006-2007 by CMX Systems, Inc.
 *
 * This software is copyrighted by and is the sole property of
 * CMX.  All rights, title, ownership, or other interests
 * in the software remain the property of CMX.  This
 * software may only be used in accordance with the corresponding
 * license agreement.  Any unauthorized use, duplication, transmission,
 * distribution, or disclosure of this software is expressly forbidden.
 *
 * This Copyright notice may not be removed or modified without prior
 * written consent of CMX.
 *
 * CMX reserves the right to modify this software without notice.
 *
 * CMX Systems, Inc.
 * 12276 San Jose Blvd. #511
 * Jacksonville, FL 32223
 * USA
 *
 * Tel:  (904) 880-1840
 * Fax:  (904) 880-1632
 * http: www.cmx.com
 * email: cmx@cmx.com
 *
 ***************************************************************************/
#ifndef _HOST_HID_KBD_H_
#define _HOST_HID_KBD_H_

#define KEY_NONE                               0x00
#define KEY_ERRORROLLOVER                      0x01
#define KEY_POSTFAIL                           0x02
#define KEY_ERRORUNDEFINED                     0x03
#define KEY_A                                  0x04
#define KEY_B                                  0x05
#define KEY_C                                  0x06
#define KEY_D                                  0x07
#define KEY_E                                  0x08
#define KEY_F                                  0x09
#define KEY_G                                  0x0A
#define KEY_H                                  0x0B
#define KEY_I                                  0x0C
#define KEY_J                                  0x0D
#define KEY_K                                  0x0E
#define KEY_L                                  0x0F
#define KEY_M                                  0x10
#define KEY_N                                  0x11
#define KEY_O                                  0x12
#define KEY_P                                  0x13
#define KEY_Q                                  0x14
#define KEY_R                                  0x15
#define KEY_S                                  0x16
#define KEY_T                                  0x17
#define KEY_U                                  0x18
#define KEY_V                                  0x19
#define KEY_W                                  0x1A
#define KEY_X                                  0x1B
#define KEY_Y                                  0x1C
#define KEY_Z                                  0x1D
#define KEY_1_EXCLAMATION_MARK                 0x1E
#define KEY_2_AT                               0x1F
#define KEY_3_NUMBER_SIGN                      0x20
#define KEY_4_DOLLAR                           0x21
#define KEY_5_PERCENT                          0x22
#define KEY_6_CARET                            0x23
#define KEY_7_AMPERSAND                        0x24
#define KEY_8_ASTERISK                         0x25
#define KEY_9_OPARENTHESIS                     0x26
#define KEY_0_CPARENTHESIS                     0x27
#define KEY_ENTER                              0x28
#define KEY_ESCAPE                             0x29
#define KEY_BACKSPACE                          0x2A
#define KEY_TAB                                0x2B
#define KEY_SPACEBAR                           0x2C
#define KEY_MINUS_UNDERSCORE                   0x2D
#define KEY_EQUAL_PLUS                         0x2E
#define KEY_OBRACKET_AND_OBRACE                0x2F
#define KEY_CBRACKET_AND_CBRACE                0x30
#define KEY_BACKSLASH_VERTICAL_BAR             0x31
#define KEY_NONUS_NUMBER_SIGN_TILDE            0x32
#define KEY_SEMICOLON_COLON                    0x33
#define KEY_SINGLE_AND_DOUBLE_QUOTE            0x34
#define KEY_GRAVE ACCENT AND TILDE             0x35
#define KEY_COMMA_AND_LESS                     0x36
#define KEY_DOT_GREATER                        0x37
#define KEY_SLASH_QUESTION                     0x38
#define KEY_CAPS LOCK                          0x39
#define KEY_F1                                 0x3A
#define KEY_F2                                 0x3B
#define KEY_F3                                 0x3C
#define KEY_F4                                 0x3D
#define KEY_F5                                 0x3E
#define KEY_F6                                 0x3F
#define KEY_F7                                 0x40
#define KEY_F8                                 0x41
#define KEY_F9                                 0x42
#define KEY_F10                                0x43
#define KEY_F11                                0x44
#define KEY_F12                                0x45
#define KEY_PRINTSCREEN                        0x46
#define KEY_SCROLL LOCK                        0x47
#define KEY_PAUSE                              0x48
#define KEY_INSERT                             0x49
#define KEY_HOME                               0x4A
#define KEY_PAGEUP                             0x4B
#define KEY_DELETE                             0x4C
#define KEY_END1                               0x4D
#define KEY_PAGEDOWN                           0x4E
#define KEY_RIGHTARROW                         0x4F
#define KEY_LEFTARROW                          0x50
#define KEY_DOWNARROW                          0x51
#define KEY_UPARROW                            0x52
#define KEY_KEYPAD_NUM_LOCK_AND_CLEAR          0x53
#define KEY_KEYPAD_SLASH                       0x54
#define KEY_KEYPAD_ASTERIKS                    0x55
#define KEY_KEYPAD_MINUS                       0x56
#define KEY_KEYPAD_PLUS                        0x57
#define KEY_KEYPAD_ENTER                       0x58
#define KEY_KEYPAD_1_END                       0x59
#define KEY_KEYPAD_2_DOWN_ARROW                0x5A
#define KEY_KEYPAD_3_PAGEDN                    0x5B
#define KEY_KEYPAD_4_LEFT_ARROW                0x5C
#define KEY_KEYPAD_5                           0x5D
#define KEY_KEYPAD_6_RIGHT_ARROW               0x5E
#define KEY_KEYPAD_7_HOME                      0x5F
#define KEY_KEYPAD_8_UP_ARROW                  0x60
#define KEY_KEYPAD_9_PAGEUP                    0x61
#define KEY_KEYPAD_0_INSERT                    0x62
#define KEY_KEYPAD_DECIMAL_SEPARATOR_DELETE    0x63
#define KEY_NONUS_BACK_SLASH_VERTICAL_BAR      0x64
#define KEY_APPLICATION                        0x65
#define KEY_POWER                              0x66
#define KEY_KEYPAD_EQUAL                       0x67
#define KEY_F13                                0x68
#define KEY_F14                                0x69
#define KEY_F15                                0x6A
#define KEY_F16                                0x6B
#define KEY_F17                                0x6C
#define KEY_F18                                0x6D
#define KEY_F19                                0x6E
#define KEY_F20                                0x6F
#define KEY_F21                                0x70
#define KEY_F22                                0x71
#define KEY_F23                                0x72
#define KEY_F24                                0x73
#define KEY_EXECUTE                            0x74
#define KEY_HELP                               0x75
#define KEY_MENU                               0x76
#define KEY_SELECT                             0x77
#define KEY_STOP                               0x78
#define KEY_AGAIN                              0x79
#define KEY_UNDO                               0x7A
#define KEY_CUT                                0x7B
#define KEY_COPY                               0x7C
#define KEY_PASTE                              0x7D
#define KEY_FIND                               0x7E
#define KEY_MUTE                               0x7F
#define KEY_VOLUME_UP                          0x80
#define KEY_VOLUME_DOWN                        0x81
#define KEY_LOCKING_CAPS_LOCK                  0x82
#define KEY_LOCKING_NUM_LOCK                   0x83
#define KEY_LOCKING_SCROLL_LOCK                0x84
#define KEY_KEYPAD_COMMA                       0x85
#define KEY_KEYPAD_EQUAL_SIGN                  0x86
#define KEY_INTERNATIONAL1                     0x87
#define KEY_INTERNATIONAL2                     0x88
#define KEY_INTERNATIONAL3                     0x89
#define KEY_INTERNATIONAL4                     0x8A
#define KEY_INTERNATIONAL5                     0x8B
#define KEY_INTERNATIONAL6                     0x8C
#define KEY_INTERNATIONAL7                     0x8D
#define KEY_INTERNATIONAL8                     0x8E
#define KEY_INTERNATIONAL9                     0x8F
#define KEY_LANG1                              0x90
#define KEY_LANG2                              0x91
#define KEY_LANG3                              0x92
#define KEY_LANG4                              0x93
#define KEY_LANG5                              0x94
#define KEY_LANG6                              0x95
#define KEY_LANG7                              0x96
#define KEY_LANG8                              0x97
#define KEY_LANG9                              0x98
#define KEY_ALTERNATE_ERASE                    0x99
#define KEY_SYSREQ                             0x9A
#define KEY_CANCEL                             0x9B
#define KEY_CLEAR                              0x9C
#define KEY_PRIOR                              0x9D
#define KEY_RETURN                             0x9E
#define KEY_SEPARATOR                          0x9F
#define KEY_OUT                                0xA0
#define KEY_OPER                               0xA1
#define KEY_CLEAR_AGAIN                        0xA2
#define KEY_CRSEL                              0xA3
#define KEY_EXSEL                              0xA4
#define KEY_KEYPAD_00                          0xB0
#define KEY_KEYPAD_000                         0xB1
#define KEY_THOUSANDS_SEPARATOR                0xB2
#define KEY_DECIMAL_SEPARATOR                  0xB3
#define KEY_CURRENCY_UNIT                      0xB4
#define KEY_CURRENCY_SUB_UNIT                  0xB5
#define KEY_KEYPAD_OPARENTHESIS                0xB6
#define KEY_KEYPAD_CPARENTHESIS                0xB7
#define KEY_KEYPAD_OBRACE                      0xB8
#define KEY_KEYPAD_CBRACE                      0xB9
#define KEY_KEYPAD_TAB                         0xBA
#define KEY_KEYPAD_BACKSPACE                   0xBB
#define KEY_KEYPAD_A                           0xBC
#define KEY_KEYPAD_B                           0xBD
#define KEY_KEYPAD_C                           0xBE
#define KEY_KEYPAD_D                           0xBF
#define KEY_KEYPAD_E                           0xC0
#define KEY_KEYPAD_F                           0xC1
#define KEY_KEYPAD_XOR                         0xC2
#define KEY_KEYPAD_CARET                       0xC3
#define KEY_KEYPAD_PERCENT                     0xC4
#define KEY_KEYPAD_LESS                        0xC5
#define KEY_KEYPAD_GREATER                     0xC6
#define KEY_KEYPAD_AMPERSAND                   0xC7
#define KEY_KEYPAD_LOGICAL_AND                 0xC8
#define KEY_KEYPAD_VERTICAL_BAR                0xC9
#define KEY_KEYPAD_LOGIACL_OR                  0xCA
#define KEY_KEYPAD_COLON                       0xCB
#define KEY_KEYPAD_NUMBER_SIGN                 0xCC
#define KEY_KEYPAD_SPACE                       0xCD
#define KEY_KEYPAD_AT                          0xCE
#define KEY_KEYPAD_EXCLAMATION_MARK            0xCF
#define KEY_KEYPAD_MEMORY_STORE                0xD0
#define KEY_KEYPAD_MEMORY_RECALL               0xD1
#define KEY_KEYPAD_MEMORY_CLEAR                0xD2
#define KEY_KEYPAD_MEMORY_ADD                  0xD3
#define KEY_KEYPAD_MEMORY_SUBTRACT             0xD4
#define KEY_KEYPAD_MEMORY_MULTIPLY             0xD5
#define KEY_KEYPAD_MEMORY_DIVIDE               0xD6
#define KEY_KEYPAD_PLUSMINUS                   0xD7
#define KEY_KEYPAD_CLEAR                       0xD8
#define KEY_KEYPAD_CLEAR_ENTRY                 0xD9
#define KEY_KEYPAD_BINARY                      0xDA
#define KEY_KEYPAD_OCTAL                       0xDB
#define KEY_KEYPAD_DECIMAL                     0xDC
#define KEY_KEYPAD_HEXADECIMAL                 0xDD
#define KEY_LEFTCONTROL                        0xE0
#define KEY_LEFTSHIFT                          0xE1
#define KEY_LEFTALT                            0xE2
#define KEY_LEFT_GUI                           0xE3
#define KEY_RIGHTCONTROL                       0xE4
#define KEY_RIGHTSHIFT                         0xE5
#define KEY_RIGHTALT                           0xE6
#define KEY_RIGHT_GUI                          0xE7


void hid_kbd_init(void);
void hid_kbd_set_leds(hcc_u8 num, hcc_u8 caps, hcc_u8 scroll, hcc_u8 compo, hcc_u8 kana);
int hid_kbd_process(void);
hcc_u8 hid_kbd_get_lshift(void);
hcc_u8 hid_kbd_get_rshift(void);
hcc_u8 hid_kbd_get_ralt(void);
hcc_u8 hid_kbd_get_lalt(void);
hcc_u8 hid_kbd_get_rctrl(void);
hcc_u8 hid_kbd_get_lctrl(void);
hcc_u8 hid_kbd_get_rgui(void);
hcc_u8 hid_kbd_get_lgui(void);
hcc_u8 hid_kbd_get_nkey(void);
hcc_u8 hid_kbd_get_key(hcc_u8 ndx);

#endif
/****************************** END OF FILE **********************************/
%-*****************************************************************************************************
%FILE %'DirRel_Code'host_hid_kbd.c
%-*****************************************************************************************************
/***************************************************************************
 *
 *            Copyright (c) 2006-2007 by CMX Systems, Inc.
 *
 * This software is copyrighted by and is the sole property of
 * CMX.  All rights, title, ownership, or other interests
 * in the software remain the property of CMX.  This
 * software may only be used in accordance with the corresponding
 * license agreement.  Any unauthorized use, duplication, transmission,
 * distribution, or disclosure of this software is expressly forbidden.
 *
 * This Copyright notice may not be removed or modified without prior
 * written consent of CMX.
 *
 * CMX reserves the right to modify this software without notice.
 *
 * CMX Systems, Inc.
 * 12276 San Jose Blvd. #511
 * Jacksonville, FL 32223
 * USA
 *
 * Tel:  (904) 880-1840
 * Fax:  (904) 880-1632
 * http: www.cmx.com
 * email: cmx@cmx.com
 *
 ***************************************************************************/
//#include "target.h"
#include "usb_host.h"
#include "usb_utils.h"
#include "hid_usage.h"
#include "host_hid.h"
#include "host_hid_kbd.h"
#include "hid_parser.h"
/*****************************************************************************
 * External references.
 *****************************************************************************/
/* none */
/*****************************************************************************
 * Local types.
 *****************************************************************************/
/* none */
/*****************************************************************************
 * Macro definitions.
 *****************************************************************************/
/* KBD states */
#define HKST_INVALID    0u
#define HKST_ACTIVE     1u
/*****************************************************************************
 * Module variables.
 *****************************************************************************/
struct {
  hcc_u8 state;
  hcc_u8 lctrl;
  hcc_u8 lshift;
  hcc_u8 lalt;
  hcc_u8 lgui;
  hcc_u8 rctrl;
  hcc_u8 rshift;
  hcc_u8 ralt;
  hcc_u8 rgui;
  hcc_u8 keys[6];
  hcc_u8 in_report_data[8];
  hcc_u8 out_report_data[1];
} static hid_kbd_info;
static const rp_item_t imp_0_lctrl={
  hid_kbd_info.in_report_data+0, /*data*/
  1,     /*size*/
  0,     /*shift*/
  0,     /*count (only for array items)*/
  0,     /*signed?*/
  0,     /*min value read can return*/
  1,     /*max value read can return*/
  0,     /*min vale device can report*/
  1,     /*max value device can report*/
  1      /*resolution*/
};
static const rp_item_t imp_0_lshift={
  hid_kbd_info.in_report_data+0, /*data*/
  1,     /*size*/
  1,     /*shift*/
  0,     /*count (only for array items)*/
  0,     /*signed?*/
  0,     /*min value read can return*/
  1,     /*max value read can return*/
  0,     /*min vale device can report*/
  1,     /*max value device can report*/
  1      /*resolution*/
};
static const rp_item_t imp_0_lalt={
  hid_kbd_info.in_report_data+0, /*data*/
  1,     /*size*/
  2,     /*shift*/
  0,     /*count (only for array items)*/
  0,     /*signed?*/
  0,     /*min value read can return*/
  1,     /*max value read can return*/
  0,     /*min vale device can report*/
  1,     /*max value device can report*/
  1      /*resolution*/
};
static const rp_item_t imp_0_lgui={
  hid_kbd_info.in_report_data+0, /*data*/
  1,     /*size*/
  3,     /*shift*/
  0,     /*count (only for array items)*/
  0,     /*signed?*/
  0,     /*min value read can return*/
  1,     /*max value read can return*/
  0,     /*min vale device can report*/
  1,     /*max value device can report*/
  1      /*resolution*/
};
static const rp_item_t imp_0_rctrl={
  hid_kbd_info.in_report_data+0, /*data*/
  1,     /*size*/
  4,     /*shift*/
  0,     /*count (only for array items)*/
  0,     /*signed?*/
  0,     /*min value read can return*/
  1,     /*max value read can return*/
  0,     /*min vale device can report*/
  1,     /*max value device can report*/
  1      /*resolution*/
};
static const rp_item_t imp_0_rshift={
  hid_kbd_info.in_report_data+0, /*data*/
  1,     /*size*/
  5,     /*shift*/
  0,     /*count (only for array items)*/
  0,     /*signed?*/
  0,     /*min value read can return*/
  1,     /*max value read can return*/
  0,     /*min vale device can report*/
  1,     /*max value device can report*/
  1      /*resolution*/
};
static const rp_item_t imp_0_ralt={
  hid_kbd_info.in_report_data+0, /*data*/
  1,     /*size*/
  6,     /*shift*/
  0,     /*count (only for array items)*/
  0,     /*signed?*/
  0,     /*min value read can return*/
  1,     /*max value read can return*/
  0,     /*min vale device can report*/
  1,     /*max value device can report*/
  1      /*resolution*/
};
static const rp_item_t imp_0_rgui={
  hid_kbd_info.in_report_data+0, /*data*/
  1,     /*size*/
  7,     /*shift*/
  0,     /*count (only for array items)*/
  0,     /*signed?*/
  0,     /*min value read can return*/
  1,     /*max value read can return*/
  0,     /*min vale device can report*/
  1,     /*max value device can report*/
  1      /*resolution*/
};
static const rp_item_t out_0_num={
  hid_kbd_info.out_report_data+0, /*data*/
  1,     /*size*/
  0,     /*shift*/
  0,     /*count (only for array items)*/
  0,     /*signed?*/
  0,     /*min value read can return*/
  1,     /*max value read can return*/
  0,     /*min vale device can report*/
  1,     /*max value device can report*/
  1      /*resolution*/
};
static const rp_item_t out_0_caps_lock={
  hid_kbd_info.out_report_data+0, /*data*/
  1,     /*size*/
  1,     /*shift*/
  0,     /*count (only for array items)*/
  0,     /*signed?*/
  0,     /*min value read can return*/
  1,     /*max value read can return*/
  0,     /*min vale device can report*/
  1,     /*max value device can report*/
  1      /*resolution*/
};
static const rp_item_t out_0_scroll_lock={
  hid_kbd_info.out_report_data+0, /*data*/
  1,     /*size*/
  2,     /*shift*/
  0,     /*count (only for array items)*/
  0,     /*signed?*/
  0,     /*min value read can return*/
  1,     /*max value read can return*/
  0,     /*min vale device can report*/
  1,     /*max value device can report*/
  1      /*resolution*/
};
static const rp_item_t out_0_compose={
  hid_kbd_info.out_report_data+0, /*data*/
  1,     /*size*/
  3,     /*shift*/
  0,     /*count (only for array items)*/
  0,     /*signed?*/
  0,     /*min value read can return*/
  1,     /*max value read can return*/
  0,     /*min vale device can report*/
  1,     /*max value device can report*/
  1      /*resolution*/
};
static const rp_item_t out_0_kana={
  hid_kbd_info.out_report_data+0, /*data*/
  1,     /*size*/
  4,     /*shift*/
  0,     /*count (only for array items)*/
  0,     /*signed?*/
  0,     /*min value read can return*/
  1,     /*max value read can return*/
  0,     /*min vale device can report*/
  1,     /*max value device can report*/
  1      /*resolution*/
};
static const rp_item_t imp_0_key_array={
  hid_kbd_info.in_report_data+2, /*data*/
  8,     /*size*/
  0,     /*shift*/
  6,     /*count (only for array items)*/
  0,     /*signed?*/
  0,     /*min value read can return*/
  101,   /*max value read can return*/
  0,     /*min vale device can report*/
  101,   /*max value device can report*/
  1      /*resolution*/
};
static const report_tree_item_t b_kbd_report_tree[] = {
  {0x0001, 0x0006, 0x0000, 0, 0},  /* application collection */
  {0x0007, 0x00e0, 0x0000, 1, (rp_item_t *) &imp_0_lctrl},
  {0x0007, 0x00e1, 0x0000, 1, (rp_item_t *) &imp_0_lshift},
  {0x0007, 0x00e2, 0x0000, 1, (rp_item_t *) &imp_0_lalt},
  {0x0007, 0x00e3, 0x0000, 1, (rp_item_t *) &imp_0_lgui},
  {0x0007, 0x00e4, 0x0000, 1, (rp_item_t *) &imp_0_rctrl},
  {0x0007, 0x00e5, 0x0000, 1, (rp_item_t *) &imp_0_rshift},
  {0x0007, 0x00e6, 0x0000, 1, (rp_item_t *) &imp_0_ralt},
  {0x0007, 0x00e7, 0x0000, 1, (rp_item_t *) &imp_0_rgui},
  {0x0005, 0x0001, 0x0000, 1, (rp_item_t *) &out_0_num},
  {0x0005, 0x0002, 0x0000, 1, (rp_item_t *) &out_0_caps_lock},
  {0x0005, 0x0003, 0x0000, 1, (rp_item_t *) &out_0_scroll_lock},
  {0x0005, 0x0004, 0x0000, 1, (rp_item_t *) &out_0_compose},
  {0x0005, 0x0005, 0x0000, 1, (rp_item_t *) &out_0_kana},
  {0x0007, 0x0000, 0x0065, 1, (rp_item_t *) &imp_0_key_array},
  {0x0000, 0x0000, 0xff, 0}
};
/*****************************************************************************
 * Function predefinitions.
 *****************************************************************************/
/* none */
/*****************************************************************************
 * Function definitions.
 *****************************************************************************/
/*****************************************************************************
 * Name:
 *    hid_kbd_init
 * In:
 *    -
 * Out:
 *    -
 *
 * Description:
 *    Iitialize keyboard driver.
 *
 * Assumptions:
 *    -
 *****************************************************************************/
void hid_kbd_init(void)
{
  int x;
  hid_kbd_info.lctrl=hid_kbd_info.lshift=
     hid_kbd_info.lalt=hid_kbd_info.lgui=
     hid_kbd_info.rctrl=hid_kbd_info.rshift=
     hid_kbd_info.ralt=hid_kbd_info.rgui=0;

  hid_kbd_info.state=HKST_INVALID;
  for(x=0; x< sizeof(hid_kbd_info.in_report_data); x++)
  {
    hid_kbd_info.in_report_data[x]=0;
  }
  for(x=0; x< sizeof(hid_kbd_info.out_report_data); x++)
  {
    hid_kbd_info.out_report_data[x]=0;
  }
}
/*****************************************************************************
 * Name:
 *    hid_kbd_set_leds
 * In:
 *    num    - required status of num lock LED (0 off , 1 on)
 *    caps   - required status of CAPS lock LED (0 off , 1 on)
 *    scroll - required status of scroll lock LED (0 off , 1 on)
 *    compo  - required status of compose lock LED (0 off , 1 on)
 *    kana   - required status of kana lock LED (0 off , 1 on)
 * Out:
 *    -
 *
 * Description:
 *    Set status of LEDS on the keyboard.
 *
 * Assumptions:
 *    -
 *****************************************************************************/
void hid_kbd_set_leds(hcc_u8 num, hcc_u8 caps, hcc_u8 scroll, hcc_u8 compo, hcc_u8 kana)
{
  /* update report buffer */
  write_item((rp_item_t *) &out_0_num, (hcc_u32)(num ? 1 : 0), 0);
  write_item((rp_item_t *) &out_0_caps_lock, (hcc_u32)(caps ? 1 : 0), 0);
  write_item((rp_item_t *) &out_0_scroll_lock, (hcc_u32)(scroll ? 1 : 0), 0);
  write_item((rp_item_t *) &out_0_compose, (hcc_u32)(compo ? 1 : 0), 0);
  write_item((rp_item_t *) &out_0_kana, (hcc_u32)(kana ? 1 : 0), 0);

  /* send report to device */
  hid_set_report(0, hid_kbd_info.out_report_data, 1);
}
/*****************************************************************************
 * Name:
 *    hid_kbd_in_convert
 * In:
 *    -
 * Out:
 *    -
 *
 * Description:
 *    Update stored values with values got in the last report.
 *
 * Assumptions:
 *    -
 *****************************************************************************/
static void hid_kbd_in_convert(void)
{
  hcc_u8 x;
  hid_kbd_info.lctrl=(hcc_u8)read_item((rp_item_t *) &imp_0_lctrl, 0);
  hid_kbd_info.lshift=(hcc_u8)read_item((rp_item_t *) &imp_0_lshift, 0);
  hid_kbd_info.lalt=(hcc_u8)read_item((rp_item_t *) &imp_0_lalt, 0);
  hid_kbd_info.lgui=(hcc_u8)read_item((rp_item_t *) &imp_0_lgui, 0);
  hid_kbd_info.rctrl=(hcc_u8)read_item((rp_item_t *) &imp_0_rctrl, 0);
  hid_kbd_info.rshift=(hcc_u8)read_item((rp_item_t *) &imp_0_rshift, 0);
  hid_kbd_info.ralt=(hcc_u8)read_item((rp_item_t *) &imp_0_ralt, 0);
  hid_kbd_info.rgui=(hcc_u8)read_item((rp_item_t *) &imp_0_rgui, 0);
  for(x=0; x < sizeof(hid_kbd_info.keys); x++)
  {
    hid_kbd_info.keys[x]=(hcc_u8)read_item((rp_item_t *) &imp_0_key_array, x);
  }

}
/*****************************************************************************
 * Name:
 *    hid_kbd_process
 * In:
 *    -
 * Out:
 *    0 - all ok
 *    1 - error encountered
 *
 * Description:
 *    Give CPU time to keyboard driver. This function shall be called
 *    periodically. It handles keyboard states, and will update values readable
 *    trough the API.
 *
 * Assumptions:
 *    -
 *****************************************************************************/
int hid_kbd_process(void)
{
  hcc_u32 r;
  switch(hid_kbd_info.state)
  {
  case HKST_INVALID:
    /* Set idle time to infinite. Deveice shall send a report only if we ask for
       a report. */
    hid_set_idle(0,0);

    /* Get the "default values". */
    if (!hid_get_report(0, hid_kbd_info.in_report_data, sizeof(hid_kbd_info.in_report_data)))
    {
      /* Convert report. */
      hid_kbd_in_convert();
      /* Switch state. */
      hid_kbd_info.state=HKST_ACTIVE;
    }
    else
    {
      /* Communication error. Dropp device. */
      return(1);
    }
    break;
  case HKST_ACTIVE:
    /* Get next report from device. */
    r=host_receive(hid_kbd_info.in_report_data, sizeof(hid_kbd_info.in_report_data), hid_info.in_it_ep);
    switch (r)
    {
    default:
    case -1u:
      /* Communication error, dropp device.  */
      return(1);
    case sizeof(hid_kbd_info.in_report_data):
      /* Got new values, convert data. */
      hid_kbd_in_convert();
      break;
    case 0:
      /* No data returned. Check if device is still connected. */
      if (!host_has_device())
      {
        return(1);
      }
      break;
    }
    break;
  }
  return(0);
}
/*****************************************************************************
 * Name:
 *    hid_kbd_get_lshift
 * In:
 *    -
 * Out:
 *    0 - released
 *    1 - pressed
 *
 * Description:
 *    Get status of left shift.
 *
 * Assumptions:
 *    -
 *****************************************************************************/
hcc_u8 hid_kbd_get_lshift(void)
{
  return(hid_kbd_info.lshift);
}
/*****************************************************************************
 * Name:
 *    hid_kbd_get_rshift
 * In:
 *    -
 * Out:
 *    0 - released
 *    1 - pressed
 *
 * Description:
 *    Get status of right shift.
 *
 * Assumptions:
 *    -
 *****************************************************************************/
hcc_u8 hid_kbd_get_rshift(void)
{
  return(hid_kbd_info.rshift);
}
/*****************************************************************************
 * Name:
 *    hid_kbd_get_ralt
 * In:
 *    -
 * Out:
 *    0 - released
 *    1 - pressed
 *
 * Description:
 *    Get status of rigth alt.
 *
 * Assumptions:
 *    -
 *****************************************************************************/
hcc_u8 hid_kbd_get_ralt(void)
{
  return(hid_kbd_info.ralt);
}
/*****************************************************************************
 * Name:
 *    hid_kbd_get_lalt
 * In:
 *    -
 * Out:
 *    0 - released
 *    1 - pressed
 *
 * Description:
 *    Get status of left alt.
 *
 * Assumptions:
 *    -
 *****************************************************************************/
hcc_u8 hid_kbd_get_lalt(void)
{
  return(hid_kbd_info.lalt);
}
/*****************************************************************************
 * Name:
 *    hid_kbd_get_rctrl
 * In:
 *    -
 * Out:
 *    0 - released
 *    1 - pressed
 *
 * Description:
 *    Get status of right control.
 *
 * Assumptions:
 *    -
 *****************************************************************************/
hcc_u8 hid_kbd_get_rctrl(void)
{
  return(hid_kbd_info.rctrl);
}
/*****************************************************************************
 * Name:
 *    hid_kbd_get_lctrl
 * In:
 *    -
 * Out:
 *    0 - released
 *    1 - pressed
 *
 * Description:
 *    Get status of left control.
 *
 * Assumptions:
 *    -
 *****************************************************************************/
hcc_u8 hid_kbd_get_lctrl(void)
{
  return(hid_kbd_info.lctrl);
}
/*****************************************************************************
 * Name:
 *    hid_kbd_get_rgui
 * In:
 *    -
 * Out:
 *    0 - released
 *    1 - pressed
 *
 * Description:
 *    Get status of right gui.
 *
 * Assumptions:
 *    -
 *****************************************************************************/
hcc_u8 hid_kbd_get_rgui(void)
{
  return(hid_kbd_info.rgui);
}
/*****************************************************************************
 * Name:
 *    hid_kbd_get_lgui
 * In:
 *    -
 * Out:
 *    0 - released
 *    1 - pressed
 *
 * Description:
 *    Get status of left gui.
 *
 * Assumptions:
 *    -
 *****************************************************************************/
hcc_u8 hid_kbd_get_lgui(void)
{
  return(hid_kbd_info.lgui);
}
/*****************************************************************************
 * Name:
 *    hid_kbd_get_nkey
 * In:
 *    -
 * Out:
 *    Number of keys pressed.
 *
 * Description:
 *    Return the number of pressed keys.
 *
 * Assumptions:
 *    -
 *****************************************************************************/
hcc_u8 hid_kbd_get_nkey(void)
{
  hcc_u8 nkey;

  for(nkey=0; nkey < sizeof(hid_kbd_info.keys)/sizeof(hid_kbd_info.keys[0]); nkey++)
  {
    if (hid_kbd_info.keys[nkey] == 0
        || hid_kbd_info.keys[nkey] == 1)
    {
      break;
    }
  }
  return(nkey);
}
/*****************************************************************************
 * Name:
 *    hid_kbd_get_key
 * In:
 *    Index of pressed key.
 * Out:
 *    Scan code.
 *
 * Description:
 *    Return the scan code of ndx th pressed key.
 *
 * Assumptions:
 *    -
 *****************************************************************************/
hcc_u8 hid_kbd_get_key(hcc_u8 ndx)
{
  return(hid_kbd_info.keys[ndx]);
}
/****************************** END OF FILE **********************************/
%-*****************************************************************************************************
%FILE %'DirRel_Code'host_hid.h
%-*****************************************************************************************************
/***************************************************************************
 *
 *            Copyright (c) 2006-2007 by CMX Systems, Inc.
 *
 * This software is copyrighted by and is the sole property of
 * CMX.  All rights, title, ownership, or other interests
 * in the software remain the property of CMX.  This
 * software may only be used in accordance with the corresponding
 * license agreement.  Any unauthorized use, duplication, transmission,
 * distribution, or disclosure of this software is expressly forbidden.
 *
 * This Copyright notice may not be removed or modified without prior
 * written consent of CMX.
 *
 * CMX reserves the right to modify this software without notice.
 *
 * CMX Systems, Inc.
 * 12276 San Jose Blvd. #511
 * Jacksonville, FL 32223
 * USA
 *
 * Tel:  (904) 880-1840
 * Fax:  (904) 880-1632
 * http: www.cmx.com
 * email: cmx@cmx.com
 *
 ***************************************************************************/
#ifndef _HOST_HID_H_
#define _HOST_HID_H_
#define HIDTYPE_UNKNOWN  0u
#define HIDTYPE_KBD      1u
#define HIDTYPE_MOUSE    2u
#define HIDTYPE_JOY      3u
typedef struct {
  hcc_u16 ifcd_offset; /* offset of interface descriptor used */
  hcc_u16 hidver;      /* HID version supported by the device */
  hcc_u8 boot;         /* type of boot-protocol device talks */
  hcc_u8 ifc_ndx;      /* index of used interface */
  hcc_u8 alt_set;      /* alternate setting of used interface */
  hcc_u8 cfg_ndx;      /* configuration for HID functionality */
  hcc_u8 country;      /* country code of device */
  hcc_u8 no_of_classd; /* number of class descriptors in device */
  hcc_u8 in_it_ep;
  hcc_u8 out_it_ep;
} hid_info_t;
extern hid_info_t hid_info;
extern hcc_u8 hid_init(void);
extern hcc_u8 hid_set_report(hcc_u8 report_id, hcc_u8 *buffer, hcc_u16 length);
extern hcc_u8 hid_get_report(hcc_u8 report_id, hcc_u8 *buffer, hcc_u16 length);
extern int hid_set_protocol(hcc_u8 boot);
extern int hid_set_idle(hcc_u8 dur, hcc_u8 report_id);
extern hcc_u8 hid_get_dev_type(void);
#endif
/****************************** END OF FILE **********************************/
%-*****************************************************************************************************
%FILE %'DirRel_Code'host_hid.c
%-*****************************************************************************************************
/***************************************************************************
 *
 *            Copyright (c) 2006-2007 by CMX Systems, Inc.
 *
 * This software is copyrighted by and is the sole property of
 * CMX.  All rights, title, ownership, or other interests
 * in the software remain the property of CMX.  This
 * software may only be used in accordance with the corresponding
 * license agreement.  Any unauthorized use, duplication, transmission,
 * distribution, or disclosure of this software is expressly forbidden.
 *
 * This Copyright notice may not be removed or modified without prior
 * written consent of CMX.
 *
 * CMX reserves the right to modify this software without notice.
 *
 * CMX Systems, Inc.
 * 12276 San Jose Blvd. #511
 * Jacksonville, FL 32223
 * USA
 *
 * Tel:  (904) 880-1840
 * Fax:  (904) 880-1632
 * http: www.cmx.com
 * email: cmx@cmx.com
 *
 ***************************************************************************/
//#include "target.h"
#include "usb_host.h"
#include "usb_utils.h"
#include "hid_usage.h"
#include "host_hid.h"
#include "host_hid_mouse.h"
#include "host_hid_kbd.h"

#define HIDDESC_HID       0x21
#define HIDDESC_REPORT    0x22
#define HIDDESC_PHYSICAL  0x23

#define HIDRQ_GET_REPORT    0x1
#define HIDRQ_GET_IDLE      0x2
#define HIDRQ_GET_PROTOCOL  0x3

#define HIDRQ_SET_REPORT    0x9
#define HIDRQ_SET_IDLE      0xa
#define HIDRQ_SET_PROTOCOL  0xb

#define REPORT_ITEM_LIST_SIZE   100u

/* this type is used to access (read/write) short items in a
   report */
typedef struct {
  hcc_u16 offset;
  hcc_u8 usage;
  hcc_u8 usage_page;
  hcc_u8 absolute;
  hcc_u8 length;
  hcc_u8 shr;
  hcc_u8 mask;
} report_item_t;

/* this structure will hold information about report item
   properties while pharsing the report descriptor */
typedef struct {
  hcc_u8 usage;
  hcc_u8 usage_page;
  hcc_u32 log_min;
  hcc_u32 log_max;
  hcc_u32 rep_size;
  hcc_u32 rep_count;
} item_prop_t;

/* holds data needed to manage the HID driver */
hid_info_t hid_info;

/* number of allocated entryes in the following list */
hcc_u8 report_items;
/* each entry describes one HID report item */
report_item_t report_item_list[REPORT_ITEM_LIST_SIZE];

/* get the sepcified report over the control channel */
hcc_u8 hid_set_report(hcc_u8 report_id, hcc_u8 *buffer, hcc_u16 length)
{
  hcc_u8 setup[8];
  fill_setup_packet(setup, STP_DIR_OUT, STP_TYPE_CLASS, STP_RECIPIENT_IFC,
     HIDRQ_SET_REPORT, (hcc_u16)((0x02<<8) | report_id), hid_info.ifc_ndx,
     length);

  if (((hcc_u16)-1)==host_send_control(setup, buffer, 0))
  {
    return(1);
  }
  return(0);
}


/* get the sepcified report over the control channel */
hcc_u8 hid_get_report(hcc_u8 report_id, hcc_u8 *buffer, hcc_u16 length)
{
  hcc_u8 setup[8];
  fill_setup_packet(setup, STP_DIR_IN, STP_TYPE_CLASS, STP_RECIPIENT_IFC,
     HIDRQ_GET_REPORT, (hcc_u16)((0x01<<8) | report_id), hid_info.ifc_ndx,
     length);

  if (((hcc_u16)-1)==host_receive_control(setup, buffer, 0))
  {
    return(1);
  }
  return(0);
}

/* set protocol to boot/nonboot version */
int hid_set_protocol(hcc_u8 boot)
{
  hcc_u8 setup[8];
  fill_setup_packet(setup, STP_DIR_OUT, STP_TYPE_CLASS, STP_RECIPIENT_IFC,
     HIDRQ_SET_PROTOCOL, (hcc_u8)(boot ? 0 : 1), hid_info.ifc_ndx, 0);
  return(host_send_control(setup, 0, 0));
}

/* set idle time of device */
int hid_set_idle(hcc_u8 dur, hcc_u8 report_id)
{
  hcc_u8 setup[8];
  fill_setup_packet(setup, STP_DIR_OUT, STP_TYPE_CLASS, STP_RECIPIENT_IFC,
     HIDRQ_SET_IDLE, (hcc_u16)((dur<<8) | report_id), hid_info.ifc_ndx, 0);
  return(host_send_control(setup, 0, 0));
}

static int hid_search_ifc(void)
{
  device_info_t dev_inf;
  ifc_info_t ifc_info;
  cfg_info_t cfg_info;
  hcc_u8 cfg;

  hid_info.hidver=0;
  hid_info.ifcd_offset=0;

  /* see what device is this */
  if (get_device_info(&dev_inf))
  {
    return(0);
  }

  /* HID devices have their class info in the interface descriptor. */
  /* check all configurations */
  for(cfg=0; cfg < dev_inf.ncfg; cfg++)
  {
    hcc_u16 ifc;

    /* get the configuration descriptor */
    if (get_cfg_desc(cfg))
    {
      continue;
    };

    /* find a HID interface */
    ifc=find_ifc_csp(0x03, 0, 0);

    if (!ifc)
    {
      continue;
    }

    get_ifc_info(&ifc_info, ifc);

    if(ifc_info.sclas == 0x0)
    { /* non boot device */
       hid_info.boot=0;
    }
    else if (ifc_info.sclas == 0x1)
    { /* boot device */
      if (ifc_info.protocol < 3)
      {
        hid_info.boot=ifc_info.protocol;
      }
      else
      { /* bad protocol value, skipp interface */
        continue;
      }
    }
    /* we only handle the first HID interface. */

    get_cfg_info(&cfg_info);
    hid_info.cfg_ndx=cfg_info.ndx;

    hid_info.ifc_ndx=ifc_info.ndx;
    hid_info.ifcd_offset=ifc;
    hid_info.alt_set=ifc_info.alt_set;
    return(1);
  }
  return(0);
}
/* Startup HID driver. */
hcc_u8 hid_init(void)
{

  hid_info.alt_set=0;
  hid_info.boot=0;
  hid_info.country=0;
  hid_info.hidver=0;
  hid_info.ifc_ndx=0;
  hid_info.ifcd_offset=0;
  hid_info.in_it_ep=0;
  hid_info.out_it_ep=0;

  /* look for an interface supporing the HID class */
  if (hid_search_ifc())
  {
    hcc_u16 ep_ofs;
    hcc_u8 ep;
    ifc_info_t ifc_inf;

    /* Inicialize endpoints.  */
    get_ifc_info(&ifc_inf, hid_info.ifcd_offset);
    ep_ofs=hid_info.ifcd_offset;
    for(ep=0; ep < ifc_inf.nep; ep++)
    {
      ep_info_t ep_inf;
      ep_ofs=find_descriptor(STDDTYPE_ENDPOINT, ep_ofs, 1);
      get_ep_info(&ep_inf, ep_ofs);
      /* Note: HID ifc shall only have interrupt endpoints so we ignore other
                 ep types.
               A HID device shall have one IN and may have one OUT endpoint. We
               will use the last IN and OUT endpoint defined. */
      if (ep_inf.type==EPTYPE_INT)
      {
        if (ep_inf.address > 0x80)
        {
          hid_info.in_it_ep=host_add_ep(ep_inf.type, (hcc_u8)(ep_inf.address & 0x7f), ep_inf.interval, (hcc_u16)ep_inf.psize);
        }
        else
        {
          hid_info.out_it_ep=host_add_ep(ep_inf.type, (hcc_u8)(ep_inf.address & 0x7f), ep_inf.interval, ep_inf.psize);
        }
      }
      ep_ofs++;
    }

    /* Device shall have an interrupt IN endpoint */
    if (hid_info.in_it_ep == 0)
    {
      /* return error */
      return((hcc_u8)-1);
    }

    /* start device */
    if (set_config(hid_info.cfg_ndx))
    {
      /* request failed, return error */
      return((hcc_u8)-1);
    }
    else
    {
      return(0);
    }
  }
  else
  {
    /* not found, return error */
    return((hcc_u8)1u);
  }
}

hcc_u8 hid_get_dev_type(void)
{
  device_info_t devi;
  /* only mouse or keyboard devicas may have the boot filed set to a value
     other than 0 */
  if (hid_info.boot)
  {
    return(hid_info.boot);
  }
  /* Check if the device is a joystick. Since we do not have the code needed for
     parsing report descriptors, we use pre-created data acccess structures
     for the supported joystick. We identify our joystick by vendor id and
     product id, and release number. */
  if (!get_dev_desc())
  {
    get_device_info(&devi);

    if (devi.vid==0x06d6 && devi.pid==0x002f && devi.rev==0x0120)
    {
      return(HIDTYPE_JOY);
    }
  }
  return(HIDTYPE_UNKNOWN);
}
/****************************** END OF FILE **********************************/
%-*****************************************************************************************************
%FILE %'DirRel_Code'hid_usage.h
%-*****************************************************************************************************
/***************************************************************************
 *
 *            Copyright (c) 2006-2007 by CMX Systems, Inc.
 *
 * This software is copyrighted by and is the sole property of
 * CMX.  All rights, title, ownership, or other interests
 * in the software remain the property of CMX.  This
 * software may only be used in accordance with the corresponding
 * license agreement.  Any unauthorized use, duplication, transmission,
 * distribution, or disclosure of this software is expressly forbidden.
 *
 * This Copyright notice may not be removed or modified without prior
 * written consent of CMX.
 *
 * CMX reserves the right to modify this software without notice.
 *
 * CMX Systems, Inc.
 * 12276 San Jose Blvd. #511
 * Jacksonville, FL 32223
 * USA
 *
 * Tel:  (904) 880-1840
 * Fax:  (904) 880-1632
 * http: www.cmx.com
 * email: cmx@cmx.com
 *
 ***************************************************************************/
#ifndef _HID_USAGE_H_
#define _HID_USAGE_H_

#define UV(v)   ((hcc_u16)(v))
/****************************************************/
/* HID 1.11 usage pages                             */
/****************************************************/

#define HIDUPG_UNDEFINED  UV(0x00)   /* Undefined */
/**** Top level pages */
#define HIDUPG_GEN_DES    UV(0x01)   /* Generic Desktop Controls*/
#define HIDUPG_SIM_CTR    UV(0x02)   /* Simulation Controls */
#define HIDUPG_VR_CTR     UV(0x03)   /* VR Controls */
#define HIDUPG_SPORT_CTR  UV(0x04)   /* Sport Controls */
#define HIDUPG_GAME_CTR   UV(0x05)   /* Game Controls */
#define HIDUPG_GEN_DEV    UV(0x06)   /* Generic Device Controls */
#define HIDUPG_KEYB       UV(0x07)   /* Keyboard/Keypad */
#define HIDUPG_LED        UV(0x08)   /* LEDs */
#define HIDUPG_BUTTON     UV(0x09)   /* Button */
#define HIDUPG_ORDINAL    UV(0x0A)   /* Ordinal */
#define HIDUPG_PHONE      UV(0x0B)   /* Telephony */
#define HIDUPG_CONSUMER   UV(0x0C)   /* Consumer */
#define HIDUPG_DIGITIZER  UV(0x0D)   /* Digitizer*/
/* 0E    Reserved */
#define HIDUPG_PID        UV(0x0F)   /* PID Page (force feedback and related devices) */
#define HIDUPG_UNICODE    UV(0x10)   /* Unicode */
/* 11-13 Reserved */
#define HIDUPG_ALNUM_DISP UV(0x14)   /* Alphanumeric Display */
/* 15-1f Reserved */
/**** END of top level pages */
/* 25-3f Reserved */
#define HIDUPG_MEDICAL    UV(0x40)   /* Medical Instruments */
/* 41-7F Reserved */
/*80-83 Monitor pages USB Device Class Definition for Monitor Devices
  84-87 Power pages USB Device Class Definition for Power Devices */
/* 88-8B Reserved */
#define HIDUPG_BARCODE    UV(0x8C)   /* Bar Code Scanner page */
#define HIDUPG_SCALE      UV(0x8D)   /* Scale page */
#define HIDUPG_MSR        UV(0x8E)   /* Magnetic Stripe Reading (MSR) Devices */
#define HIDUPG_POS        UV(0x8F)   /* Reserved Point of Sale pages */
#define HIDUPG_CAMERA_CTR UV(0x90)   /* Camera Control Page */
#define HIDUPG_ARCADE     UV(0x91)   /* Arcade Page */

/****************************************************/
/* Usage definitions for the "Generic Decktop" page */
/****************************************************/
#define HIDU_UNDEFINED     UV(0x00)   /* Undefined */
#define HIDU_POINTER       UV(0x01)   /* Pointer (Physical Collection) */
#define HIDU_MOUSE         UV(0x02)   /* Mouse (Application Collection) */
/* 03 Reserved */
#define HIDU_JOYSTICK      UV(0x04)   /* Joystick (Application Collection) */
#define HIDU_GAMEPAD       UV(0x05)   /* Game Pad (Application Collection) */
#define HIDU_KBD           UV(0x06)   /* Keyboard (Application Collection) */
#define HIDU_KEYPAD        UV(0x07)   /* Keypad (Application Collection) */
#define HIDU_MAX_CTR       UV(0x08)   /* Multi-axis Controller (Application Collection) */
/* 09-2F Reserved */
#define HIDU_X             UV(0x30)   /* X (Dynamic Value) */
#define HIDU_Y             UV(0x31)   /* Y (Dynamic Value) */
#define HIDU_Z             UV(0x32)   /* Z (Dynamic Value) */
#define HIDU_RX            UV(0x33)   /* Rx (Dynamic Value) */
#define HIDU_RY            UV(0x34)   /* Ry (Dynamic Value) */
#define HIDU_RZ            UV(0x35)   /* Rz (Dynamic Value) */
#define HIDU_SLIDER        UV(0x36)   /* Slider (Dynamic Value) */
#define HIDU_DIAL          UV(0x37)   /* Dial (Dynamic Value) */
#define HIDU_WHEEL         UV(0x38)   /* Wheel (Dynamic Value) */
#define HIDU_HATSW         UV(0x39)   /* Hat switch (Dynamic Value) */
#define HIDU_COUNTEDBUF    UV(0x3A)   /* Counted Buffer (Logical Collection) */
#define HIDU_BYTECOUNT     UV(0x3B)   /* Byte Count (Dynamic Value) */
#define HIDU_MOTIONWAKE    UV(0x3C)   /* Motion Wakeup (One Shot Control) */
#define HIDU_START         UV(0x3D)   /* Start (On/Off Control) */
#define HIDU_SELECT        UV(0x3E)   /* Select (On/Off Control) */
/* 3F Reserved */
#define HIDU_VX            UV(0x40)   /* Vx (Dynamic Value) */
#define HIDU_VY            UV(0x41)   /* Vy (Dynamic Value) */
#define HIDU_VZ            UV(0x42)   /* Vz (Dynamic Value) */
#define HIDU_VBRX          UV(0x43)   /* Vbrx (Dynamic Value) */
#define HIDU_VBRY          UV(0x44)   /* Vbry (Dynamic Value) */
#define HIDU_VBRZ          UV(0x45)   /* Vbrz (Dynamic Value) */
#define HIDU_VNO           UV(0x46)   /* Vno (Dynamic Value) */
#define HIDU_FEATNOTIF     UV(0x47)   /* Feature Notification (Dynamic Value),(Dynamic Flag) */
/* 48-7F Reserved */
#define HIDU_SYSCTL        UV(0x80)   /* System Control (Application Collection) */
#define HIDU_PWDOWN        UV(0x81)   /* System Power Down (One Shot Control) */
#define HIDU_SLEEP         UV(0x82)   /* System Sleep (One Shot Control) */
#define HIDU_WAKEUP        UV(0x83)   /* System Wake Up (One Shot Control)  */
#define HIDU_CONTEXTM      UV(0x84)   /* System Context Menu (One Shot Control) */
#define HIDU_MAINM         UV(0x85)   /* System Main Menu (One Shot Control) */
#define HIDU_APPM          UV(0x86)   /* System App Menu (One Shot Control) */
#define HIDU_MENUHELP      UV(0x87)   /* System Menu Help (One Shot Control) */
#define HIDU_MENUEXIT      UV(0x88)   /* System Menu Exit (One Shot Control) */
#define HIDU_MENUSELECT    UV(0x89)   /* System Menu Select (One Shot Control) */
#define HIDU_SYSM_RIGHT    UV(0x8A)   /* System Menu Right (Re-Trigger Control) */
#define HIDU_SYSM_LEFT     UV(0x8B)   /* System Menu Left (Re-Trigger Control) */
#define HIDU_SYSM_UP       UV(0x8C)   /* System Menu Up (Re-Trigger Control) */
#define HIDU_SYSM_DOWN     UV(0x8D)   /* System Menu Down (Re-Trigger Control) */
#define HIDU_COLDRESET     UV(0x8E)   /* System Cold Restart (One Shot Control) */
#define HIDU_WARMRESET     UV(0x8F)   /* System Warm Restart (One Shot Control) */
#define HIDU_DUP           UV(0x90)   /* D-pad Up (On/Off Control) */
#define HIDU_DDOWN         UV(0x91)   /* D-pad Down (On/Off Control) */
#define HIDU_DRIGHT        UV(0x92)   /* D-pad Right (On/Off Control) */
#define HIDU_DLEFT         UV(0x93)   /* D-pad Left (On/Off Control) */
/* 94-9F Reserved */
#define HIDU_SYS_DOCK      UV(0xA0)   /* System Dock (One Shot Control) */
#define HIDU_SYS_UNDOCK    UV(0xA1)   /* System Undock (One Shot Control) */
#define HIDU_SYS_SETUP     UV(0xA2)   /* System Setup (One Shot Control) */
#define HIDU_SYS_BREAK     UV(0xA3)   /* System Break (One Shot Control) */
#define HIDU_SYS_DBGBRK    UV(0xA4)   /* System Debugger Break (One Shot Control) */
#define HIDU_APP_BRK       UV(0xA5)   /* Application Break (One Shot Control) */
#define HIDU_APP_DBGBRK    UV(0xA6)   /* Application Debugger Break (One Shot Control) */
#define HIDU_SYS_SPKMUTE   UV(0xA7)   /* System Speaker Mute (One Shot Control) */
#define HIDU_SYS_HIBERN    UV(0xA8)   /* System Hibernate (One Shot Control) */
/* A9-AF Reserved */
#define HIDU_SYS_SIDPINV   UV(0xB0)   /* System Display Invert (One Shot Control) */
#define HIDU_SYS_DISPINT   UV(0xB1)   /* System Display Internal (One Shot Control) */
#define HIDU_SYS_DISPEXT   UV(0xB2)   /* System Display External (One Shot Control) */
#define HIDU_SYS_DISPBOTH  UV(0xB3)   /* System Display Both (One Shot Control) */
#define HIDU_SYS_DISPDUAL  UV(0xB4)   /* System Display Dual (One Shot Control) */
#define HIDU_SYS_DISPTGLIE UV(0xB5)   /* System Display Toggle Int/Ext (One Shot Control) */
#define HIDU_SYS_DISP_SWAP UV(0xB6)   /* System Display Swap Primary/Secondary (One Shot Control) */
#define HIDU_SYS_DIPS_LCDA UV(0xB7)   /* System Display LCD Autoscale (One Shot Control) */
/* B8-FFFF Reserved */
#endif
/****************************** END OF FILE **********************************/
%-*****************************************************************************************************
%FILE %'DirRel_Code'host_hid_mouse.h
%-*****************************************************************************************************
/***************************************************************************
 *
 *            Copyright (c) 2006-2007 by CMX Systems, Inc.
 *
 * This software is copyrighted by and is the sole property of
 * CMX.  All rights, title, ownership, or other interests
 * in the software remain the property of CMX.  This
 * software may only be used in accordance with the corresponding
 * license agreement.  Any unauthorized use, duplication, transmission,
 * distribution, or disclosure of this software is expressly forbidden.
 *
 * This Copyright notice may not be removed or modified without prior
 * written consent of CMX.
 *
 * CMX reserves the right to modify this software without notice.
 *
 * CMX Systems, Inc.
 * 12276 San Jose Blvd. #511
 * Jacksonville, FL 32223
 * USA
 *
 * Tel:  (904) 880-1840
 * Fax:  (904) 880-1632
 * http: www.cmx.com
 * email: cmx@cmx.com
 *
 ***************************************************************************/
#ifndef _HOST_HID_MOUSE_H_
#define _HOST_HID_MOUSE_H_

extern void hid_mouse_init(void);
extern signed short hid_mouse_get_x(void);
extern signed short hid_mouse_get_y(void);
extern hcc_u8 hid_mouse_get_button(hcc_u8 b);
extern int hid_mouse_process(void);

#endif
/****************************** END OF FILE **********************************/
%-*****************************************************************************************************
%FILE %'DirRel_Code'host_hid_mouse.c
%-*****************************************************************************************************
/***************************************************************************
 *
 *            Copyright (c) 2006-2007 by CMX Systems, Inc.
 *
 * This software is copyrighted by and is the sole property of
 * CMX.  All rights, title, ownership, or other interests
 * in the software remain the property of CMX.  This
 * software may only be used in accordance with the corresponding
 * license agreement.  Any unauthorized use, duplication, transmission,
 * distribution, or disclosure of this software is expressly forbidden.
 *
 * This Copyright notice may not be removed or modified without prior
 * written consent of CMX.
 *
 * CMX reserves the right to modify this software without notice.
 *
 * CMX Systems, Inc.
 * 12276 San Jose Blvd. #511
 * Jacksonville, FL 32223
 * USA
 *
 * Tel:  (904) 880-1840
 * Fax:  (904) 880-1632
 * http: www.cmx.com
 * email: cmx@cmx.com
 *
 ***************************************************************************/
//#include "target.h"
#include "usb_host.h"
#include "usb_utils.h"
#include "hid_usage.h"
#include "host_hid.h"
#include "host_hid_mouse.h"
#include "hid_parser.h"
/*****************************************************************************
 * External references.
 *****************************************************************************/
/* none */
/*****************************************************************************
 * Local types.
 *****************************************************************************/
/* none */
/*****************************************************************************
 * Macro definitions.
 *****************************************************************************/
/* Mouse states */
#define HMST_INVALID    0u
#define HMST_ACTIVE     1u
/*****************************************************************************
 * Module variables.
 *****************************************************************************/
/* Mouse state info. All mouses connected to the system shall modify this
   structure. Currently only one mouse is supported. */
struct {
  hcc_u8 state;
  signed short x;
  signed short y;
  hcc_u8 buttons[3];
  hcc_u8 report_data[4];
} static hid_mouse_info;
/* These structures define how to access items in a HID mouse report, if the
   mouse talks the boot protocol. Nearly all mouse is compatibile with this
   protocol. */
/* Access button 1 state. */
static const rp_item_t imp_0_b1={
  hid_mouse_info.report_data+0, /*data*/
  1,     /*size*/
  0,     /*shift*/
  0,     /*count (only for array items)*/
  0,     /*signed?*/
  0,     /*min value read can return*/
  1,     /*max value read can return*/
  0,     /*min vale device can report*/
  1,     /*max value device can report*/
  1      /*resolution*/
};
/* Access button 2 state. */
static const rp_item_t imp_0_b2={
  hid_mouse_info.report_data+0, /*data*/
  1,     /*size*/
  1,     /*shift*/
  0,     /*count (only for array items)*/
  0,     /*signed?*/
  0,     /*min value read can return*/
  1,     /*max value read can return*/
  0,     /*min vale device can report*/
  1,     /*max value device can report*/
  1      /*resolution*/
};
/* Access button 3 state. */
static const rp_item_t imp_0_b3={
  hid_mouse_info.report_data+0, /*data*/
  1,     /*size*/
  2,     /*shift*/
  0,     /*count (only for array items)*/
  0,     /*signed?*/
  0,     /*min value read can return*/
  1,     /*max value read can return*/
  0,     /*min vale device can report*/
  1,     /*max value device can report*/
  1      /*resolution*/
};
/* Access x coordinate change. */
static const rp_item_t imp_0_x={
  hid_mouse_info.report_data+1, /*data*/
  8,     /*size*/
  0,     /*shift*/
  0,     /*count (only for array items)*/
  1,     /*signed?*/
  0,     /*min value read can return*/
  0xff,  /*max value read can return*/
  0,     /*min vale device can report*/
  0xff,  /*max value device can report*/
  1      /*resolution*/
};
/* Access y coordinate change. */
static const rp_item_t imp_0_y={
  hid_mouse_info.report_data+2, /*data*/
  8,     /*size*/
  0,     /*shift*/
  0,     /*count (only for array items)*/
  1,     /*signed?*/
  0,     /*min value read can return*/
  0xff,  /*max value read can return*/
  0,     /*min vale device can report*/
  0xff,  /*max value device can report*/
  1      /*resolution*/
};
static const report_tree_item_t b_mouse_report_tree[] = {
  {0x0001, 0x0002, 0x0000, 0, 0},  /* application collection */
  {0x0001, 0x0001, 0x0000, 1, 0},  /* physical collection */
  {0x0009, 0x0001, 0x0000, 2, (rp_item_t *) &imp_0_b1}, /* button 1 */
  {0x0009, 0x0002, 0x0000, 2, (rp_item_t *) &imp_0_b2}, /* button 2 */
  {0x0009, 0x0003, 0x0000, 2, (rp_item_t *) &imp_0_b3}, /* button 3 */
  {0x0001, 0x0030, 0x0000, 2, (rp_item_t *) &imp_0_x},  /* x pos */
  {0x0001, 0x0031, 0x0000, 2, (rp_item_t *) &imp_0_y},  /* y pos */
  {0x0000, 0x0000, 0xff, 0}
};
/*****************************************************************************
 * Function predefinitions.
 *****************************************************************************/
/* none */
/*****************************************************************************
 * Function definitions.
 *****************************************************************************/
/*****************************************************************************
 * Name:
 *    hid_mouse_init
 * In:
 *    -
 * Out:
 *    -
 *
 * Description:
 *    Iitialize mose driver.
 *
 * Assumptions:
 *    -
 *****************************************************************************/
void hid_mouse_init(void)
{
  hid_mouse_info.state=HMST_INVALID;
  hid_mouse_info.x=0;
  hid_mouse_info.y=0;
  hid_mouse_info.buttons[0]=0;
  hid_mouse_info.buttons[1]=0;
  hid_mouse_info.buttons[2]=0;
  hid_mouse_info.report_data[0]=0;
  hid_mouse_info.report_data[1]=0;
  hid_mouse_info.report_data[2]=0;
  hid_mouse_info.report_data[3]=0;
}
/*****************************************************************************
 * Name:
 *    hid_mouse_get_x
 * In:
 *    -
 * Out:
 *    Current value of X offset.
 *
 * Description:
 *    Returns X offset.
 *
 * Assumptions:
 *    -
 *****************************************************************************/
signed short hid_mouse_get_x(void)
{
  return(hid_mouse_info.x);
}
/*****************************************************************************
 * Name:
 *    hid_mouse_get_y
 * In:
 *    -
 * Out:
 *    Current value of Y offset.
 *
 * Description:
 *    Returns Y offset.
 *
 * Assumptions:
 *    -
 *****************************************************************************/
signed short hid_mouse_get_y(void)
{
  return(hid_mouse_info.y);
}
/*****************************************************************************
 * Name:
 *    hid_mouse_get_button
 * In:
 *    b - index of button.
 * Out:
 *    0 - button released
 *    1 - button pressed
 *
 * Description:
 *    Return state os a button.
 *
 * Assumptions:
 *    -
 *****************************************************************************/
hcc_u8 hid_mouse_get_button(hcc_u8 b)
{
  if (b>2)
  {
    return(0);
  }
  return(hid_mouse_info.buttons[b]);
}
/*****************************************************************************
 * Name:
 *    hid_mouse_convert
 * In:
 *    -
 * Out:
 *    -
 *
 * Description:
 *    Update stored values with values got in the last report. Some values
 *    contain relative data and thus instead of overwriting we add the cnahge.
 *
 * Assumptions:
 *    -
 *****************************************************************************/
static void hid_mouse_convert(void)
{
  int tmp;
  tmp=hid_mouse_info.x+(signed int)read_item((rp_item_t *) &imp_0_x, 0);

  hid_mouse_info.x=(short)tmp;
  tmp=hid_mouse_info.y+(signed int)read_item((rp_item_t *) &imp_0_y,0 );

  hid_mouse_info.y=(short)tmp;
  hid_mouse_info.buttons[0]=(hcc_u8)read_item((rp_item_t *) &imp_0_b1, 0);
  hid_mouse_info.buttons[1]=(hcc_u8)read_item((rp_item_t *) &imp_0_b2, 0);
  hid_mouse_info.buttons[2]=(hcc_u8)read_item((rp_item_t *) &imp_0_b3, 0);
}
/*****************************************************************************
 * Name:
 *    hid_mouse_process
 * In:
 *    -
 * Out:
 *    0 - all ok
 *    1 - error encountered
 *
 * Description:
 *    Give CPU time to mouse driver. This function shall be called
 *    periodically. It handles mouse states, and will update values readable
 *    trough the API.
 *
 * Assumptions:
 *    -
 *****************************************************************************/
int hid_mouse_process(void)
{
  hcc_u32 r;
  switch(hid_mouse_info.state)
  {
  case HMST_INVALID:
    /* Since we use the values we already have when converiong, we set all our
       variables to default state (0). */
    hid_mouse_init();
    /* Get default values from device. */
    if (!hid_get_report(0, hid_mouse_info.report_data, sizeof(hid_mouse_info.report_data)))
    {
      /* Convert report data. */
      hid_mouse_convert();
      /* Change state. */
      hid_mouse_info.state=HMST_ACTIVE;
    }
    else
    {
      /* Failed to get report. Assume device has been disconnected. */
      return(1);
    }
    break;
  case HMST_ACTIVE:
    /* Get next report from device. */
    r=host_receive(hid_mouse_info.report_data, sizeof(hid_mouse_info.report_data), hid_info.in_it_ep);
    switch (r)
    {
    case -1u:
      /* Error reading data. Assume device hs been disconnected. */
      return(1);
    default:
    case sizeof(hid_mouse_info.report_data):
      /* Right number of bytes received. Convert readed relative data to absolute
         values. */
      hid_mouse_convert();
      break;
    case 0:
      /* Device has no datat to send. See if device is still connected. */
      if (!host_has_device())
      {
        return(1);
      }
      break;
    }
    break;
  }
  return(0);
}
/****************************** END OF FILE **********************************/
%-*****************************************************************************************************
%FILE %'DirRel_Code'hid_parser.h
%-*****************************************************************************************************
/***************************************************************************
 *
 *            Copyright (c) 2006-2007 by CMX Systems, Inc.
 *
 * This software is copyrighted by and is the sole property of
 * CMX.  All rights, title, ownership, or other interests
 * in the software remain the property of CMX.  This
 * software may only be used in accordance with the corresponding
 * license agreement.  Any unauthorized use, duplication, transmission,
 * distribution, or disclosure of this software is expressly forbidden.
 *
 * This Copyright notice may not be removed or modified without prior
 * written consent of CMX.
 *
 * CMX reserves the right to modify this software without notice.
 *
 * CMX Systems, Inc.
 * 12276 San Jose Blvd. #511
 * Jacksonville, FL 32223
 * USA
 *
 * Tel:  (904) 880-1840
 * Fax:  (904) 880-1632
 * http: www.cmx.com
 * email: cmx@cmx.com
 *
 ***************************************************************************/
#ifndef _HID_PARSER_H_
#define _HID_PARSER_H_

#include "hcc_types.h"
#include "hid_usage.h"

/* Report data item. */
typedef struct {
  hcc_u8  *data;
  hcc_u32 size;
  hcc_u8  shift;
  hcc_u8  count;
  hcc_u8  sign;
  hcc_u32 logical_min;  /*min value device can return*/
  hcc_u32 logical_max;  /*max value device can return*/
  hcc_u32 physical_min; /*min vale read can report*/
  hcc_u32 physical_max; /*max value read can report*/
  hcc_u32 resolution;
} rp_item_t;

typedef struct{
  hcc_u16 usage_page;
  hcc_u16 usage_min;
  hcc_u16 usage_max;
  hcc_u8 level;
  rp_item_t *rpi;
} report_tree_item_t;

hcc_u32 read_item(rp_item_t *ri, hcc_u8 ndx);
hcc_u32 write_item(rp_item_t *ri, hcc_u32 value, hcc_u8 ndx);

#endif
/****************************** END OF FILE **********************************/
%-*****************************************************************************************************
%FILE %'DirRel_Code'hid_parser.c
%-*****************************************************************************************************
/***************************************************************************
 *
 *            Copyright (c) 2006-2007 by CMX Systems, Inc.
 *
 * This software is copyrighted by and is the sole property of
 * CMX.  All rights, title, ownership, or other interests
 * in the software remain the property of CMX.  This
 * software may only be used in accordance with the corresponding
 * license agreement.  Any unauthorized use, duplication, transmission,
 * distribution, or disclosure of this software is expressly forbidden.
 *
 * This Copyright notice may not be removed or modified without prior
 * written consent of CMX.
 *
 * CMX reserves the right to modify this software without notice.
 *
 * CMX Systems, Inc.
 * 12276 San Jose Blvd. #511
 * Jacksonville, FL 32223
 * USA
 *
 * Tel:  (904) 880-1840
 * Fax:  (904) 880-1632
 * http: www.cmx.com
 * email: cmx@cmx.com
 *
 ***************************************************************************/
#include "hid_parser.h"

#define MAX_REPORT_TREE_SIZE  100;

hcc_u32 read_item(rp_item_t *ri, hcc_u8 ndx)
{
  hcc_u32 val=0;
  hcc_u32 x=0;
  hcc_u32 bofs;
  hcc_u8 *data=ri->data;
  hcc_u8 shift=ri->shift;

  /* get the logical value of the item */

  /* if this is an array, wee may need to offset ri->data.*/
  if (ri->count > 0)
  {
    /* If app tries to read outside of the array. */
    if (ri->count <= ndx)
    {
      return(0);
    }

    /* calculate bit offset */
    bofs = ndx*ri->size;
    bofs += shift;
    /* calculate byte offset + shift pair from bit offset. */
    data+=bofs/8;
    shift=(hcc_u8)(bofs%8);
  }
  /* read data bytes in little endian order */
  for(x=0; x < ((ri->size & 0x7) ? (ri->size/8)+1 : (ri->size/8)); x++)
  {
    val=(hcc_u32)(*data << (x*8));
  }
  val=(val >> shift) & ((1<<ri->size)-1);

  if (val < ri->logical_min || val > ri->logical_max)
  {
    return(0);
  }

  /* convert logical value to physical value */
  /* See if the number is negative or not. */
  if ((ri->sign) && (val & (1<<(ri->size-1))))
  {
    /* yes, so sign extend value to 32 bits. */
    int vs=(int)((-1 & ~((1<<(ri->size))-1)) | val);

    if(ri->resolution == 1)
    {
      return((hcc_u32)vs);
    }
    return((hcc_u32)(vs*ri->resolution));
  }
  else
  {
    if(ri->resolution == 1)
    {
      return(val);
    }
    return(val*ri->resolution);
  }
}

hcc_u32 write_item(rp_item_t *ri, hcc_u32 value, hcc_u8 ndx)
{
  hcc_u32 x;
  hcc_u32 mask;
  hcc_u32 bofs;
  hcc_u8 *data=ri->data;
  hcc_u8 shift=ri->shift;

  if (value < ri->physical_min || value > ri->physical_max)
  {
    return(1);
  }

    /* if this is an array, wee may need to offset ri->data.*/
  if (ri->count > 0)
  {
    /* If app tries to read outside of the array. */
    if (ri->count >= ndx)
    {
      return(0);
    }
    /* calculate bit offset */
    bofs = ndx*ri->size;
    bofs += shift;
    /* calculate byte offset + shift pair from bit offset. */
    data+=bofs/8;
    shift=(hcc_u8)(bofs%8);

  }

  /* Convert physical value to logical value. */
  if (ri->resolution != 1)
  {
    value=value/ri->resolution;
  }

  /* Write logical value to report in little endian order. */
  mask=(hcc_u32)((1<<ri->size)-1);
  value = (value & mask) << shift;

  for(x=0; x < ((ri->size & 0x7) ? (ri->size/8)+1 : (ri->size/8)); x++)
  {
    *(ri->data+x)=(hcc_u8)((*(ri->data+x) & ~(mask>>(x*8))) | ((value>>(x*8)) & (mask>>(x*8))));
  }
  return(0);
}
/****************************** END OF FILE **********************************/
%-*****************************************************************************************************
%FILE %'DirRel_Code'mcf5xxx_lo.s
%-*****************************************************************************************************


/*
 * File:    mcf5xxx.s
 * Purpose: Lowest level routines for all ColdFire processors.
 *
 * Notes:
 *
 */


    .global asm_set_ipl
    .global _asm_set_ipl
    .global _mcf5xxx_byterev

    .text



/********************************************************************/
/*
 * This routines changes the IPL to the value passed into the routine.
 * It also returns the old IPL value back.
 * Calling convention from C:
 *   old_ipl = asm_set_ipl(new_ipl);
 * For the Diab Data C compiler, it passes return value thru D0.
 * Note that only the least significant three bits of the passed
 * value are used.
 */

asm_set_ipl:
_asm_set_ipl:
    link    A6,#-12
    movem.l D6-D7,(SP)

    move.w  SR,D7       /* current sr    */

    move.l  D7,D6       /* prepare return value  */
    andi.l  #0x0700,D6  /* mask out IPL  */
    lsr.l   #8,D6       /* IPL   */


    andi.l  #0x07,D0        /* least significant three bits  */
    lsl.l   #8,D0           /* move over to make mask    */

    andi.l  #0x0000F8FF,D7  /* zero out current IPL  */
    or.l    D0,D7           /* place new IPL in sr   */
    move.w  D7,SR

    move.w  d6,d0
    movem.l (SP),D6-D7
    lea     8(SP),SP
    unlk    A6
    rts


_mcf5xxx_byterev:
    .short   0x02c0      /* byterev.l, D0   */
    rts


/********************************************************************/
    .end
%-*****************************************************************************************************
%FILE %'DirRel_Code'host_hid_joy.h
%-*****************************************************************************************************
/***************************************************************************
 *
 *            Copyright (c) 2006-2007 by CMX Systems, Inc.
 *
 * This software is copyrighted by and is the sole property of
 * CMX.  All rights, title, ownership, or other interests
 * in the software remain the property of CMX.  This
 * software may only be used in accordance with the corresponding
 * license agreement.  Any unauthorized use, duplication, transmission,
 * distribution, or disclosure of this software is expressly forbidden.
 *
 * This Copyright notice may not be removed or modified without prior
 * written consent of CMX.
 *
 * CMX reserves the right to modify this software without notice.
 *
 * CMX Systems, Inc.
 * 12276 San Jose Blvd. #511
 * Jacksonville, FL 32223
 * USA
 *
 * Tel:  (904) 880-1840
 * Fax:  (904) 880-1632
 * http: www.cmx.com
 * email: cmx@cmx.com
 *
 ***************************************************************************/
#ifndef _HOST_HID_JOY_H_
#define _HOST_HID_JOY_H_

extern void hid_joy_init(void);
extern hcc_u16 hid_joy_get_x(void);
extern hcc_u16 hid_joy_get_y(void);
extern hcc_u16 hid_joy_get_rz(void);
extern hcc_u16 hid_joy_get_slider(void);
extern hcc_u8 hid_joy_get_button(hcc_u8 b);
extern hcc_u16 hid_joy_get_hat(void);
extern int hid_joy_process(void);

#endif
/****************************** END OF FILE **********************************/
%-*****************************************************************************************************
%FILE %'DirRel_Code'host_hid_joy.c
%-*****************************************************************************************************
/***************************************************************************
 *
 *            Copyright (c) 2006-2007 by CMX Systems, Inc.
 *
 * This software is copyrighted by and is the sole property of
 * CMX.  All rights, title, ownership, or other interests
 * in the software remain the property of CMX.  This
 * software may only be used in accordance with the corresponding
 * license agreement.  Any unauthorized use, duplication, transmission,
 * distribution, or disclosure of this software is expressly forbidden.
 *
 * This Copyright notice may not be removed or modified without prior
 * written consent of CMX.
 *
 * CMX reserves the right to modify this software without notice.
 *
 * CMX Systems, Inc.
 * 12276 San Jose Blvd. #511
 * Jacksonville, FL 32223
 * USA
 *
 * Tel:  (904) 880-1840
 * Fax:  (904) 880-1632
 * http: www.cmx.com
 * email: cmx@cmx.com
 *
 ***************************************************************************/
//#include "target.h"
#include "usb_host.h"
#include "usb_utils.h"
#include "hid_usage.h"
#include "host_hid.h"
#include "host_hid_joy.h"
#include "hid_parser.h"
#define HJST_INVALID    0u
#define HJST_ACTIVE     1u
/* Joystick state info.  */
struct {
  hcc_u16 x;
  hcc_u16 y;
  hcc_u16 rz;
  hcc_u16 slider;
  hcc_u16 hat;
  hcc_u8 buttons[6];
  hcc_u8 in_report_data[6];
  hcc_u8 state;
} static hid_joy_info;
/* These structures define how to access items in a HID joy report */
static rp_item_t imp_0_x={
  hid_joy_info.in_report_data+0, /*data*/
  8,     /*size*/
  0,     /*shift*/
  0,     /*count (only for array items)*/
  0,     /*signed?*/
  0,     /*min value read can return*/
  0xff,  /*max value read can return*/
  0,     /*min value device can report*/
  0xff,  /*max value device can report*/
  1      /*resolution*/
};
static rp_item_t imp_0_y={
  hid_joy_info.in_report_data+1, /*data*/
  8,     /*size*/
  0,     /*shift*/
  0,     /*count (only for array items)*/
  0,     /*signed?*/
  0,     /*min value read can return*/
  0xff,  /*max value read can return*/
  0,     /*min value device can report*/
  0xff,  /*max value device can report*/
  1      /*resolution*/
};
static rp_item_t imp_0_rz={
  hid_joy_info.in_report_data+2, /*data*/
  8,     /*size*/
  0,     /*shift*/
  0,     /*count (only for array items)*/
  0,     /*signed?*/
  0,     /*min value read can return*/
  0xff,  /*max value read can return*/
  0,     /*min value device can report*/
  0xff,  /*max value device can report*/
  1      /*resolution*/
};
static rp_item_t imp_0_slider={
  hid_joy_info.in_report_data+3, /*data*/
  8,     /*size*/
  0,     /*shift*/
  0,     /*count (only for array items)*/
  0,     /*signed?*/
  0,     /*min value read can return*/
  0xff,  /*max value read can return*/
  0,     /*min value device can report*/
  0xff,  /*max value device can report*/
  1      /*resolution*/
};
static rp_item_t imp_0_hat={
  hid_joy_info.in_report_data+4, /*data*/
  4,     /*size*/
  0,     /*shift*/
  0,     /*count (only for array items)*/
  0,     /*signed?*/
  1,     /*min value read can return*/
  8,     /*max value read can return*/
  0,     /*min value device can report*/
  0x13b, /*max value device can report*/
  0x2D   /*resolution*/
};
static rp_item_t imp_0_b1={
  hid_joy_info.in_report_data+4, /*data*/
  1,     /*size*/
  4,     /*shift*/
  0,     /*count (only for array items)*/
  0,     /*signed?*/
  0,     /*min value read can return*/
  1,     /*max value read can return*/
  0,     /*min value device can report*/
  1,     /*max value device can report*/
  1      /*resolution*/
};
static rp_item_t imp_0_b2={
  hid_joy_info.in_report_data+4, /*data*/
  1,     /*size*/
  5,     /*shift*/
  0,     /*count (only for array items)*/
  0,     /*signed?*/
  0,     /*min value read can return*/
  1,     /*max value read can return*/
  0,     /*min value device can report*/
  1,     /*max value device can report*/
  1      /*resolution*/
};
static rp_item_t imp_0_b3={
  hid_joy_info.in_report_data+4, /*data*/
  1,     /*size*/
  6,     /*shift*/
  0,     /*count (only for array items)*/
  0,     /*signed?*/
  0,     /*min value read can return*/
  1,     /*max value read can return*/
  0,     /*min value device can report*/
  1,     /*max value device can report*/
  1      /*resolution*/
};
static rp_item_t imp_0_b4={
  hid_joy_info.in_report_data+4, /*data*/
  1,     /*size*/
  7,     /*shift*/
  0,     /*count (only for array items)*/
  0,     /*signed?*/
  0,     /*min value read can return*/
  1,     /*max value read can return*/
  0,     /*min value device can report*/
  1,     /*max value device can report*/
  1      /*resolution*/
};
static rp_item_t imp_0_b5={
  hid_joy_info.in_report_data+5, /*data*/
  1,     /*size*/
  0,     /*shift*/
  0,     /*count (only for array items)*/
  0,     /*signed?*/
  0,     /*min value read can return*/
  1,     /*max value read can return*/
  0,     /*min value device can report*/
  1,     /*max value device can report*/
  1      /*resolution*/
};
static rp_item_t imp_0_b6={
  hid_joy_info.in_report_data+5, /*data*/
  1,     /*size*/
  1,     /*shift*/
  0,     /*count (only for array items)*/
  0,     /*signed?*/
  0,     /*min value read can return*/
  1,     /*max value read can return*/
  0,     /*min value device can report*/
  1,     /*max value device can report*/
  1      /*resolution*/
};
static hcc_u8 out_report0_buffer[3];
static rp_item_t out_0_bcr={
  out_report0_buffer+0, /*data*/
  24,    /*size*/
  0,     /*shift*/
  0,     /*count (only for array items)*/
  0,     /*signed?*/
  0,     /*min value device can return*/
  0xff,  /*max value device can return*/
  0,     /*min vale read can report*/
  0,     /*max value read can report*/
  1      /*resolution*/
};
static hcc_u8 feat_report0_buffer[3];
static rp_item_t feat_0_bcr={
  feat_report0_buffer+0, /*data*/
  24,    /*size*/
  0,     /*shift*/
  0,     /*count (only for array items)*/
  0,     /*signed?*/
  0,     /*min value device can return*/
  0xff,  /*max value device can return*/
  0,     /*min vale read can report*/
  0,     /*max value read can report*/
  1      /*resolution*/
};

static report_tree_item_t xtrust_report_tree[] = {
  {0x0001, 0x0004, 0x0000, 0, 0},
  {0x0001, 0x0001, 0x0000, 1, 0},
  {0x0001, 0x0001, 0x0000, 2, 0},
  {0x0001, 0x0030, 0x0000, 2, &imp_0_x},
  {0x0001, 0x0031, 0x0000, 2, &imp_0_y},
  {0x0001, 0x0035, 0x0000, 2, &imp_0_rz},
  {0x0001, 0x0036, 0x0000, 2, &imp_0_slider},
  {0x0001, 0x0039, 0x0000, 2, &imp_0_hat},
  {0x0009, 0x0001, 0x0000, 2, &imp_0_b1},
  {0x0009, 0x0002, 0x0000, 2, &imp_0_b2},
  {0x0009, 0x0003, 0x0000, 2, &imp_0_b3},
  {0x0009, 0x0004, 0x0000, 2, &imp_0_b4},
  {0x0009, 0x0005, 0x0000, 2, &imp_0_b5},
  {0x0009, 0x0006, 0x0000, 2, &imp_0_b6},
  {0x0000, 0x0000, 0xff, 0}
};
/****************** HID joy stuff *************************/
/* joy states */
void hid_joy_init(void)
{
  hid_joy_info.state=HJST_INVALID;
  hid_joy_info.x=0;
  hid_joy_info.y=0;
  hid_joy_info.rz=0;
  hid_joy_info.slider=0;
  hid_joy_info.hat=0;
  hid_joy_info.buttons[0]=0;
  hid_joy_info.buttons[1]=0;
  hid_joy_info.buttons[2]=0;
  hid_joy_info.buttons[3]=0;
  hid_joy_info.in_report_data[0]=0;
  hid_joy_info.in_report_data[1]=0;
  hid_joy_info.in_report_data[2]=0;
  hid_joy_info.in_report_data[3]=0;
  hid_joy_info.in_report_data[4]=0;
  hid_joy_info.in_report_data[5]=0;
}
hcc_u16 hid_joy_get_x(void)
{
  return(hid_joy_info.x);
}
hcc_u16 hid_joy_get_y(void)
{
  return(hid_joy_info.y);
}
hcc_u16 hid_joy_get_rz(void)
{
  return(hid_joy_info.rz);
}
hcc_u16 hid_joy_get_slider(void)
{
  return(hid_joy_info.slider);
}
hcc_u16 hid_joy_get_hat(void)
{
  return(hid_joy_info.hat);
}
hcc_u8 hid_joy_get_button(hcc_u8 b)
{
  if (b>sizeof(hid_joy_info.buttons)/sizeof(hid_joy_info.buttons[0]))
  {
    return(0);
  }
  return(hid_joy_info.buttons[b]);
}
static void hid_joy_convert(void)
{
  hid_joy_info.x=(hcc_u16)read_item(&imp_0_x, 0);
  hid_joy_info.y=(hcc_u16)read_item(&imp_0_y, 0 );
  hid_joy_info.rz=(hcc_u16)read_item(&imp_0_rz, 0 );
  hid_joy_info.slider=(hcc_u16)read_item(&imp_0_slider, 0 );
  hid_joy_info.hat=(hcc_u16)read_item(&imp_0_hat, 0 );
  hid_joy_info.buttons[0]=(hcc_u8)read_item(&imp_0_b1, 0);
  hid_joy_info.buttons[1]=(hcc_u8)read_item(&imp_0_b2, 0);
  hid_joy_info.buttons[2]=(hcc_u8)read_item(&imp_0_b3, 0);
  hid_joy_info.buttons[3]=(hcc_u8)read_item(&imp_0_b4, 0);
  hid_joy_info.buttons[4]=(hcc_u8)read_item(&imp_0_b5, 0);
  hid_joy_info.buttons[5]=(hcc_u8)read_item(&imp_0_b6, 0);
}
int hid_joy_process(void)
{
  hcc_u32 r;
  switch(hid_joy_info.state)
  {
  case HJST_INVALID:

    /* Since we use the values we already have when converiong, we set all our
       variables to default state (0). */
    hid_joy_init();
    hid_joy_info.state=HJST_ACTIVE;
    /* yes, there is no break. */
  case HJST_ACTIVE:
    /* Get next report from device. */
    r=host_receive(hid_joy_info.in_report_data, sizeof(hid_joy_info.in_report_data), hid_info.in_it_ep);
    switch (r)
    {
    default:
    case -1u:
      /* Error reading data. Assume device hs been disconnected. */
      return(1);
    case sizeof(hid_joy_info.in_report_data):
      /* Right number of bytes received. Convert readed relative data to absolute
         values. */
      hid_joy_convert();
      break;
    case 0:
      /* Device has no datat to send. See if device is still connected. */
      if (!host_has_device())
      {
        return(1);
      }
      break;
    }
    break;
  }
  return(0);
}
/****************************** END OF FILE **********************************/

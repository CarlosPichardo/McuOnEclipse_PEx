%-Driver generated by the Bean Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Bean Wizard
%- If you change these lines, Bean Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    26.12.2009
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%define! Description_ReadTouchAxis Returns the value of the given channel
%define! Description_GetFilteredAxis Reads from the given channel and determines if a touch has been detected.
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\TouchScreenSensorSettings.Inc
%define! Abstract Common\TouchScreenSensorAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
typedef word %'ModuleName'_TouchSensorValue;                     %>40/* we get 16bit values from the sensor */

/* Constants specifying sensor values */
#define %'ModuleName'%.AD_RESOLUTION  %@ADConverter@ADresolution %>40/* A/D Converter number of bits */
#define %'ModuleName'%.AD_TYPE_BITS   16                         %>40/* how many bits we are using for the A/D value/type */
#define %'ModuleName'%.AD_RSHIFT_CNT  (%'ModuleName'%.AD_TYPE_BITS-%'ModuleName'%.AD_RESOLUTION)%>40/* The A/D component gives us left aligned result: we need to right shift it */
#define %'ModuleName'%.FULL_SCALE     (0xFFFF>>%'ModuleName'%.AD_RSHIFT_CNT)%>40/* bit mask of maximum A/D result (right justified) */

#define %'ModuleName'%.TOUCH_MAX      ((%'ModuleName'%.FULL_SCALE * %MaximumTouchPercent)/100) /* user defined percentage, touches are recognized below this value */
#define %'ModuleName'%.TOUCH_MIN      ((%'ModuleName'%.FULL_SCALE * %MinimumTouchPercent)/100) /* user defined percentage, touches are recognized above this value */
#define %'ModuleName'%.X_TOUCH_MIN    %'ModuleName'%.TOUCH_MIN
#define %'ModuleName'%.Y_TOUCH_MIN    %'ModuleName'%.TOUCH_MIN
#define %'ModuleName'%.X_TOUCH_OFFMAX (%'ModuleName'%.X_TOUCH_MIN * 4 / 2)
#define %'ModuleName'%.Y_TOUCH_OFFMAX (%'ModuleName'%.Y_TOUCH_MIN * 4 / 2)
#define %'ModuleName'%.SAMPLE_MARGIN  (%'ModuleName'%.FULL_SCALE / 256) /* defines the allowed noise band to recognize a touch */
%-
%-BW_CUSTOM_USERTYPE_END


%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetPositionRaw
%ifdef GetPositionRaw
bool %'ModuleName'%.%GetPositionRaw(%'ModuleName'_TouchSensorValue *TouchPositionX, %'ModuleName'_TouchSensorValue *TouchPositionY);
%define! ParTouchPositionX
%define! ParTouchPositionY
%define! RetVal
%include Common\TouchScreenSensorGetPositionRaw.Inc

%endif %- GetPositionRaw
%-BW_METHOD_END GetPositionRaw
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
void %'ModuleName'%.%Init(void);
%include Common\TouchScreenSensorInit.Inc

%endif %- Init
%-BW_METHOD_END Init
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_METHOD_BEGIN OnADGet
%ifdef OnADGet
%INTERFACE OnADGet
void %OnADGet(void);
%include Common\TouchScreenSensorOnADGet.Inc

%endif %- OnADGet
%-BW_METHOD_END OnADGet
%-BW_METHOD_BEGIN OnADGive
%ifdef OnADGive
%INTERFACE OnADGive
void %OnADGive(void);
%include Common\TouchScreenSensorOnADGive.Inc

%endif %- OnADGive
%-BW_METHOD_END OnADGive
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\TouchScreenSensorSettings.Inc
%define! Abstract Common\TouchScreenSensorAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;

/* X+ wire definition */
#define %'ModuleName'%.X_PLUS_ADCH                 %XplusChannel %>40/* A/D converter channel for X+ wire */
#define %'ModuleName'%.X_PLUS_ADCH_PIN_CONNECT     %XplusConnect %>40/* macro to connect X+ pin to the A/D converter */
#define %'ModuleName'%.X_PLUS_ADCH_PIN_DISCONNECT  %XplusDisconnect%>40/* macro to disconnect X+ pin from the A/D converter and to use it as digital I/O */

/* Y+ wire definition */
#define %'ModuleName'%.Y_PLUS_ADCH                 %YplusChannel %>40/* A/D converter channel for Y+ wire */
#define %'ModuleName'%.Y_PLUS_ADCH_PIN_CONNECT     %YplusConnect %>40/* macro to connect Y+ pin to the A/D converter */
#define %'ModuleName'%.Y_PLUS_ADCH_PIN_DISCONNECT  %YplusDisconnect%>40/* macro to disconnect Y+ pin from the A/D converter and to use it as digital I/O */

%-
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-UNLOCKED
/* Internal method prototypes */
%-INTERNAL_LOC_METHOD_BEG ReadTouchAxis
static word ReadTouchAxis(byte channel);
%-INTERNAL_LOC_METHOD_END ReadTouchAxis
%-INTERNAL_LOC_METHOD_BEG GetFilteredAxis
static bool GetFilteredAxis(byte channel, %'ModuleName'_TouchSensorValue *result);
%-INTERNAL_LOC_METHOD_END GetFilteredAxis
%-

%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG ReadTouchAxis
%define! Parchannel
%define! RetVal
%include Common\GeneralInternalGlobal.inc (ReadTouchAxis)
static word ReadTouchAxis(byte channel)
{
  byte res;
  word value;

%ifdef OnADGet
  %OnADGet();                                                    %>40/* call user event to get mutex */
%endif
  res = %@ADConverter@'ModuleName'%.MeasureChan(TRUE, channel);  %>40/* measure channel and wait for result */
  if (res==ERR_OK) {
    res = %@ADConverter@'ModuleName'%.GetChanValue16(channel, &value);
  }
%ifdef OnADGive
  %OnADGive();                                                   %>40/* call user event to return mutex */
%endif
  if (res==ERR_OK) {
    return (word)(value>>%'ModuleName'%.AD_RSHIFT_CNT);          %>40/* right justify the A/D bits (as left justified) */
  } else {
    return 0; /* failure */
  }
}

%-INTERNAL_METHOD_END ReadTouchAxis
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG GetFilteredAxis
%define! Parchannel
%define! Parresult
%define! RetVal
%include Common\GeneralInternalGlobal.inc (GetFilteredAxis)
static bool GetFilteredAxis(byte channel, %'ModuleName'_TouchSensorValue *result)
{
  #define %'ModuleName'%.AVERAGE_BUFF_LEN 6
  %'ModuleName'_TouchSensorValue wSample[%'ModuleName'%.AVERAGE_BUFF_LEN];
  %'ModuleName'_TouchSensorValue wRes, wSum;
  %'ModuleName'_TouchSensorValue wADCReading;
  byte tmp, tmp_res;
  byte cnt;

  /* clear all local variables and buffer  */
  for(tmp=0; tmp<%'ModuleName'%.AVERAGE_BUFF_LEN; tmp++) {
    wSample[tmp] = 0;
  }
  wSum = 0;
  cnt = 0;
  while (cnt < 0x50) {
    cnt++;
    /* Read ADC value */
    wADCReading = ReadTouchAxis(channel);
    /* check if input value is under minimal value */
    if(wADCReading>%'ModuleName'%.TOUCH_MAX || wADCReading<%'ModuleName'%.TOUCH_MIN) {
      break;
    }
    /* Compute the current output value */
    wSum += wADCReading;
    wSum -= wSample[%'ModuleName'%.AVERAGE_BUFF_LEN-1];
    /* shift all values in input buffer */
    for(tmp=%'ModuleName'%.AVERAGE_BUFF_LEN-1; tmp>0; tmp--) {
      wSample[tmp] = wSample[tmp-1];
    }
    /* put new value into buffer */
    wSample[0] = wADCReading;
    /* compute current result from all buffer values */
    wRes = (unsigned short)(wSum/%'ModuleName'%.AVERAGE_BUFF_LEN);
    /* if buffer is full */
    if(cnt>%'ModuleName'%.AVERAGE_BUFF_LEN) { /* buffer full */
      /* Check all input samples if are in allowed range */
      tmp_res = 0;
      for(tmp=0; tmp<%'ModuleName'%.AVERAGE_BUFF_LEN; tmp++) {
        if((wRes > (wSample[tmp]-%'ModuleName'%.SAMPLE_MARGIN)) && (wRes<(wSample[tmp]+%'ModuleName'%.SAMPLE_MARGIN))) {
          tmp_res++; /* count the number of samples inside the boundaries */
        }
      }
      /* If most of sample are in allowed range with output value, assert this sample as result */
      if(tmp_res >= (%'ModuleName'%.AVERAGE_BUFF_LEN-2)) {
        *result = wRes;
        return TRUE;                                             %>40/* touch detected */
      }
    } /* if */
  } /* while */
  return FALSE;                                                  %>40/* no touch */
}

%-INTERNAL_METHOD_END GetFilteredAxis
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetPositionRaw
%ifdef GetPositionRaw
%define! ParTouchPositionX
%define! ParTouchPositionY
%define! RetVal
%include Common\TouchScreenSensorGetPositionRaw.Inc
bool %'ModuleName'%.%GetPositionRaw(%'ModuleName'_TouchSensorValue *TouchPositionX, %'ModuleName'_TouchSensorValue *TouchPositionY)
{
  /* Declare and initialize local variables */
  %'ModuleName'_TouchSensorValue tmpRes;
  byte tmpCnt;
  bool bSampleComplete = FALSE;

  /* Switch on ADC channel on Y+ wire */
  %'ModuleName'%.Y_PLUS_ADCH_PIN_CONNECT;
  tmpCnt = 0;

  /* to check that the touch screen surface is without any voltage and prepared */
  while((ReadTouchAxis(%'ModuleName'%.Y_PLUS_ADCH)>%'ModuleName'%.Y_TOUCH_MIN) && (++tmpCnt)) {
  }
  /* when the touch screen surface is prepared switch on on X+ wire high level  */
  %@XplusIO@'ModuleName'%.SetVal();
  /* wait a moment */
  asm {nop};

  /* and Y- pin put into high Z mode to keep measurement non affected */
  %@YminusPin@'ModuleName'%.SetInput();
  asm {nop};

  /* read value of Y axis and check if touch screen is touched */
  if(GetFilteredAxis(%'ModuleName'%.Y_PLUS_ADCH, &tmpRes)) {
    /* if it's touched save the result of Y measurement */
    *TouchPositionY = tmpRes;

    /* Disable ADC function on Y+ */
    %'ModuleName'%.Y_PLUS_ADCH_PIN_DISCONNECT;

    /* Set pins to default values */
    %@XplusIO@'ModuleName'%.ClrVal();
    %@XminusPin@'ModuleName'%.ClrVal();
    %@YplusIO@'ModuleName'%.ClrVal();
    %@YminusPin@'ModuleName'%.ClrVal();
    %@YminusPin@'ModuleName'%.SetOutput();
    /* wait a moment */
    asm {nop};

    /* Switch on ADC channel on X+ wire */
    %'ModuleName'%.X_PLUS_ADCH_PIN_CONNECT;
    /* to check that the touch screen surface is without any voltage and prepared */
    tmpCnt = 0;
    while((ReadTouchAxis(%'ModuleName'%.X_PLUS_ADCH)>%'ModuleName'%.X_TOUCH_MIN) && (++tmpCnt)) {
    }

    /* when the touch screen surface is prepared switch on on Y+ wire high level */
    %@YplusIO@'ModuleName'%.SetVal();
    /* wait a moment */
    asm {nop};
    /* and X- pin put into high Z mode to keep measurement non affected */
    %@XminusPin@'ModuleName'%.SetInput();

    /* read value of X axis and check if touch screen is touched */
    if(GetFilteredAxis(%'ModuleName'%.X_PLUS_ADCH, &tmpRes)) {
      /* if it's touched save the result of X measurement */
      *TouchPositionX = tmpRes;
      bSampleComplete = TRUE;
    }
  }
  /* Disable ADC function on X+ and Y+ */
  %'ModuleName'%.X_PLUS_ADCH_PIN_DISCONNECT;
  %@XminusPin@'ModuleName'%.SetOutput();
  %'ModuleName'%.Y_PLUS_ADCH_PIN_DISCONNECT;
  %@YminusPin@'ModuleName'%.SetOutput();

  /* Put on touch screen pins into default mode */
  %@XplusIO@'ModuleName'%.ClrVal();
  %@XminusPin@'ModuleName'%.ClrVal();
  %@YplusIO@'ModuleName'%.ClrVal();;
  %@YminusPin@'ModuleName'%.ClrVal();

  /* return back result - if screen is touched or not */
  return bSampleComplete;
}

%endif %- GetPositionRaw
%-BW_METHOD_END GetPositionRaw
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%include Common\TouchScreenSensorInit.Inc
void %'ModuleName'%.%Init(void)
{
  %@XplusIO@'ModuleName'%.SetOutput(); %@XplusIO@'ModuleName'%.ClrVal();
  %@XminusPin@'ModuleName'%.SetOutput(); %@XminusPin@'ModuleName'%.ClrVal();
  %@YplusIO@'ModuleName'%.SetOutput(); %@YplusIO@'ModuleName'%.ClrVal();
  %@YminusPin@'ModuleName'%.SetOutput(); %@YminusPin@'ModuleName'%.ClrVal();
}

%endif %- Init
%-BW_METHOD_END Init
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_METHOD_BEGIN OnADGet
%ifdef OnADGet
%IMPLEMENTATION OnADGet
%include Common\TouchScreenSensorOnADGet.Inc
void %OnADGet(void)
{
  /* Write your code here ... */
}

%endif %- OnADGet
%-BW_METHOD_END OnADGet
%-BW_METHOD_BEGIN OnADGive
%ifdef OnADGive
%IMPLEMENTATION OnADGive
%include Common\TouchScreenSensorOnADGive.Inc
void %OnADGive(void)
{
  /* Write your code here ... */
}

%endif %- OnADGive
%-BW_METHOD_END OnADGive
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
%if InitializeOnInit='yes'
  %'ModuleName'%.Init();
%endif
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This bean is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-

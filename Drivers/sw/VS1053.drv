%-Driver generated by the Component Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Component Wizard
%- If you change these lines, Component Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    29.12.2014
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%define! Description_MIDI_Send Sends a MIDI data byte
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\VS1053Settings.Inc
%define! Abstract Common\VS1053Abstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
/* VS1053 Registers */
#define VS1053_MODE         0x00
  #define VS1053_MODE_SM_DIFF           (1<<0)
  #define VS1053_MODE_SM_LAYER12        (1<<1)
  #define VS1053_MODE_SM_RESET          (1<<2)
  #define VS1053_MODE_SM_CANCEL         (1<<3)
  #define VS1053_MODE_SM_EARSPEAKER_LO  (1<<4)
  #define VS1053_MODE_SM_TESTS          (1<<5)
  #define VS1053_MODE_SM_STREAM         (1<<6)
  #define VS1053_MODE_SM_EARSPEAKER_HI  (1<<7)
  #define VS1053_MODE_SM_DACT           (1<<8)
  #define VS1053_MODE_SM_SDIORD         (1<<9)
  #define VS1053_MODE_SM_SDISHARE       (1<<10)
  #define VS1053_MODE_SM_SDINEW         (1<<11)
  #define VS1053_MODE_SM_ADPCM          (1<<12)
  #define VS1053_MODE_SM_LINE1          (1<<14)
  #define VS1053_MODE_SM_SM_CLK_RANGE   (1<<15)

#define VS1053_STATUS       0x01
#define VS1053_BASS         0x02
#define VS1053_CLOCKF       0x03
#define VS1053_DECODE_TIME  0x04
#define VS1053_AUDATA       0x05
#define VS1053_WRAM         0x06
#define VS1053_WRAMADDR     0x07
#define VS1053_HDAT0        0x08
#define VS1053_HDAT1        0x09
#define VS1053_AIADDR       0x0A
#define VS1053_VOL          0x0B
#define VS1053_AICTRL0      0x0C
#define VS1053_AICTRL1      0x0D
#define VS1053_AICTRL2      0x0E
#define VS1053_AICTRL3      0x0F
#define VS1053_IO_DDR       0xC017
#define VS1053_IO_IDATA     0xC018
#define VS1053_IO_ODATA     0xC019

#define VS1053_PARA_END_FILL_BYTE 0x1E06 /*1e06 byte value to send after file sent */

%ifdef ParseCommand
#define %'ModuleName'%.PARSE_COMMAND_ENABLED  1 /* set to 1 if method ParseCommand() is present, 0 otherwise */
%else
#define %'ModuleName'%.PARSE_COMMAND_ENABLED  0 /* set to 1 if method ParseCommand() is present, 0 otherwise */
%endif %- ParseCommand

%if defined(WaitIfNotReady) & %WaitIfNotReady='yes' & defined(WaitNotReadyMs) & defined(Wait)
#define %'ModuleName'%.WAIT_IF_NOT_READY          1 /* Wait if not ready */
%else
#define %'ModuleName'%.WAIT_IF_NOT_READY          0 /* Wait if not ready */
%endif
#if %'ModuleName'%.WAIT_IF_NOT_READY
  #define %'ModuleName'%.WAIT_IF_NOT_READY_TIME_MS  %WaitNotReadyMs /* Wait if not ready */
  #define %'ModuleName'%.WAIT_IF_NOT_READY_WAIT()   %@Wait@'ModuleName'%.WaitOSms(%'ModuleName'%.WAIT_IF_NOT_READY_TIME_MS)
#else
  #define %'ModuleName'%.WAIT_IF_NOT_READY_WAIT()   /* nothing */
#endif

/* ---------------------------*/
/* MIDI support               */
/* ---------------------------*/
/* see http://www.midi.org/techspecs/midimessages.php for message format */
/* supported MIDI messages */
/* channel messages */
#define %'ModuleName'%.MIDI_MSG_CH_NOTE_OFF      0x80 /* channel message 'note off' */
#define %'ModuleName'%.MIDI_MSG_CH_NOTE_ON       0x90 /* channel message 'note on' */
#define %'ModuleName'%.MIDI_MSG_CH_PRG           0xC0 /* channel message 'program' */
#define %'ModuleName'%.MIDI_MSG_CH_PITCH_WHEEL   0xE0 /* channel message 'pitch wheel' */
#define %'ModuleName'%.MIDI_MSG_CH_PARAMETER     0xB0 /* channel message 'parameter' */
  #define %'ModuleName'%.MIDI_MSG_CH_PARAM_BANK_SELECT          0x00 /* bank select, 0 is default, 0x7f and 0x7f is drums, 0x79 melodic */
  #define %'ModuleName'%.MIDI_MSG_CH_PARAM_RPN_MSB              0x06 /* RPN MSB: 0 = bend range, 2 = coarse tune */
  #define %'ModuleName'%.MIDI_MSG_CH_PARAM_VOLUME               0x07 /* channel volume */
  #define %'ModuleName'%.MIDI_MSG_CH_PARAM_PAN                  0x0A /* pan */
  #define %'ModuleName'%.MIDI_MSG_CH_PARAM_EXPRESSION           0x0B /* expression (changes volume) */
  #define %'ModuleName'%.MIDI_MSG_CH_PARAM_ALL_SOUND_OFF        0x78 /* all sound off */

/* http://www.sengpielaudio.com/calculator-notenames.htm
Octave #  MIDI Note Numbers
          C   C#  D   D#  E   F   F#  G   G#  A   A#  B
-1        0   1   2   3   4   5   6   7   8   9  10  11
0        12  13  14  15  16  17  18  19  20  21  22  23
1        24  25  26  27  28  29  30  31  32  33  34  35
2        36  37  38  39  40  41  42  43  44  45  46  47
3        48  49  50  51  52  53  54  55  56  57  58  59
4        60  61  62  63  64  65  66  67  68  69  70  71
5        72  73  74  75  76  77  78  79  80  81  82  83
6        84  85  86  87  88  89  90  91  92  93  94  95
7        96  97  98  99 100 101 102 103 104 105 106 107
8       108 109 110 111 112 113 114 115 116 117 118 119
9       120 121 122 123 124 125 126 127
*/
/* 'm' is for -1 octave, 'h' is for '#' */
/* Octave -1 */
#define %'ModuleName'%.MIDI_NOTE_Cm     0
#define %'ModuleName'%.MIDI_NOTE_Chm    1
#define %'ModuleName'%.MIDI_NOTE_Dm     2
#define %'ModuleName'%.MIDI_NOTE_Dhm    3
#define %'ModuleName'%.MIDI_NOTE_Em     4
#define %'ModuleName'%.MIDI_NOTE_Fm     5
#define %'ModuleName'%.MIDI_NOTE_Fhm    6
#define %'ModuleName'%.MIDI_NOTE_Gm     7
#define %'ModuleName'%.MIDI_NOTE_Ghm    8
#define %'ModuleName'%.MIDI_NOTE_Am     9
#define %'ModuleName'%.MIDI_NOTE_Ahm   10
#define %'ModuleName'%.MIDI_NOTE_Bm    11
/* Octave 0 */
#define %'ModuleName'%.MIDI_NOTE_C0    12
#define %'ModuleName'%.MIDI_NOTE_Ch0   13
#define %'ModuleName'%.MIDI_NOTE_D0    14
#define %'ModuleName'%.MIDI_NOTE_Dh0   15
#define %'ModuleName'%.MIDI_NOTE_E0    16
#define %'ModuleName'%.MIDI_NOTE_F0    17
#define %'ModuleName'%.MIDI_NOTE_Fh0   18
#define %'ModuleName'%.MIDI_NOTE_G0    19
#define %'ModuleName'%.MIDI_NOTE_Gh0   20
#define %'ModuleName'%.MIDI_NOTE_A0    21
#define %'ModuleName'%.MIDI_NOTE_Ah0   22
#define %'ModuleName'%.MIDI_NOTE_B0    23
/* Octave 1 */
#define %'ModuleName'%.MIDI_NOTE_C1    24
#define %'ModuleName'%.MIDI_NOTE_Ch1   25
#define %'ModuleName'%.MIDI_NOTE_D1    26
#define %'ModuleName'%.MIDI_NOTE_Dh1   27
#define %'ModuleName'%.MIDI_NOTE_E1    28
#define %'ModuleName'%.MIDI_NOTE_F1    29
#define %'ModuleName'%.MIDI_NOTE_Fh1   30
#define %'ModuleName'%.MIDI_NOTE_G1    31
#define %'ModuleName'%.MIDI_NOTE_Gh1   32
#define %'ModuleName'%.MIDI_NOTE_A1    33
#define %'ModuleName'%.MIDI_NOTE_Ah1   34
#define %'ModuleName'%.MIDI_NOTE_B1    35
/* Octave 2 */
#define %'ModuleName'%.MIDI_NOTE_C2    36
#define %'ModuleName'%.MIDI_NOTE_Ch2   37
#define %'ModuleName'%.MIDI_NOTE_D2    38
#define %'ModuleName'%.MIDI_NOTE_Dh2   39
#define %'ModuleName'%.MIDI_NOTE_E2    40
#define %'ModuleName'%.MIDI_NOTE_F2    41
#define %'ModuleName'%.MIDI_NOTE_Fh2   42
#define %'ModuleName'%.MIDI_NOTE_G2    43
#define %'ModuleName'%.MIDI_NOTE_Gh2   44
#define %'ModuleName'%.MIDI_NOTE_A2    45
#define %'ModuleName'%.MIDI_NOTE_Ah2   46
#define %'ModuleName'%.MIDI_NOTE_B2    47
/* Octave 3 */
#define %'ModuleName'%.MIDI_NOTE_C3    48
#define %'ModuleName'%.MIDI_NOTE_Ch3   49
#define %'ModuleName'%.MIDI_NOTE_D3    50
#define %'ModuleName'%.MIDI_NOTE_Dh3   51
#define %'ModuleName'%.MIDI_NOTE_E3    52
#define %'ModuleName'%.MIDI_NOTE_F3    53
#define %'ModuleName'%.MIDI_NOTE_Fh3   54
#define %'ModuleName'%.MIDI_NOTE_G3    55
#define %'ModuleName'%.MIDI_NOTE_Gh3   56
#define %'ModuleName'%.MIDI_NOTE_A3    57
#define %'ModuleName'%.MIDI_NOTE_Ah3   58
#define %'ModuleName'%.MIDI_NOTE_B3    59
/* Octave 4 */
#define %'ModuleName'%.MIDI_NOTE_C4    60
#define %'ModuleName'%.MIDI_NOTE_Ch4   61
#define %'ModuleName'%.MIDI_NOTE_D4    62
#define %'ModuleName'%.MIDI_NOTE_Dh4   63
#define %'ModuleName'%.MIDI_NOTE_E4    64
#define %'ModuleName'%.MIDI_NOTE_F4    65
#define %'ModuleName'%.MIDI_NOTE_Fh4   66
#define %'ModuleName'%.MIDI_NOTE_G4    67
#define %'ModuleName'%.MIDI_NOTE_Gh4   68
#define %'ModuleName'%.MIDI_NOTE_A4    69
#define %'ModuleName'%.MIDI_NOTE_Ah4   70
#define %'ModuleName'%.MIDI_NOTE_B4    71
/* Octave 5 */
#define %'ModuleName'%.MIDI_NOTE_C5    72
#define %'ModuleName'%.MIDI_NOTE_Ch5   73
#define %'ModuleName'%.MIDI_NOTE_D5    74
#define %'ModuleName'%.MIDI_NOTE_Dh5   75
#define %'ModuleName'%.MIDI_NOTE_E5    76
#define %'ModuleName'%.MIDI_NOTE_F5    77
#define %'ModuleName'%.MIDI_NOTE_Fh5   78
#define %'ModuleName'%.MIDI_NOTE_G5    79
#define %'ModuleName'%.MIDI_NOTE_Gh5   80
#define %'ModuleName'%.MIDI_NOTE_A5    81
#define %'ModuleName'%.MIDI_NOTE_Ah5   82
#define %'ModuleName'%.MIDI_NOTE_B5    83
/* Octave 6 */
#define %'ModuleName'%.MIDI_NOTE_C6    84
#define %'ModuleName'%.MIDI_NOTE_Ch6   85
#define %'ModuleName'%.MIDI_NOTE_D6    86
#define %'ModuleName'%.MIDI_NOTE_Dh6   87
#define %'ModuleName'%.MIDI_NOTE_E6    88
#define %'ModuleName'%.MIDI_NOTE_F6    89
#define %'ModuleName'%.MIDI_NOTE_Fh6   90
#define %'ModuleName'%.MIDI_NOTE_G6    91
#define %'ModuleName'%.MIDI_NOTE_Gh6   92
#define %'ModuleName'%.MIDI_NOTE_A6    93
#define %'ModuleName'%.MIDI_NOTE_Ah6   94
#define %'ModuleName'%.MIDI_NOTE_B6    95
/* Octave 7 */
#define %'ModuleName'%.MIDI_NOTE_C7    96
#define %'ModuleName'%.MIDI_NOTE_Ch7   97
#define %'ModuleName'%.MIDI_NOTE_D7    98
#define %'ModuleName'%.MIDI_NOTE_Dh7   99
#define %'ModuleName'%.MIDI_NOTE_E7   100
#define %'ModuleName'%.MIDI_NOTE_F7   101
#define %'ModuleName'%.MIDI_NOTE_Fh7  102
#define %'ModuleName'%.MIDI_NOTE_G7   103
#define %'ModuleName'%.MIDI_NOTE_Gh7  104
#define %'ModuleName'%.MIDI_NOTE_A7   105
#define %'ModuleName'%.MIDI_NOTE_Ah7  106
#define %'ModuleName'%.MIDI_NOTE_B7   107
/* Octave 8 */
#define %'ModuleName'%.MIDI_NOTE_C8   108
#define %'ModuleName'%.MIDI_NOTE_Ch8  109
#define %'ModuleName'%.MIDI_NOTE_D8   110
#define %'ModuleName'%.MIDI_NOTE_Dh8  111
#define %'ModuleName'%.MIDI_NOTE_E8   112
#define %'ModuleName'%.MIDI_NOTE_F8   113
#define %'ModuleName'%.MIDI_NOTE_Fh8  114
#define %'ModuleName'%.MIDI_NOTE_G8   115
#define %'ModuleName'%.MIDI_NOTE_Gh8  116
#define %'ModuleName'%.MIDI_NOTE_A8   117
#define %'ModuleName'%.MIDI_NOTE_Ah8  118
#define %'ModuleName'%.MIDI_NOTE_B8   119
/* Octave 9 */
#define %'ModuleName'%.MIDI_NOTE_C9   120
#define %'ModuleName'%.MIDI_NOTE_Ch9  121
#define %'ModuleName'%.MIDI_NOTE_D9   122
#define %'ModuleName'%.MIDI_NOTE_Dh9  123
#define %'ModuleName'%.MIDI_NOTE_E9   124
#define %'ModuleName'%.MIDI_NOTE_F9   125
#define %'ModuleName'%.MIDI_NOTE_Fh9  126
#define %'ModuleName'%.MIDI_NOTE_G9   127

/* GM1 instruments */
#define %'ModuleName'%.MIDI_INSTR_Default               0
#define %'ModuleName'%.MIDI_INSTR_AcousticGrandPiano    1
#define %'ModuleName'%.MIDI_INSTR_PanFlute              76
#define %'ModuleName'%.MIDI_INSTR_GuitarFretNoise       121
#define %'ModuleName'%.MIDI_INSTR_BreatNoise            122
#define %'ModuleName'%.MIDI_INSTR_Seashore              123
#define %'ModuleName'%.MIDI_INSTR_BirdTweet             124
#define %'ModuleName'%.MIDI_INSTR_TelephoneRing         125
#define %'ModuleName'%.MIDI_INSTR_Helicopter            126
#define %'ModuleName'%.MIDI_INSTR_Applause              127
#define %'ModuleName'%.MIDI_INSTR_GunShot               128

%-
%-BW_CUSTOM_USERTYPE_END
%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseCommand
%ifdef ParseCommand
byte %'ModuleName'%.%ParseCommand(const unsigned char *cmd, bool *handled, const %@Shell@'ModuleName'%.StdIOType *io);
%define! Parcmd
%define! Parhandled
%define! Pario
%define! RetVal
%include Common\VS1053ParseCommand.Inc

%endif %- ParseCommand
%-BW_METHOD_END ParseCommand
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
byte %'ModuleName'%.%Deinit(void);
%define! RetVal
%include Common\VS1053Deinit.Inc

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
byte %'ModuleName'%.%Init(void);
%define! RetVal
%include Common\VS1053Init.Inc

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN IsReady
%ifdef IsReady
bool %'ModuleName'%.%IsReady(void);
%define! RetVal
%include Common\VS1053IsReady.Inc

%endif %- IsReady
%-BW_METHOD_END IsReady
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteRegister
%ifdef WriteRegister
byte %'ModuleName'%.%WriteRegister(byte reg, word value);
%define! Parreg
%define! Parvalue
%define! RetVal
%include Common\VS1053WriteRegister.Inc

%endif %- WriteRegister
%-BW_METHOD_END WriteRegister
%-************************************************************************************************************
%-BW_METHOD_BEGIN ActivateSPI
%ifdef ActivateSPI
byte %'ModuleName'%.%ActivateSPI(void);
%define! RetVal
%include Common\VS1053ActivateSPI.Inc

%endif %- ActivateSPI
%-BW_METHOD_END ActivateSPI
%-************************************************************************************************************
%-BW_METHOD_BEGIN DeactivateSPI
%ifdef DeactivateSPI
byte %'ModuleName'%.%DeactivateSPI(void);
%define! RetVal
%include Common\VS1053DeactivateSPI.Inc

%endif %- DeactivateSPI
%-BW_METHOD_END DeactivateSPI
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadRegister
%ifdef ReadRegister
byte %'ModuleName'%.%ReadRegister(byte reg, word *value);
%define! Parreg
%define! Parvalue
%define! RetVal
%include Common\VS1053ReadRegister.Inc

%endif %- ReadRegister
%-BW_METHOD_END ReadRegister
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendValues
%ifdef SendValues
byte %'ModuleName'%.%SendValues(word nofValues, byte value);
%define! ParnofValues
%define! Parvalue
%define! RetVal
%include Common\VS1053SendValues.Inc

%endif %- SendValues
%-BW_METHOD_END SendValues
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetVolume
%ifdef SetVolume
byte %'ModuleName'%.%SetVolume(byte left, byte right);
%define! Parleft
%define! Parright
%define! RetVal
%include Common\VS1053SetVolume.Inc

%endif %- SetVolume
%-BW_METHOD_END SetVolume
%-************************************************************************************************************
%-BW_METHOD_BEGIN StartSong
%ifdef StartSong
byte %'ModuleName'%.%StartSong(void);
%define! RetVal
%include Common\VS1053StartSong.Inc

%endif %- StartSong
%-BW_METHOD_END StartSong
%-************************************************************************************************************
%-BW_METHOD_BEGIN TerminateStreams
%ifdef TerminateStreams
byte %'ModuleName'%.%TerminateStreams(void);
%define! RetVal
%include Common\VS1053TerminateStreams.Inc

%endif %- TerminateStreams
%-BW_METHOD_END TerminateStreams
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendData
%ifdef SendData
byte %'ModuleName'%.%SendData(byte *data, size_t dataSize);
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\VS1053SendData.Inc

%endif %- SendData
%-BW_METHOD_END SendData
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteWRAM
%ifdef WriteWRAM
byte %'ModuleName'%.%WriteWRAM(word addr, word value);
%define! Paraddr
%define! Parvalue
%define! RetVal
%include Common\VS1053WriteWRAM.Inc

%endif %- WriteWRAM
%-BW_METHOD_END WriteWRAM
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadWRAM
%ifdef ReadWRAM
byte %'ModuleName'%.%ReadWRAM(word addr, word *value);
%define! Paraddr
%define! Parvalue
%define! RetVal
%include Common\VS1053ReadWRAM.Inc

%endif %- ReadWRAM
%-BW_METHOD_END ReadWRAM
%-************************************************************************************************************
%-BW_METHOD_BEGIN LoadUserCode
%ifdef LoadUserCode
byte %'ModuleName'%.%LoadUserCode(const uint16_t *data, word nofWords);
%define! Pardata
%define! ParnofWords
%define! RetVal
%include Common\VS1053LoadUserCode.Inc

%endif %- LoadUserCode
%-BW_METHOD_END LoadUserCode
%-************************************************************************************************************
%-BW_METHOD_BEGIN LoadRealtimeMidiPlugin
%ifdef LoadRealtimeMidiPlugin
byte %'ModuleName'%.%LoadRealtimeMidiPlugin(void);
%define! RetVal
%include Common\VS1053LoadRealtimeMidiPlugin.Inc

%endif %- LoadRealtimeMidiPlugin
%-BW_METHOD_END LoadRealtimeMidiPlugin
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG MIDI_Send
byte %'ModuleName'%.MIDI_Send(byte data);
%define! Pardata
%define! RetVal
%include Common\GeneralInternal.inc (MIDI_Send)

%-INTERNAL_METHOD_END MIDI_Send
%-************************************************************************************************************
%-BW_METHOD_BEGIN MIDI_Talk
%ifdef MIDI_Talk
byte %'ModuleName'%.%MIDI_Talk(byte cmd, byte data1, byte data2);
%define! Parcmd
%define! Pardata1
%define! Pardata2
%define! RetVal
%include Common\VS1053MIDI_Talk.Inc

%endif %- MIDI_Talk
%-BW_METHOD_END MIDI_Talk
%-************************************************************************************************************
%-BW_METHOD_BEGIN MIDI_NoteOn
%ifdef MIDI_NoteOn
byte %'ModuleName'%.%MIDI_NoteOn(byte channel, byte note, byte velocity);
%define! Parchannel
%define! Parnote
%define! Parvelocity
%define! RetVal
%include Common\VS1053MIDI_NoteOn.Inc

%endif %- MIDI_NoteOn
%-BW_METHOD_END MIDI_NoteOn
%-************************************************************************************************************
%-BW_METHOD_BEGIN MIDI_NoteOff
%ifdef MIDI_NoteOff
byte %'ModuleName'%.%MIDI_NoteOff(byte channel, byte note, byte velocity);
%define! Parchannel
%define! Parnote
%define! Parvelocity
%define! RetVal
%include Common\VS1053MIDI_NoteOff.Inc

%endif %- MIDI_NoteOff
%-BW_METHOD_END MIDI_NoteOff
%-************************************************************************************************************
%-BW_METHOD_BEGIN MIDI_SetVolume
%ifdef MIDI_SetVolume
byte %'ModuleName'%.%MIDI_SetVolume(byte channel, byte volume);
%define! Parchannel
%define! Parvolume
%define! RetVal
%include Common\VS1053MIDI_SetVolume.Inc

%endif %- MIDI_SetVolume
%-BW_METHOD_END MIDI_SetVolume
%-************************************************************************************************************
%-BW_METHOD_BEGIN MIDI_SetBank
%ifdef MIDI_SetBank
byte %'ModuleName'%.%MIDI_SetBank(byte channel, byte bank);
%define! Parchannel
%define! Parbank
%define! RetVal
%include Common\VS1053MIDI_SetBank.Inc

%endif %- MIDI_SetBank
%-BW_METHOD_END MIDI_SetBank
%-************************************************************************************************************
%-BW_METHOD_BEGIN MIDI_SetInstrument
%ifdef MIDI_SetInstrument
byte %'ModuleName'%.%MIDI_SetInstrument(byte channel, byte instrument);
%define! Parchannel
%define! Parinstrument
%define! RetVal
%include Common\VS1053MIDI_SetInstrument.Inc

%endif %- MIDI_SetInstrument
%-BW_METHOD_END MIDI_SetInstrument
%-************************************************************************************************************
%-BW_METHOD_BEGIN MIDI_SetPan
%ifdef MIDI_SetPan
byte %'ModuleName'%.%MIDI_SetPan(byte channel, byte pan);
%define! Parchannel
%define! Parpan
%define! RetVal
%include Common\VS1053MIDI_SetPan.Inc

%endif %- MIDI_SetPan
%-BW_METHOD_END MIDI_SetPan
%-************************************************************************************************************
%-BW_METHOD_BEGIN MIDI_AllSoundOff
%ifdef MIDI_AllSoundOff
byte %'ModuleName'%.%MIDI_AllSoundOff(byte channel);
%define! Parchannel
%define! RetVal
%include Common\VS1053MIDI_AllSoundOff.Inc

%endif %- MIDI_AllSoundOff
%-BW_METHOD_END MIDI_AllSoundOff
%-************************************************************************************************************
%-BW_METHOD_BEGIN SoftReset
%ifdef SoftReset
byte %'ModuleName'%.%SoftReset(void);
%define! RetVal
%include Common\VS1053SoftReset.Inc

%endif %- SoftReset
%-BW_METHOD_END SoftReset
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_METHOD_BEGIN OnActivateSPI
%ifdef OnActivateSPI
%INTERFACE OnActivateSPI
void %OnActivateSPI(void);
%include Common\VS1053OnActivateSPI.Inc

%endif %- OnActivateSPI
%-BW_METHOD_END OnActivateSPI
%-BW_METHOD_BEGIN OnDeactivateSPI
%ifdef OnDeactivateSPI
%INTERFACE OnDeactivateSPI
void %OnDeactivateSPI(void);
%include Common\VS1053OnDeactivateSPI.Inc

%endif %- OnDeactivateSPI
%-BW_METHOD_END OnDeactivateSPI
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\VS1053Settings.Inc
%define! Abstract Common\VS1053Abstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;

/*
 * Plugin to put VS10XX into realtime MIDI mode
 * Originally from http://www.vlsi.fi/fileadmin/software/VS10XX/vs1053b-rtmidistart.zip
 * Permission to reproduce here granted by VLSI solution.
 */
static const uint16_t %'ModuleName'%.Realtime_MIDI_Plugin[28] = { /* Compressed plugin */
  0x0007, 0x0001, 0x8050, 0x0006, 0x0014, 0x0030, 0x0715, 0xb080, /* 0 */
  0x3400, 0x0007, 0x9255, 0x3d00, 0x0024, 0x0030, 0x0295, 0x6890, /* 8 */
  0x3400, 0x0030, 0x0495, 0x3d00, 0x0024, 0x2908, 0x4d40, 0x0030, /* 10 */
  0x0200, 0x000a, 0x0001, 0x0050,
};

static uint8_t rxDummy; /* dummy byte if we do not need the result. Needed to read from SPI register. */
#define %'ModuleName'%.SPI_WRITE(write)            \
   { \
     while(%@SPI@'ModuleName'%.SendChar(write)!=ERR_OK) {} \
     while(%@SPI@'ModuleName'%.RecvChar(&rxDummy)!=ERR_OK) {} \
   }
#define %'ModuleName'%.SPI_WRITE_READ(write, readP) \
   { \
     while(%@SPI@'ModuleName'%.SendChar(write)!=ERR_OK) {} \
     while(%@SPI@'ModuleName'%.RecvChar(readP)!=ERR_OK) {} \
   }

/* macros to select device and to switch between data and control mode */
#define %'ModuleName'%.CONTROL_MODE_ON()    %@DCS@'ModuleName'%.SetVal(); %@MCS@'ModuleName'%.ClrVal()
#define %'ModuleName'%.CONTROL_MODE_OFF()   %@MCS@'ModuleName'%.SetVal()
#define %'ModuleName'%.DATA_MODE_ON()       %@MCS@'ModuleName'%.SetVal(); %@DCS@'ModuleName'%.ClrVal()
#define %'ModuleName'%.DATA_MODE_OFF()      %@DCS@'ModuleName'%.SetVal()

#define %'ModuleName'%.DATA_SIZE_BYTES      32  /* always 32 bytes of data */
#define %'ModuleName'%.BAUD_SPEED_INDEX     %SPIBaudMode   /* index as defined in properties */

%if defined(Shell)
static uint8_t PrintStatus(const %@Shell@'ModuleName'%.StdIOType *io) {
  uint8_t buf[48];
  uint16_t val;

  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"%'ModuleName'", (unsigned char*)"\r\n", io->stdOut);
  if (%'ModuleName'%.%ReadRegister(VS1053_MODE, &val)==ERR_OK) {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (uint8_t*)"0x");
    %@Utility@'ModuleName'%.strcatNum16Hex(buf, sizeof(buf), val);
    %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (uint8_t*)"\r\n");
  } else {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (uint8_t*)"ERROR\r\n");
  }
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  MODE", buf, io->stdOut);

  if (%'ModuleName'%.%ReadRegister(VS1053_STATUS, &val)==ERR_OK) {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (uint8_t*)"0x");
    %@Utility@'ModuleName'%.strcatNum16Hex(buf, sizeof(buf), val);
    %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (uint8_t*)"\r\n");
  } else {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (uint8_t*)"ERROR\r\n");
  }
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  STATUS", buf, io->stdOut);

  if (%'ModuleName'%.%ReadRegister(VS1053_BASS, &val)==ERR_OK) {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (uint8_t*)"0x");
    %@Utility@'ModuleName'%.strcatNum16Hex(buf, sizeof(buf), val);
    %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (uint8_t*)"\r\n");
  } else {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (uint8_t*)"ERROR\r\n");
  }
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  BASS", buf, io->stdOut);

  if (%'ModuleName'%.%ReadRegister(VS1053_CLOCKF, &val)==ERR_OK) {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (uint8_t*)"0x");
    %@Utility@'ModuleName'%.strcatNum16Hex(buf, sizeof(buf), val);
    %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (uint8_t*)"\r\n");
  } else {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (uint8_t*)"ERROR\r\n");
  }
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  CLOCKF", buf, io->stdOut);

  if (%'ModuleName'%.%ReadRegister(VS1053_DECODE_TIME, &val)==ERR_OK) {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (uint8_t*)"0x");
    %@Utility@'ModuleName'%.strcatNum16Hex(buf, sizeof(buf), val);
    %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (uint8_t*)" seconds\r\n");
  } else {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (uint8_t*)"ERROR\r\n");
  }
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  DECODE", buf, io->stdOut);

  if (%'ModuleName'%.%ReadRegister(VS1053_AUDATA, &val)==ERR_OK) {
    buf[0] = '\0';
    %@Utility@'ModuleName'%.Num16uToStr(buf, sizeof(buf), val&0xFFFE);
    %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (uint8_t*)" Hz, ");
    %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (val&1)?(uint8_t*)"stereo\r\n":(uint8_t*)"mono\r\n");
  } else {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (uint8_t*)"ERROR\r\n");
  }
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  AUDATA", buf, io->stdOut);

  if (%'ModuleName'%.%ReadRegister(VS1053_VOL, &val)==ERR_OK) {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (uint8_t*)"0x");
    %@Utility@'ModuleName'%.strcatNum16Hex(buf, sizeof(buf), val);
    %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (uint8_t*)" (0x0000 full, 0xFEFE silence)\r\n");
  } else {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (uint8_t*)"ERROR\r\n");
  }
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  VOLUME", buf, io->stdOut);

  return ERR_OK;
}

static uint8_t PrintHelp(const %@Shell@'ModuleName'%.StdIOType *io) {
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"%'ModuleName'", (unsigned char*)"Group of %'ModuleName' commands\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  help|status", (unsigned char*)"Print help or status information\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  volume <left> <right>", (unsigned char*)"Set volume, full: 0x00, 0xFE silence, 0xFF power down\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  softreset", (unsigned char*)"Perform a software reset\r\n", io->stdOut);
  return ERR_OK;
}

%endif
%-
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseCommand
%ifdef ParseCommand
%define! Parcmd
%define! Parhandled
%define! Pario
%define! RetVal
%include Common\VS1053ParseCommand.Inc
byte %'ModuleName'%.%ParseCommand(const unsigned char *cmd, bool *handled, const %@Shell@'ModuleName'%.StdIOType *io)
{
  const uint8_t *p;
  int32_t val32s;

  if (%@Utility@'ModuleName'%.strcmp((char*)cmd, %@Shell@'ModuleName'%.CMD_HELP)==0 || %@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' help")==0) {
    *handled = TRUE;
    return PrintHelp(io);
  } else if ((%@Utility@'ModuleName'%.strcmp((char*)cmd, %@Shell@'ModuleName'%.CMD_STATUS)==0) || (%@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' status")==0)) {
    *handled = TRUE;
    return PrintStatus(io);
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, "%'ModuleName' volume ", sizeof("%'ModuleName' volume ")-1)==0) {
    uint8_t left, right;

    *handled = TRUE;
    p = cmd+sizeof("%'ModuleName' volume ")-1;
    if (%@Utility@'ModuleName'%.xatoi(&p, &val32s)==ERR_OK) {
      left = (uint8_t)val32s;
      if (%@Utility@'ModuleName'%.xatoi(&p, &val32s)==ERR_OK) {
        right = (uint8_t)val32s;
        return %'ModuleName'%.%SetVolume(left, right);
      } else {
        %@Shell@'ModuleName'%.SendStr((uint8_t*)"Failed reading right volume", io->stdErr);
        return ERR_FAILED;
      }
    } else {
      %@Shell@'ModuleName'%.SendStr((uint8_t*)"Failed reading left volume", io->stdErr);
      return ERR_FAILED;
    }
  } else if (%@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' softreset")==0) {
    *handled = TRUE;
    return %'ModuleName'%.%SoftReset();
  }
  return ERR_OK;
}

%endif %- ParseCommand
%-BW_METHOD_END ParseCommand
%-************************************************************************************************************
%-BW_METHOD_BEGIN ActivateSPI
%ifdef ActivateSPI
%define! RetVal
%include Common\VS1053ActivateSPI.Inc
byte %'ModuleName'%.%ActivateSPI(void)
{
  uint8_t res;
  bool isError = FALSE;

%if defined(OnActivateSPI)
  %OnActivateSPI(); /* call user event */
%endif
  res = %@SPI@'ModuleName'%.Disable();
  if (res != ERR_OK) {
    isError = TRUE;
  }
  res = %@SPI@'ModuleName'%.SetIdleClockPolarity(0);    /* low idle clock polarity */
  if (res != ERR_OK) {
    isError = TRUE;
  }
  res = %@SPI@'ModuleName'%.SetShiftClockPolarity(0);   /* shift clock polarity: falling edge */
  if (res != ERR_OK) {
    isError = TRUE;
  }
  res = %@SPI@'ModuleName'%.SetBaudRateMode(%'ModuleName'%.BAUD_SPEED_INDEX);
  if (res != ERR_OK) {
    isError = TRUE;
  }
  res = %@SPI@'ModuleName'%.Enable();
  if (res != ERR_OK) {
    isError = TRUE;
  }
  if (isError) {
    return ERR_FAILED;
  } else {
    return ERR_OK;
  }
}

%endif %- ActivateSPI
%-BW_METHOD_END ActivateSPI
%-************************************************************************************************************
%-BW_METHOD_BEGIN DeactivateSPI
%ifdef DeactivateSPI
%define! RetVal
%include Common\VS1053DeactivateSPI.Inc
byte %'ModuleName'%.%DeactivateSPI(void)
{
%if defined(OnDeactivateSPI)
  %OnDeactivateSPI(); /* call user event */
%endif
  return ERR_OK;
}

%endif %- DeactivateSPI
%-BW_METHOD_END DeactivateSPI
%-************************************************************************************************************
%-BW_METHOD_BEGIN IsReady
%ifdef IsReady
%define! RetVal
%include Common\VS1053IsReady.Inc
bool %'ModuleName'%.%IsReady(void)
{
  return %@DREQ@'ModuleName'%.GetVal()!=0; /* DREQ HIGH: ready to receive data */
}

%endif %- IsReady
%-BW_METHOD_END IsReady
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteRegister
%ifdef WriteRegister
%define! Parreg
%define! Parvalue
%define! RetVal
%include Common\VS1053WriteRegister.Inc
byte %'ModuleName'%.%WriteRegister(byte reg, word value)
{
  %'ModuleName'%.ActivateSPI();
  %'ModuleName'%.CONTROL_MODE_ON();
  while(!%'ModuleName'%.%IsReady()) {
    %'ModuleName'%.WAIT_IF_NOT_READY_WAIT(); /* wait until pin goes high so we know it is ready */
  }
  /* send instruction byte, address byte and 16bit data word */
  %'ModuleName'%.SPI_WRITE(0x02); /* write instruction */
  %'ModuleName'%.SPI_WRITE(reg);
  %'ModuleName'%.SPI_WRITE(value>>8); /* high byte first */
  while(!%'ModuleName'%.%IsReady()) {
    %'ModuleName'%.WAIT_IF_NOT_READY_WAIT(); /* wait until pin goes high so we know it is ready */
  }
  %'ModuleName'%.SPI_WRITE(value&0xff); /* low byte */
  while(!%'ModuleName'%.%IsReady()) {
    %'ModuleName'%.WAIT_IF_NOT_READY_WAIT(); /* wait until pin goes high so we know it is ready */
  }
  %'ModuleName'%.CONTROL_MODE_OFF();
  %'ModuleName'%.DeactivateSPI();
  return ERR_OK;
}

%endif %- WriteRegister
%-BW_METHOD_END WriteRegister
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadRegister
%ifdef ReadRegister
%define! Parreg
%define! Parvalue
%define! RetVal
%include Common\VS1053ReadRegister.Inc
byte %'ModuleName'%.%ReadRegister(byte reg, word *value)
{
  uint8_t val0, val1;

  %'ModuleName'%.ActivateSPI();
  %'ModuleName'%.CONTROL_MODE_ON();
  while(!%'ModuleName'%.%IsReady()) {
    %'ModuleName'%.WAIT_IF_NOT_READY_WAIT(); /* wait until pin goes high so we know it is ready */
  }
  /* send instruction byte, address byte and 16bit data word */
  %'ModuleName'%.SPI_WRITE(0x03); /* read instruction */
  %'ModuleName'%.SPI_WRITE(reg);
  %'ModuleName'%.SPI_WRITE_READ(0xff, &val0); /* read first byte */
  while(!%'ModuleName'%.%IsReady()) {
    %'ModuleName'%.WAIT_IF_NOT_READY_WAIT(); /* wait until pin goes high so we know it is ready */
  }
  %'ModuleName'%.SPI_WRITE_READ(0xff, &val1); /* read second byte */
  while(!%'ModuleName'%.%IsReady()) {
    %'ModuleName'%.WAIT_IF_NOT_READY_WAIT(); /* wait until pin goes high so we know it is ready */
  }
  %'ModuleName'%.CONTROL_MODE_OFF();
  *value = (val0<<8)|val1;
  %'ModuleName'%.DeactivateSPI();
  return ERR_OK;
}

%endif %- ReadRegister
%-BW_METHOD_END ReadRegister
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteWRAM
%ifdef WriteWRAM
%define! Paraddr
%define! Parvalue
%define! RetVal
%include Common\VS1053WriteWRAM.Inc
byte %'ModuleName'%.%WriteWRAM(word addr, word value)
{
  uint8_t res;

  res = %'ModuleName'%.%WriteRegister(VS1053_WRAMADDR, addr);
  if (res==ERR_OK) {
    res = %'ModuleName'%.%WriteRegister(VS1053_WRAM, value);
  }
  return res;
}

%endif %- WriteWRAM
%-BW_METHOD_END WriteWRAM
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadWRAM
%ifdef ReadWRAM
%define! Paraddr
%define! Parvalue
%define! RetVal
%include Common\VS1053ReadWRAM.Inc
byte %'ModuleName'%.%ReadWRAM(word addr, word *value)
{
  uint8_t res = ERR_OK;
  uint16_t tmp1, tmp2;

  for(;;) { /* breaks */
   res = %'ModuleName'%.%WriteRegister(VS1053_WRAMADDR, addr);
   if (res!=ERR_OK) {
     break;
   }
   res = %'ModuleName'%.%ReadRegister(VS1053_WRAM, &tmp1);
   if (res!=ERR_OK) {
     break;
   }
   /* second try */
   res = %'ModuleName'%.%WriteRegister(VS1053_WRAMADDR, addr);
   if (res!=ERR_OK) {
     break;
   }
   res = %'ModuleName'%.%ReadRegister(VS1053_WRAM, &tmp2);
   if (res!=ERR_OK) {
     break;
   }
   if (tmp1==tmp2) {
     *value = tmp1;
     break;
   }

   res = %'ModuleName'%.%WriteRegister(VS1053_WRAMADDR, addr);
   if (res!=ERR_OK) {
     break;
   }
   res = %'ModuleName'%.%ReadRegister(VS1053_WRAM, &tmp1);
   if (res!=ERR_OK) {
     break;
   }
   if (tmp1==tmp2) {
     *value = tmp1;
     break;
   }

   res = %'ModuleName'%.%WriteRegister(VS1053_WRAMADDR, addr);
   if (res!=ERR_OK) {
     break;
   }
   res = %'ModuleName'%.%ReadRegister(VS1053_WRAM, &tmp1);
   if (res!=ERR_OK) {
     break;
   }
   if (tmp1==tmp2) {
     *value = tmp1;
     break;
   }
   *value = tmp1;
    break;
  } /* for */
  return res;
}

%endif %- ReadWRAM
%-BW_METHOD_END ReadWRAM
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
%define! RetVal
%include Common\VS1053Deinit.Inc
byte %'ModuleName'%.%Deinit(void)
{
  return ERR_OK;
}

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%define! RetVal
%include Common\VS1053Init.Inc
byte %'ModuleName'%.%Init(void)
{
  %@MCS@'ModuleName'%.SetVal(); /* chip select is low active, deselect it */
  %@DCS@'ModuleName'%.SetVal(); /* data mode is low active, deselect data mode */
  return ERR_OK;
}

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendValues
%ifdef SendValues
%define! ParnofValues
%define! Parvalue
%define! RetVal
%include Common\VS1053SendValues.Inc
byte %'ModuleName'%.%SendValues(word nofValues, byte value)
{
  uint16_t chunk;

  %'ModuleName'%.ActivateSPI();
  %'ModuleName'%.DATA_MODE_ON();
  while(nofValues!=0) {
    while(!%'ModuleName'%.%IsReady()) {
      %'ModuleName'%.WAIT_IF_NOT_READY_WAIT(); /* wait until pin goes high so we know it is ready */
    }
    if (nofValues>%'ModuleName'%.DATA_SIZE_BYTES) { /* max 32 bytes */
      chunk = %'ModuleName'%.DATA_SIZE_BYTES;
    } else {
      chunk = nofValues;
    }
    nofValues -= chunk;
    while(chunk>0) {
      %'ModuleName'%.SPI_WRITE(value);
      chunk--;
    }
  }
  %'ModuleName'%.DATA_MODE_OFF();
  %'ModuleName'%.DeactivateSPI();
  return ERR_OK;
}

%endif %- SendValues
%-BW_METHOD_END SendValues
%-************************************************************************************************************
%-BW_METHOD_BEGIN StartSong
%ifdef StartSong
%define! RetVal
%include Common\VS1053StartSong.Inc
byte %'ModuleName'%.%StartSong(void)
{
  return %'ModuleName'%.%SendValues(10, 0);
}

%endif %- StartSong
%-BW_METHOD_END StartSong
%-************************************************************************************************************
%-BW_METHOD_BEGIN TerminateStreams
%ifdef TerminateStreams
%define! RetVal
%include Common\VS1053TerminateStreams.Inc
byte %'ModuleName'%.%TerminateStreams(void)
{
  uint16_t endFill, sciMode;
  uint8_t endFillByte;
  uint8_t res = ERR_OK;
  int i;

  for(;;) { /* breaks */
    /* read fillbyte from WRAM */
    res = %'ModuleName'%.%ReadWRAM(VS1053_PARA_END_FILL_BYTE, &endFill);
    if (res!=ERR_OK) {
      break;
    }
    endFillByte = endFill; /* only 8 lower bits */
    /* send at least 2052 EndFillByte */
    res = %'ModuleName'%.%SendValues(2052, endFillByte);
    if (res!=ERR_OK) {
      break;
    }
    /* set SCI_MODE bit to SM_CANCEL */
    res = %'ModuleName'%.%ReadRegister(VS1053_MODE, &sciMode);
    if (res!=ERR_OK) {
      break;
    }
    sciMode |= VS1053_MODE_SM_CANCEL;
    res = %'ModuleName'%.%WriteRegister(VS1053_MODE, sciMode);
    if (res!=ERR_OK) {
      break;
    }
    /* send up to 2048 bytes of endFillByte */
    for(i=0;i<64;i++) {
      res = %'ModuleName'%.%SendValues(32, endFillByte);
      if (res!=ERR_OK) {
        break;
      }
      /* read SCI_MODE register. If SM_CANCEL is still set, repeat ... */
      res = %'ModuleName'%.%ReadRegister(VS1053_MODE, &sciMode);
      if (res!=ERR_OK) {
        break;
      }
      if (!(sciMode&VS1053_MODE_SM_CANCEL)) {
        break;
      }
    } /* for */
    if (sciMode&VS1053_MODE_SM_CANCEL) {
      return %'ModuleName'%.%SoftReset();
    }
    if (res!=ERR_OK) {
      break;
    }
    break;
  } /* for */
  return res;
}

%endif %- TerminateStreams
%-BW_METHOD_END TerminateStreams
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetVolume
%ifdef SetVolume
%define! Parleft
%define! Parright
%define! RetVal
%include Common\VS1053SetVolume.Inc
byte %'ModuleName'%.%SetVolume(byte left, byte right)
{
  /* max volume: 0x0000, total silence: 0xFEFE, 0xFFFF analog power down */
  return %'ModuleName'%.%WriteRegister(VS1053_VOL, (left<<8)|right);
}

%endif %- SetVolume
%-BW_METHOD_END SetVolume
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendData
%ifdef SendData
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\VS1053SendData.Inc
byte %'ModuleName'%.%SendData(byte *data, size_t dataSize)
{
  if (dataSize!=%'ModuleName'%.DATA_SIZE_BYTES) {
    return ERR_FAULT; /* need 32 bytes! */
  }
  %'ModuleName'%.ActivateSPI();
  %'ModuleName'%.DATA_MODE_ON();
  while(dataSize>0) {
    while(!%'ModuleName'%.%IsReady()) {
      %'ModuleName'%.WAIT_IF_NOT_READY_WAIT(); /* wait until pin goes high so we know it is ready */
    }
    %'ModuleName'%.SPI_WRITE(*data++);
    dataSize--;
  }
  %'ModuleName'%.DATA_MODE_OFF();
  %'ModuleName'%.DeactivateSPI();
  return ERR_OK;
}

%endif %- SendData
%-BW_METHOD_END SendData
%-************************************************************************************************************
%-BW_METHOD_BEGIN LoadUserCode
%ifdef LoadUserCode
%define! Pardata
%define! ParnofWords
%define! RetVal
%include Common\VS1053LoadUserCode.Inc
byte %'ModuleName'%.%LoadUserCode(const uint16_t *data, word nofWords)
{
  int i;
  uint16_t addr, n, val;
  uint8_t res = ERR_OK;

  i = 0;
  while(i<nofWords) {
    addr = data[i++];
    n = data[i++];
    while(n--) {
      val = data[i++];
      res = %'ModuleName'%.%WriteRegister(addr, val);
      if (res!=ERR_OK) {
        break;
      }
    }
  }
  return res;
}

%endif %- LoadUserCode
%-BW_METHOD_END LoadUserCode
%-************************************************************************************************************
%-BW_METHOD_BEGIN LoadRealtimeMidiPlugin
%ifdef LoadRealtimeMidiPlugin
%define! RetVal
%include Common\VS1053LoadRealtimeMidiPlugin.Inc
byte %'ModuleName'%.%LoadRealtimeMidiPlugin(void)
{
  return %'ModuleName'%.%LoadUserCode(&%'ModuleName'%.Realtime_MIDI_Plugin[0], sizeof(%'ModuleName'%.Realtime_MIDI_Plugin)/sizeof(%'ModuleName'%.Realtime_MIDI_Plugin[0]));
}

%endif %- LoadRealtimeMidiPlugin
%-BW_METHOD_END LoadRealtimeMidiPlugin
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG MIDI_Send
%define! Pardata
%define! RetVal
%include Common\GeneralInternal.inc (MIDI_Send)
byte %'ModuleName'%.MIDI_Send(byte data)
{
  %'ModuleName'%.SPI_WRITE(0x00);
  %'ModuleName'%.SPI_WRITE(data);
  return ERR_OK;
}

%-INTERNAL_METHOD_END MIDI_Send
%-************************************************************************************************************
%-BW_METHOD_BEGIN MIDI_Talk
%ifdef MIDI_Talk
%define! Parcmd
%define! Pardata1
%define! Pardata2
%define! RetVal
%include Common\VS1053MIDI_Talk.Inc
byte %'ModuleName'%.%MIDI_Talk(byte cmd, byte data1, byte data2)
{
  %'ModuleName'%.ActivateSPI();
  %'ModuleName'%.DATA_MODE_ON();
  while(!%'ModuleName'%.%IsReady()) {
    %'ModuleName'%.WAIT_IF_NOT_READY_WAIT(); /* wait until pin goes high so we know it is ready */
  }
  (void)%'ModuleName'%.MIDI_Send(cmd);
  /* some MIDI commands have only one data byte. All cmds less than 0xBn have two data bytes */
  if ((cmd&0xF0)<=0xB0 || (cmd&0xF0)>=0xE0) {
    (void)%'ModuleName'%.MIDI_Send(data1);
    (void)%'ModuleName'%.MIDI_Send(data2);
  } else {
    (void)%'ModuleName'%.MIDI_Send(data1);
  }
  %'ModuleName'%.DATA_MODE_OFF();
  %'ModuleName'%.DeactivateSPI();
  return ERR_OK;
}

%endif %- MIDI_Talk
%-BW_METHOD_END MIDI_Talk
%-************************************************************************************************************
%-BW_METHOD_BEGIN MIDI_NoteOn
%ifdef MIDI_NoteOn
%define! Parchannel
%define! Parnote
%define! Parvelocity
%define! RetVal
%include Common\VS1053MIDI_NoteOn.Inc
byte %'ModuleName'%.%MIDI_NoteOn(byte channel, byte note, byte velocity)
{
  channel &= 0x0F; /* limit channel to 0..15 */
  note &= 0x7F; /* 0..127 */
  velocity &= 0x7F; /* 0..127 */
  return %'ModuleName'%.%MIDI_Talk((%'ModuleName'%.MIDI_MSG_CH_NOTE_ON|channel), note, velocity);
}

%endif %- MIDI_NoteOn
%-BW_METHOD_END MIDI_NoteOn
%-************************************************************************************************************
%-BW_METHOD_BEGIN MIDI_NoteOff
%ifdef MIDI_NoteOff
%define! Parchannel
%define! Parnote
%define! Parvelocity
%define! RetVal
%include Common\VS1053MIDI_NoteOff.Inc
byte %'ModuleName'%.%MIDI_NoteOff(byte channel, byte note, byte velocity)
{
  channel &= 0x0F; /* limit channel to 0..15 */
  note &= 0x7F; /* 0..127 */
  velocity &= 0x7F; /* 0..127 */
  return %'ModuleName'%.%MIDI_Talk((%'ModuleName'%.MIDI_MSG_CH_NOTE_OFF|channel), note, velocity);
}

%endif %- MIDI_NoteOff
%-BW_METHOD_END MIDI_NoteOff
%-************************************************************************************************************
%-BW_METHOD_BEGIN MIDI_SetVolume
%ifdef MIDI_SetVolume
%define! Parchannel
%define! Parvolume
%define! RetVal
%include Common\VS1053MIDI_SetVolume.Inc
byte %'ModuleName'%.%MIDI_SetVolume(byte channel, byte volume)
{
  channel &= 0x0F; /* limit channel to 0..15 */
  volume &= 0x7F; /* limit to 0..127 */
  return %'ModuleName'%.%MIDI_Talk((%'ModuleName'%.MIDI_MSG_CH_PARAMETER|channel), %'ModuleName'%.MIDI_MSG_CH_PARAM_VOLUME, volume);
}

%endif %- MIDI_SetVolume
%-BW_METHOD_END MIDI_SetVolume
%-************************************************************************************************************
%-BW_METHOD_BEGIN MIDI_SetBank
%ifdef MIDI_SetBank
%define! Parchannel
%define! Parbank
%define! RetVal
%include Common\VS1053MIDI_SetBank.Inc
byte %'ModuleName'%.%MIDI_SetBank(byte channel, byte bank)
{
  channel &= 0x0F; /* limit channel to 0..15 */
  bank &= 0x7F; /* limit to 0..127 */
  return %'ModuleName'%.%MIDI_Talk((%'ModuleName'%.MIDI_MSG_CH_PARAMETER|channel), %'ModuleName'%.MIDI_MSG_CH_PARAM_BANK_SELECT, bank);
}

%endif %- MIDI_SetBank
%-BW_METHOD_END MIDI_SetBank
%-************************************************************************************************************
%-BW_METHOD_BEGIN MIDI_SetInstrument
%ifdef MIDI_SetInstrument
%define! Parchannel
%define! Parinstrument
%define! RetVal
%include Common\VS1053MIDI_SetInstrument.Inc
byte %'ModuleName'%.%MIDI_SetInstrument(byte channel, byte instrument)
{
  /* set an instrument, e.g. %'ModuleName'%.MIDI_INSTR_Default */
  channel &= 0x0F; /* limit channel to 0..15 */
  instrument &= 0x7F; /* limit to 0..127 */
  return %'ModuleName'%.%MIDI_Talk((%'ModuleName'%.MIDI_MSG_CH_PRG|channel), instrument, 0 /* dummy */);
}

%endif %- MIDI_SetInstrument
%-BW_METHOD_END MIDI_SetInstrument
%-************************************************************************************************************
%-BW_METHOD_BEGIN MIDI_SetPan
%ifdef MIDI_SetPan
%define! Parchannel
%define! Parpan
%define! RetVal
%include Common\VS1053MIDI_SetPan.Inc
byte %'ModuleName'%.%MIDI_SetPan(byte channel, byte pan)
{
  channel &= 0x0F; /* limit channel to 0..15 */
  pan &= 0x7F; /* limit to 0..127 */
  return %'ModuleName'%.%MIDI_Talk((%'ModuleName'%.MIDI_MSG_CH_PARAMETER|channel), %'ModuleName'%.MIDI_MSG_CH_PARAM_PAN, pan);
}

%endif %- MIDI_SetPan
%-BW_METHOD_END MIDI_SetPan
%-************************************************************************************************************
%-BW_METHOD_BEGIN MIDI_AllSoundOff
%ifdef MIDI_AllSoundOff
%define! Parchannel
%define! RetVal
%include Common\VS1053MIDI_AllSoundOff.Inc
byte %'ModuleName'%.%MIDI_AllSoundOff(byte channel)
{
  channel &= 0x0F; /* limit channel to 0..15 */
  return %'ModuleName'%.%MIDI_Talk((%'ModuleName'%.MIDI_MSG_CH_PARAMETER|channel), %'ModuleName'%.MIDI_MSG_CH_PARAM_ALL_SOUND_OFF, 0 /* dummy */);
}

%endif %- MIDI_AllSoundOff
%-BW_METHOD_END MIDI_AllSoundOff
%-************************************************************************************************************
%-BW_METHOD_BEGIN SoftReset
%ifdef SoftReset
%define! RetVal
%include Common\VS1053SoftReset.Inc
byte %'ModuleName'%.%SoftReset(void)
{
  uint8_t res;
  uint16_t sciMode;

  res = %'ModuleName'%.%ReadRegister(VS1053_MODE, &sciMode);
  if (res!=ERR_OK) {
    return res;
  }
  res = %'ModuleName'%.%WriteRegister(VS1053_MODE, sciMode|VS1053_MODE_SM_RESET);
  if (res!=ERR_OK) {
    return res;;
  }
  %@Wait@'ModuleName'%.Waitus(2); /* wait for at least 2 us */
  /* DREQ should now be down for about 1.8 ms. Wait until DREQ gets up again */
  while(!%'ModuleName'%.%IsReady()) {
    %'ModuleName'%.WAIT_IF_NOT_READY_WAIT(); /* wait until pin goes high so we know it is ready */
  }
  return res;
}

%endif %- SoftReset
%-BW_METHOD_END SoftReset
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_METHOD_BEGIN OnActivateSPI
%ifdef OnActivateSPI
%IMPLEMENTATION OnActivateSPI
%include Common\VS1053OnActivateSPI.Inc
void %OnActivateSPI(void)
{
  /* Write your code here ... */
}

%endif %- OnActivateSPI
%-BW_METHOD_END OnActivateSPI
%-BW_METHOD_BEGIN OnDeactivateSPI
%ifdef OnDeactivateSPI
%IMPLEMENTATION OnDeactivateSPI
%include Common\VS1053OnDeactivateSPI.Inc
void %OnDeactivateSPI(void)
{
  /* Write your code here ... */
}

%endif %- OnDeactivateSPI
%-BW_METHOD_END OnDeactivateSPI
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
  (void)%'ModuleName'%.%Init();
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This component is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-

%-Driver generated by the Component Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END 
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Component Wizard
%- If you change these lines, Component Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    29.12.2014
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%define! Description_SendMIDI Sends a MIDI data byte
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\VS1053Settings.Inc
%define! Abstract Common\VS1053Abstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
/* VS1053 Registers */
#define VS1053_MODE         0x00
  #define VS1053_MODE_SM_DIFF           (1<<0)
  #define VS1053_MODE_SM_LAYER12        (1<<1)
  #define VS1053_MODE_SM_RESET          (1<<2)
  #define VS1053_MODE_SM_CANCEL         (1<<3)
  #define VS1053_MODE_SM_EARSPEAKER_LO  (1<<4)
  #define VS1053_MODE_SM_TESTS          (1<<5)
  #define VS1053_MODE_SM_STREAM         (1<<6)
  #define VS1053_MODE_SM_EARSPEAKER_HI  (1<<7)
  #define VS1053_MODE_SM_DACT           (1<<8)
  #define VS1053_MODE_SM_SDIORD         (1<<9)
  #define VS1053_MODE_SM_SDISHARE       (1<<10)
  #define VS1053_MODE_SM_SDINEW         (1<<11)
  #define VS1053_MODE_SM_ADPCM          (1<<12)
  #define VS1053_MODE_SM_LINE1          (1<<14)
  #define VS1053_MODE_SM_SM_CLK_RANGE   (1<<15)

#define VS1053_STATUS       0x01
#define VS1053_BASS         0x02
#define VS1053_CLOCKF       0x03
#define VS1053_DECODE_TIME  0x04
#define VS1053_AUDATA       0x05
#define VS1053_WRAM         0x06
#define VS1053_WRAMADDR     0x07
#define VS1053_HDAT0        0x08
#define VS1053_HDAT1        0x09
#define VS1053_AIADDR       0x0A
#define VS1053_VOL          0x0B
#define VS1053_AICTRL0      0x0C
#define VS1053_AICTRL1      0x0D
#define VS1053_AICTRL2      0x0E
#define VS1053_AICTRL3      0x0F
#define VS1053_IO_DDR       0xC017
#define VS1053_IO_IDATA     0xC018
#define VS1053_IO_ODATA     0xC019

#define VS1053_PARA_END_FILL_BYTE 0x1E06 /*1e06 byte value to send after file sent */

%ifdef ParseCommand
#define %'ModuleName'%.PARSE_COMMAND_ENABLED  1 /* set to 1 if method ParseCommand() is present, 0 otherwise */
%else
#define %'ModuleName'%.PARSE_COMMAND_ENABLED  0 /* set to 1 if method ParseCommand() is present, 0 otherwise */
%endif %- ParseCommand

%if defined(WaitIfNotReady) & %WaitIfNotReady='yes' & defined(WaitNotReadyMs) & defined(Wait)
#define %'ModuleName'%.WAIT_IF_NOT_READY          1 /* Wait if not ready */
%else
#define %'ModuleName'%.WAIT_IF_NOT_READY          0 /* Wait if not ready */
%endif
#if %'ModuleName'%.WAIT_IF_NOT_READY
  #define %'ModuleName'%.WAIT_IF_NOT_READY_TIME_MS  %WaitNotReadyMs /* Wait if not ready */
  #define %'ModuleName'%.WAIT_IF_NOT_READY_WAIT()   %@Wait@'ModuleName'%.WaitOSms(%'ModuleName'%.WAIT_IF_NOT_READY_TIME_MS)
#else
  #define %'ModuleName'%.WAIT_IF_NOT_READY_WAIT()   /* nothing */
#endif
%-
%-BW_CUSTOM_USERTYPE_END
%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseCommand
%ifdef ParseCommand
byte %'ModuleName'%.%ParseCommand(const unsigned char *cmd, bool *handled, const %@Shell@'ModuleName'%.StdIOType *io);
%define! Parcmd
%define! Parhandled
%define! Pario
%define! RetVal
%include Common\VS1053ParseCommand.Inc

%endif %- ParseCommand
%-BW_METHOD_END ParseCommand
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
byte %'ModuleName'%.%Deinit(void);
%define! RetVal
%include Common\VS1053Deinit.Inc

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
byte %'ModuleName'%.%Init(void);
%define! RetVal
%include Common\VS1053Init.Inc

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN IsReady
%ifdef IsReady
bool %'ModuleName'%.%IsReady(void);
%define! RetVal
%include Common\VS1053IsReady.Inc

%endif %- IsReady
%-BW_METHOD_END IsReady
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteRegister
%ifdef WriteRegister
byte %'ModuleName'%.%WriteRegister(byte reg, word value);
%define! Parreg
%define! Parvalue
%define! RetVal
%include Common\VS1053WriteRegister.Inc

%endif %- WriteRegister
%-BW_METHOD_END WriteRegister
%-************************************************************************************************************
%-BW_METHOD_BEGIN ActivateSPI
%ifdef ActivateSPI
byte %'ModuleName'%.%ActivateSPI(void);
%define! RetVal
%include Common\VS1053ActivateSPI.Inc

%endif %- ActivateSPI
%-BW_METHOD_END ActivateSPI
%-************************************************************************************************************
%-BW_METHOD_BEGIN DeactivateSPI
%ifdef DeactivateSPI
byte %'ModuleName'%.%DeactivateSPI(void);
%define! RetVal
%include Common\VS1053DeactivateSPI.Inc

%endif %- DeactivateSPI
%-BW_METHOD_END DeactivateSPI
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadRegister
%ifdef ReadRegister
byte %'ModuleName'%.%ReadRegister(byte reg, word *value);
%define! Parreg
%define! Parvalue
%define! RetVal
%include Common\VS1053ReadRegister.Inc

%endif %- ReadRegister
%-BW_METHOD_END ReadRegister
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendValues
%ifdef SendValues
byte %'ModuleName'%.%SendValues(word nofValues, byte value);
%define! ParnofValues
%define! Parvalue
%define! RetVal
%include Common\VS1053SendValues.Inc

%endif %- SendValues
%-BW_METHOD_END SendValues
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetVolume
%ifdef SetVolume
byte %'ModuleName'%.%SetVolume(byte left, byte right);
%define! Parleft
%define! Parright
%define! RetVal
%include Common\VS1053SetVolume.Inc

%endif %- SetVolume
%-BW_METHOD_END SetVolume
%-************************************************************************************************************
%-BW_METHOD_BEGIN StartSong
%ifdef StartSong
byte %'ModuleName'%.%StartSong(void);
%define! RetVal
%include Common\VS1053StartSong.Inc

%endif %- StartSong
%-BW_METHOD_END StartSong
%-************************************************************************************************************
%-BW_METHOD_BEGIN TerminateStreams
%ifdef TerminateStreams
byte %'ModuleName'%.%TerminateStreams(void);
%define! RetVal
%include Common\VS1053TerminateStreams.Inc

%endif %- TerminateStreams
%-BW_METHOD_END TerminateStreams
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendData
%ifdef SendData
byte %'ModuleName'%.%SendData(byte *data, size_t dataSize);
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\VS1053SendData.Inc

%endif %- SendData
%-BW_METHOD_END SendData
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteWRAM
%ifdef WriteWRAM
byte %'ModuleName'%.%WriteWRAM(word addr, word value);
%define! Paraddr
%define! Parvalue
%define! RetVal
%include Common\VS1053WriteWRAM.Inc

%endif %- WriteWRAM
%-BW_METHOD_END WriteWRAM
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadWRAM
%ifdef ReadWRAM
byte %'ModuleName'%.%ReadWRAM(word addr, word *value);
%define! Paraddr
%define! Parvalue
%define! RetVal
%include Common\VS1053ReadWRAM.Inc

%endif %- ReadWRAM
%-BW_METHOD_END ReadWRAM
%-************************************************************************************************************
%-BW_METHOD_BEGIN LoadUserCode
%ifdef LoadUserCode
byte %'ModuleName'%.%LoadUserCode(const uint16_t *data, word nofWords);
%define! Pardata
%define! ParnofWords
%define! RetVal
%include Common\VS1053LoadUserCode.Inc

%endif %- LoadUserCode
%-BW_METHOD_END LoadUserCode
%-************************************************************************************************************
%-BW_METHOD_BEGIN LoadRealtimeMidiPlugin
%ifdef LoadRealtimeMidiPlugin
byte %'ModuleName'%.%LoadRealtimeMidiPlugin(void);
%define! RetVal
%include Common\VS1053LoadRealtimeMidiPlugin.Inc

%endif %- LoadRealtimeMidiPlugin
%-BW_METHOD_END LoadRealtimeMidiPlugin
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG SendMIDI
byte %'ModuleName'%.SendMIDI(byte data);
%define! Pardata
%define! RetVal
%include Common\GeneralInternal.inc (SendMIDI)

%-INTERNAL_METHOD_END SendMIDI
%-************************************************************************************************************
%-BW_METHOD_BEGIN TalkMIDI
%ifdef TalkMIDI
byte %'ModuleName'%.%TalkMIDI(byte cmd, byte data1, byte data2);
%define! Parcmd
%define! Pardata1
%define! Pardata2
%define! RetVal
%include Common\VS1053TalkMIDI.Inc

%endif %- TalkMIDI
%-BW_METHOD_END TalkMIDI
%-************************************************************************************************************
%-BW_METHOD_BEGIN NoteOnMIDI
%ifdef NoteOnMIDI
byte %'ModuleName'%.%NoteOnMIDI(byte channel, byte note, byte velocity);
%define! Parchannel
%define! Parnote
%define! Parvelocity
%define! RetVal
%include Common\VS1053NoteOnMIDI.Inc

%endif %- NoteOnMIDI
%-BW_METHOD_END NoteOnMIDI
%-************************************************************************************************************
%-BW_METHOD_BEGIN NoteOffMIDI
%ifdef NoteOffMIDI
byte %'ModuleName'%.%NoteOffMIDI(byte channel, byte note, byte velocity);
%define! Parchannel
%define! Parnote
%define! Parvelocity
%define! RetVal
%include Common\VS1053NoteOffMIDI.Inc

%endif %- NoteOffMIDI
%-BW_METHOD_END NoteOffMIDI
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_METHOD_BEGIN OnActivateSPI
%ifdef OnActivateSPI
%INTERFACE OnActivateSPI
void %OnActivateSPI(void);
%include Common\VS1053OnActivateSPI.Inc

%endif %- OnActivateSPI
%-BW_METHOD_END OnActivateSPI
%-BW_METHOD_BEGIN OnDeactivateSPI
%ifdef OnDeactivateSPI
%INTERFACE OnDeactivateSPI
void %OnDeactivateSPI(void);
%include Common\VS1053OnDeactivateSPI.Inc

%endif %- OnDeactivateSPI
%-BW_METHOD_END OnDeactivateSPI
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\VS1053Settings.Inc
%define! Abstract Common\VS1053Abstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;

/*
 * Plugin to put VS10XX into realtime MIDI mode
 * Originally from http://www.vlsi.fi/fileadmin/software/VS10XX/vs1053b-rtmidistart.zip
 * Permission to reproduce here granted by VLSI solution.
 */
static const uint16_t %'ModuleName'%.Realtime_MIDI_Plugin[28] = { /* Compressed plugin */
  0x0007, 0x0001, 0x8050, 0x0006, 0x0014, 0x0030, 0x0715, 0xb080, /* 0 */
  0x3400, 0x0007, 0x9255, 0x3d00, 0x0024, 0x0030, 0x0295, 0x6890, /* 8 */
  0x3400, 0x0030, 0x0495, 0x3d00, 0x0024, 0x2908, 0x4d40, 0x0030, /* 10 */
  0x0200, 0x000a, 0x0001, 0x0050,
};

static uint8_t rxDummy; /* dummy byte if we do not need the result. Needed to read from SPI register. */
#define %'ModuleName'%.SPI_WRITE(write)            \
   { \
     while(%@SPI@'ModuleName'%.SendChar(write)!=ERR_OK) {} \
     while(%@SPI@'ModuleName'%.RecvChar(&rxDummy)!=ERR_OK) {} \
   }
#define %'ModuleName'%.SPI_WRITE_READ(write, readP) \
   { \
     while(%@SPI@'ModuleName'%.SendChar(write)!=ERR_OK) {} \
     while(%@SPI@'ModuleName'%.RecvChar(readP)!=ERR_OK) {} \
   }

/* macros to select device and to switch between data and control mode */
#define %'ModuleName'%.CONTROL_MODE_ON()    %@DCS@'ModuleName'%.SetVal(); %@MCS@'ModuleName'%.ClrVal()
#define %'ModuleName'%.CONTROL_MODE_OFF()   %@MCS@'ModuleName'%.SetVal()
#define %'ModuleName'%.DATA_MODE_ON()       %@MCS@'ModuleName'%.SetVal(); %@DCS@'ModuleName'%.ClrVal()
#define %'ModuleName'%.DATA_MODE_OFF()      %@DCS@'ModuleName'%.SetVal()

#define %'ModuleName'%.DATA_SIZE_BYTES      32  /* always 32 bytes of data */
#define %'ModuleName'%.BAUD_SPEED_INDEX     %SPIBaudMode   /* index as defined in properties */

%if defined(Shell)
static uint8_t PrintStatus(const %@Shell@'ModuleName'%.StdIOType *io) {
  uint8_t buf[48];
  uint16_t val;

  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"%'ModuleName'", (unsigned char*)"\r\n", io->stdOut);
  if (%'ModuleName'%.%ReadRegister(VS1053_MODE, &val)==ERR_OK) {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), "0x");
    %@Utility@'ModuleName'%.strcatNum16Hex(buf, sizeof(buf), val);
    %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), "\r\n");
  } else {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), "ERROR\r\n");
  }
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  MODE", buf, io->stdOut);

  if (%'ModuleName'%.%ReadRegister(VS1053_STATUS, &val)==ERR_OK) {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), "0x");
    %@Utility@'ModuleName'%.strcatNum16Hex(buf, sizeof(buf), val);
    %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), "\r\n");
  } else {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), "ERROR\r\n");
  }
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  STATUS", buf, io->stdOut);

  if (%'ModuleName'%.%ReadRegister(VS1053_BASS, &val)==ERR_OK) {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), "0x");
    %@Utility@'ModuleName'%.strcatNum16Hex(buf, sizeof(buf), val);
    %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), "\r\n");
  } else {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), "ERROR\r\n");
  }
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  BASS", buf, io->stdOut);

  if (%'ModuleName'%.%ReadRegister(VS1053_CLOCKF, &val)==ERR_OK) {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), "0x");
    %@Utility@'ModuleName'%.strcatNum16Hex(buf, sizeof(buf), val);
    %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), "\r\n");
  } else {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), "ERROR\r\n");
  }
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  CLOCKF", buf, io->stdOut);

  if (%'ModuleName'%.%ReadRegister(VS1053_DECODE_TIME, &val)==ERR_OK) {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), "0x");
    %@Utility@'ModuleName'%.strcatNum16Hex(buf, sizeof(buf), val);
    %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), " seconds\r\n");
  } else {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), "ERROR\r\n");
  }
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  DECODE", buf, io->stdOut);

  if (%'ModuleName'%.%ReadRegister(VS1053_AUDATA, &val)==ERR_OK) {
    buf[0] = '\0';
    %@Utility@'ModuleName'%.Num16uToStr(buf, sizeof(buf), val&0xFFFE);
    %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), " Hz, ");
    %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (val&1)?"stereo\r\n":"mono\r\n");
  } else {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), "ERROR\r\n");
  }
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  AUDATA", buf, io->stdOut);

  if (%'ModuleName'%.%ReadRegister(VS1053_VOL, &val)==ERR_OK) {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), "0x");
    %@Utility@'ModuleName'%.strcatNum16Hex(buf, sizeof(buf), val);
    %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), " (0x0000 full, 0xFEFE silence)\r\n");
  } else {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), "ERROR\r\n");
  }
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  VOLUME", buf, io->stdOut);

  return ERR_OK;
}

static uint8_t PrintHelp(const %@Shell@'ModuleName'%.StdIOType *io) {
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"%'ModuleName'", (unsigned char*)"Group of %'ModuleName' commands\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  help|status", (unsigned char*)"Print help or status information\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  volume <left> <right>", (unsigned char*)"Set volume, full: 0x00, 0xFE silence, 0xFF power down\r\n", io->stdOut);
  return ERR_OK;
}

%endif
%-
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseCommand
%ifdef ParseCommand
%define! Parcmd
%define! Parhandled
%define! Pario
%define! RetVal
%include Common\VS1053ParseCommand.Inc
byte %'ModuleName'%.%ParseCommand(const unsigned char *cmd, bool *handled, const %@Shell@'ModuleName'%.StdIOType *io)
{
  const uint8_t *p;
  uint32_t val32u;

  if (%@Utility@'ModuleName'%.strcmp((char*)cmd, %@Shell@'ModuleName'%.CMD_HELP)==0 || %@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' help")==0) {
    *handled = TRUE;
    return PrintHelp(io);
  } else if ((%@Utility@'ModuleName'%.strcmp((char*)cmd, %@Shell@'ModuleName'%.CMD_STATUS)==0) || (%@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' status")==0)) {
    *handled = TRUE;
    return PrintStatus(io);
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, "%'ModuleName' volume ", sizeof("%'ModuleName' volume ")-1)==0) {
    uint8_t left, right;

    *handled = TRUE;
    p = cmd+sizeof("%'ModuleName' volume ")-1;
    if (%@Utility@'ModuleName'%.xatoi(&p, &val32u)==ERR_OK) {
      left = (uint8_t)val32u;
      if (%@Utility@'ModuleName'%.xatoi(&p, &val32u)==ERR_OK) {
        right = (uint8_t)val32u;
        return %'ModuleName'%.%SetVolume(left, right);
      } else {
        %@Shell@'ModuleName'%.SendStr("Failed reading right volume", io->stdErr);
        return ERR_FAILED;
      }
    } else {
      %@Shell@'ModuleName'%.SendStr("Failed reading left volume", io->stdErr);
      return ERR_FAILED;
    }
  }
  return ERR_OK;
}

%endif %- ParseCommand
%-BW_METHOD_END ParseCommand
%-************************************************************************************************************
%-BW_METHOD_BEGIN ActivateSPI
%ifdef ActivateSPI
%define! RetVal
%include Common\VS1053ActivateSPI.Inc
byte %'ModuleName'%.%ActivateSPI(void)
{
  uint8_t res;
  bool isError = FALSE;

%if defined(OnActivateSPI)
  %OnActivateSPI(); /* call user event */
%endif
  res = %@SPI@'ModuleName'%.Disable();
  if (res != ERR_OK) {
    isError = TRUE;
  }
  res = %@SPI@'ModuleName'%.SetIdleClockPolarity(0);    /* low idle clock polarity */
  if (res != ERR_OK) {
    isError = TRUE;
  }
  res = %@SPI@'ModuleName'%.SetShiftClockPolarity(0);   /* shift clock polarity: falling edge */
  if (res != ERR_OK) {
    isError = TRUE;
  }
  res = %@SPI@'ModuleName'%.SetBaudRateMode(%'ModuleName'%.BAUD_SPEED_INDEX);
  if (res != ERR_OK) {
    isError = TRUE;
  }
  res = %@SPI@'ModuleName'%.Enable();
  if (res != ERR_OK) {
    isError = TRUE;
  }
  if (isError) {
    return ERR_FAILED;
  } else {
    return ERR_OK;
  }
}

%endif %- ActivateSPI
%-BW_METHOD_END ActivateSPI
%-************************************************************************************************************
%-BW_METHOD_BEGIN DeactivateSPI
%ifdef DeactivateSPI
%define! RetVal
%include Common\VS1053DeactivateSPI.Inc
byte %'ModuleName'%.%DeactivateSPI(void)
{
%if defined(OnDeactivateSPI)
  %OnDeactivateSPI(); /* call user event */
%endif
  return ERR_OK;
}

%endif %- DeactivateSPI
%-BW_METHOD_END DeactivateSPI
%-************************************************************************************************************
%-BW_METHOD_BEGIN IsReady
%ifdef IsReady
%define! RetVal
%include Common\VS1053IsReady.Inc
bool %'ModuleName'%.%IsReady(void)
{
  return %@DREQ@'ModuleName'%.GetVal()!=0; /* DREQ HIGH: ready to receive data */
}

%endif %- IsReady
%-BW_METHOD_END IsReady
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteRegister
%ifdef WriteRegister
%define! Parreg
%define! Parvalue
%define! RetVal
%include Common\VS1053WriteRegister.Inc
byte %'ModuleName'%.%WriteRegister(byte reg, word value)
{
  %'ModuleName'%.ActivateSPI();
  %'ModuleName'%.CONTROL_MODE_ON();
  while(!%'ModuleName'%.%IsReady()) {
    %'ModuleName'%.WAIT_IF_NOT_READY_WAIT(); /* wait until pin goes high so we know it is ready */
  }
  /* send instruction byte, address byte and 16bit data word */
  %'ModuleName'%.SPI_WRITE(0x02); /* write instruction */
  %'ModuleName'%.SPI_WRITE(reg);
  %'ModuleName'%.SPI_WRITE(value>>8); /* high byte first */
  while(!%'ModuleName'%.%IsReady()) {
    %'ModuleName'%.WAIT_IF_NOT_READY_WAIT(); /* wait until pin goes high so we know it is ready */
  }
  %'ModuleName'%.SPI_WRITE(value&0xff); /* low byte */
  while(!%'ModuleName'%.%IsReady()) {
    %'ModuleName'%.WAIT_IF_NOT_READY_WAIT(); /* wait until pin goes high so we know it is ready */
  }
  %'ModuleName'%.CONTROL_MODE_OFF();
  %'ModuleName'%.DeactivateSPI();
  return ERR_OK;
}

%endif %- WriteRegister
%-BW_METHOD_END WriteRegister
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadRegister
%ifdef ReadRegister
%define! Parreg
%define! Parvalue
%define! RetVal
%include Common\VS1053ReadRegister.Inc
byte %'ModuleName'%.%ReadRegister(byte reg, word *value)
{
  uint8_t val0, val1;

  %'ModuleName'%.ActivateSPI();
  %'ModuleName'%.CONTROL_MODE_ON();
  while(!%'ModuleName'%.%IsReady()) {
    %'ModuleName'%.WAIT_IF_NOT_READY_WAIT(); /* wait until pin goes high so we know it is ready */
  }
  /* send instruction byte, address byte and 16bit data word */
  %'ModuleName'%.SPI_WRITE(0x03); /* read instruction */
  %'ModuleName'%.SPI_WRITE(reg);
  %'ModuleName'%.SPI_WRITE_READ(0xff, &val0); /* read first byte */
  while(!%'ModuleName'%.%IsReady()) {
    %'ModuleName'%.WAIT_IF_NOT_READY_WAIT(); /* wait until pin goes high so we know it is ready */
  }
  %'ModuleName'%.SPI_WRITE_READ(0xff, &val1); /* read second byte */
  while(!%'ModuleName'%.%IsReady()) {
    %'ModuleName'%.WAIT_IF_NOT_READY_WAIT(); /* wait until pin goes high so we know it is ready */
  }
  %'ModuleName'%.CONTROL_MODE_OFF();
  *value = (val0<<8)|val1;
  %'ModuleName'%.DeactivateSPI();
  return ERR_OK;
}

%endif %- ReadRegister
%-BW_METHOD_END ReadRegister
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteWRAM
%ifdef WriteWRAM
%define! Paraddr
%define! Parvalue
%define! RetVal
%include Common\VS1053WriteWRAM.Inc
byte %'ModuleName'%.%WriteWRAM(word addr, word value)
{
  uint8_t res;

  res = %'ModuleName'%.%WriteRegister(VS1053_WRAMADDR, addr);
  if (res==ERR_OK) {
    res = %'ModuleName'%.%WriteRegister(VS1053_WRAM, value);
  }
  return res;
}

%endif %- WriteWRAM
%-BW_METHOD_END WriteWRAM
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadWRAM
%ifdef ReadWRAM
%define! Paraddr
%define! Parvalue
%define! RetVal
%include Common\VS1053ReadWRAM.Inc
byte %'ModuleName'%.%ReadWRAM(word addr, word *value)
{
  uint8_t res = ERR_OK;
  uint16_t tmp1, tmp2;

  for(;;) { /* breaks */
   res = %'ModuleName'%.%WriteRegister(VS1053_WRAMADDR, addr);
   if (res!=ERR_OK) {
     break;
   }
   res = %'ModuleName'%.%ReadRegister(VS1053_WRAM, &tmp1);
   if (res!=ERR_OK) {
     break;
   }
   /* second try */
   res = %'ModuleName'%.%WriteRegister(VS1053_WRAMADDR, addr);
   if (res!=ERR_OK) {
     break;
   }
   res = %'ModuleName'%.%ReadRegister(VS1053_WRAM, &tmp2);
   if (res!=ERR_OK) {
     break;
   }
   if (tmp1==tmp2) {
     *value = tmp1;
     break;
   }

   res = %'ModuleName'%.%WriteRegister(VS1053_WRAMADDR, addr);
   if (res!=ERR_OK) {
     break;
   }
   res = %'ModuleName'%.%ReadRegister(VS1053_WRAM, &tmp1);
   if (res!=ERR_OK) {
     break;
   }
   if (tmp1==tmp2) {
     *value = tmp1;
     break;
   }

   res = %'ModuleName'%.%WriteRegister(VS1053_WRAMADDR, addr);
   if (res!=ERR_OK) {
     break;
   }
   res = %'ModuleName'%.%ReadRegister(VS1053_WRAM, &tmp1);
   if (res!=ERR_OK) {
     break;
   }
   if (tmp1==tmp2) {
     *value = tmp1;
     break;
   }
   *value = tmp1;
    break;
  } /* for */
  return res;
}

%endif %- ReadWRAM
%-BW_METHOD_END ReadWRAM
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
%define! RetVal
%include Common\VS1053Deinit.Inc
byte %'ModuleName'%.%Deinit(void)
{
  return ERR_OK;
}

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%define! RetVal
%include Common\VS1053Init.Inc
byte %'ModuleName'%.%Init(void)
{
  %@MCS@'ModuleName'%.SetVal(); /* chip select is low active, deselect it */
  %@DCS@'ModuleName'%.SetVal(); /* data mode is low active, deselect data mode */
  return ERR_OK;
}

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendValues
%ifdef SendValues
%define! ParnofValues
%define! Parvalue
%define! RetVal
%include Common\VS1053SendValues.Inc
byte %'ModuleName'%.%SendValues(word nofValues, byte value)
{
  uint16_t chunk;

  %'ModuleName'%.ActivateSPI();
  %'ModuleName'%.DATA_MODE_ON();
  while(nofValues=0) {
    while(!%'ModuleName'%.%IsReady()) {
      %'ModuleName'%.WAIT_IF_NOT_READY_WAIT(); /* wait until pin goes high so we know it is ready */
    }
    if (nofValues>%'ModuleName'%.DATA_SIZE_BYTES) { /* max 32 bytes */
      chunk = %'ModuleName'%.DATA_SIZE_BYTES;
    } else {
      chunk = nofValues;
    }
    nofValues -= chunk;
    while(chunk>0) {
      %'ModuleName'%.SPI_WRITE(value);
      chunk--;
    }
  }
  %'ModuleName'%.DATA_MODE_OFF();
  %'ModuleName'%.DeactivateSPI();
  return ERR_OK;
}

%endif %- SendValues
%-BW_METHOD_END SendValues
%-************************************************************************************************************
%-BW_METHOD_BEGIN StartSong
%ifdef StartSong
%define! RetVal
%include Common\VS1053StartSong.Inc
byte %'ModuleName'%.%StartSong(void)
{
  return %'ModuleName'%.%SendValues(10, 0);
}

%endif %- StartSong
%-BW_METHOD_END StartSong
%-************************************************************************************************************
%-BW_METHOD_BEGIN TerminateStreams
%ifdef TerminateStreams
%define! RetVal
%include Common\VS1053TerminateStreams.Inc
byte %'ModuleName'%.%TerminateStreams(void)
{
  uint16_t endFill, sciMode;
  uint8_t endFillByte;
  uint8_t res = ERR_OK;
  int i;

  for(;;) { /* breaks */
    /* read fillbyte from WRAM */
    res = %'ModuleName'%.%ReadWRAM(VS1053_PARA_END_FILL_BYTE, &endFill);
    if (res!=ERR_OK) {
      break;
    }
    endFillByte = endFill; /* only 8 lower bits */
    /* send at least 2052 EndFillByte */
    res = %'ModuleName'%.%SendValues(2052, endFillByte);
    if (res!=ERR_OK) {
      break;
    }
    /* set SCI_MODE bit to SM_CANCEL */
    res = %'ModuleName'%.%ReadRegister(VS1053_MODE, &sciMode);
    if (res!=ERR_OK) {
      break;
    }
    sciMode |= VS1053_MODE_SM_CANCEL;
    res = %'ModuleName'%.%WriteRegister(VS1053_MODE, sciMode);
    if (res!=ERR_OK) {
      break;
    }
    /* send up to 2048 bytes of endFillByte */
    for(i=0;i<64;i++) {
      res = %'ModuleName'%.%SendValues(32, endFillByte);
      if (res!=ERR_OK) {
        break;
      }
      /* read SCI_MODE register. If SM_CANCEL is still set, repeat ... */
      res = %'ModuleName'%.%ReadRegister(VS1053_MODE, &sciMode);
      if (res!=ERR_OK) {
        break;
      }
      if (!(sciMode&VS1053_MODE_SM_CANCEL)) {
        break;
      }
    } /* for */
    if (sciMode&VS1053_MODE_SM_CANCEL) {
      /* \todo Need software reset! */
      res = ERR_FAILED;
    }
    if (res!=ERR_OK) {
      break;
    }
    break;
  } /* for */
  return res;
}

%endif %- TerminateStreams
%-BW_METHOD_END TerminateStreams
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetVolume
%ifdef SetVolume
%define! Parleft
%define! Parright
%define! RetVal
%include Common\VS1053SetVolume.Inc
byte %'ModuleName'%.%SetVolume(byte left, byte right)
{
  /* max volume: 0x0000, total silence: 0xFEFE, 0xFFFF analog power down */
  return %'ModuleName'%.%WriteRegister(VS1053_VOL, (left<<8)|right);
}

%endif %- SetVolume
%-BW_METHOD_END SetVolume
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendData
%ifdef SendData
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\VS1053SendData.Inc
byte %'ModuleName'%.%SendData(byte *data, size_t dataSize)
{
  if (dataSize!=%'ModuleName'%.DATA_SIZE_BYTES) {
    return ERR_FAULT; /* need 32 bytes! */
  }
  %'ModuleName'%.ActivateSPI();
  %'ModuleName'%.DATA_MODE_ON();
  while(dataSize>0) {
    while(!%'ModuleName'%.%IsReady()) {
      %'ModuleName'%.WAIT_IF_NOT_READY_WAIT(); /* wait until pin goes high so we know it is ready */
    }
    %'ModuleName'%.SPI_WRITE(*data++);
    dataSize--;
  }
  %'ModuleName'%.DATA_MODE_OFF();
  %'ModuleName'%.DeactivateSPI();
  return ERR_OK;
}

%endif %- SendData
%-BW_METHOD_END SendData
%-************************************************************************************************************
%-BW_METHOD_BEGIN LoadUserCode
%ifdef LoadUserCode
%define! Pardata
%define! ParnofWords
%define! RetVal
%include Common\VS1053LoadUserCode.Inc
byte %'ModuleName'%.%LoadUserCode(const uint16_t *data, word nofWords)
{
  int i;
  uint16_t addr, n, val;
  uint8_t res = ERR_OK;

  i = 0;
  while(i<nofWords) {
    addr = data[i++];
    n = data[i++];
    while(n--) {
      val = data[i++];
      res = %'ModuleName'%.%WriteRegister(addr, val);
      if (res!=ERR_OK) {
        break;
      }
    }
  }
  return res;
}

%endif %- LoadUserCode
%-BW_METHOD_END LoadUserCode
%-************************************************************************************************************
%-BW_METHOD_BEGIN LoadRealtimeMidiPlugin
%ifdef LoadRealtimeMidiPlugin
%define! RetVal
%include Common\VS1053LoadRealtimeMidiPlugin.Inc
byte %'ModuleName'%.%LoadRealtimeMidiPlugin(void)
{
  return %'ModuleName'%.%LoadUserCode(&%'ModuleName'%.Realtime_MIDI_Plugin[0], sizeof(%'ModuleName'%.Realtime_MIDI_Plugin)/sizeof(%'ModuleName'%.Realtime_MIDI_Plugin[0]));
}

%endif %- LoadRealtimeMidiPlugin
%-BW_METHOD_END LoadRealtimeMidiPlugin
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG SendMIDI
%define! Pardata
%define! RetVal
%include Common\GeneralInternal.inc (SendMIDI)
byte %'ModuleName'%.SendMIDI(byte data)
{
  %'ModuleName'%.SPI_WRITE(0x00);
  %'ModuleName'%.SPI_WRITE(data);
  return ERR_OK;
}

%-INTERNAL_METHOD_END SendMIDI
%-************************************************************************************************************
%-BW_METHOD_BEGIN TalkMIDI
%ifdef TalkMIDI
%define! Parcmd
%define! Pardata1
%define! Pardata2
%define! RetVal
%include Common\VS1053TalkMIDI.Inc
byte %'ModuleName'%.%TalkMIDI(byte cmd, byte data1, byte data2)
{
  %'ModuleName'%.ActivateSPI();
  %'ModuleName'%.DATA_MODE_ON();
  while(!%'ModuleName'%.%IsReady()) {
    %'ModuleName'%.WAIT_IF_NOT_READY_WAIT(); /* wait until pin goes high so we know it is ready */
  }
  (void)%'ModuleName'%.SendMIDI(cmd);
  /* some MIDI commands have only one data byte. All cmds less than 0xBn have two data bytes */
  if ((cmd&0xF0)<=0xB0 || (cmd&0xF0)>=0xE0) {
    (void)%'ModuleName'%.SendMIDI(data1);
    (void)%'ModuleName'%.SendMIDI(data2);
  } else {
    (void)%'ModuleName'%.SendMIDI(data1);
  }
  %'ModuleName'%.DATA_MODE_OFF();
  %'ModuleName'%.DeactivateSPI();
  return ERR_OK;
}

%endif %- TalkMIDI
%-BW_METHOD_END TalkMIDI
%-************************************************************************************************************
%-BW_METHOD_BEGIN NoteOnMIDI
%ifdef NoteOnMIDI
%define! Parchannel
%define! Parnote
%define! Parvelocity
%define! RetVal
%include Common\VS1053NoteOnMIDI.Inc
byte %'ModuleName'%.%NoteOnMIDI(byte channel, byte note, byte velocity)
{
  return %'ModuleName'%.%TalkMIDI((0x90|channel), note, velocity);
}

%endif %- NoteOnMIDI
%-BW_METHOD_END NoteOnMIDI
%-************************************************************************************************************
%-BW_METHOD_BEGIN NoteOffMIDI
%ifdef NoteOffMIDI
%define! Parchannel
%define! Parnote
%define! Parvelocity
%define! RetVal
%include Common\VS1053NoteOffMIDI.Inc
byte %'ModuleName'%.%NoteOffMIDI(byte channel, byte note, byte velocity)
{
  return %'ModuleName'%.%TalkMIDI((0x80|channel), note, velocity);
}

%endif %- NoteOffMIDI
%-BW_METHOD_END NoteOffMIDI
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_METHOD_BEGIN OnActivateSPI
%ifdef OnActivateSPI
%IMPLEMENTATION OnActivateSPI
%include Common\VS1053OnActivateSPI.Inc
void %OnActivateSPI(void)
{
  /* Write your code here ... */
}

%endif %- OnActivateSPI
%-BW_METHOD_END OnActivateSPI
%-BW_METHOD_BEGIN OnDeactivateSPI
%ifdef OnDeactivateSPI
%IMPLEMENTATION OnDeactivateSPI
%include Common\VS1053OnDeactivateSPI.Inc
void %OnDeactivateSPI(void)
{
  /* Write your code here ... */
}

%endif %- OnDeactivateSPI
%-BW_METHOD_END OnDeactivateSPI
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
  (void)%'ModuleName'%.%Init();
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This component is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-

%-Driver generated by the Bean Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Bean Wizard
%- If you change these lines, Bean Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    11.07.2008
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%define! Description_Init Initialization routine
%ifdef SMAC
  %ifdef @SMAC@ResetIndication
    %define! Description_%@SMAC@ResetIndication Event in case of Transceiver reset. The event services the event of the inherited component and eventually invokes other events.
  %endif %- @SMAC@ResetIndication
%endif %- SMAC
%ifdef SMAC
  %ifdef @SMAC@DataIndicationPacket
    %define! Description_%@SMAC@DataIndicationPacket Event in case data packet received. The event services the event of the inherited component and eventually invokes other events.
  %endif %- @SMAC@DataIndicationPacket
%endif %- SMAC
%ifdef SimpleEvents
  %ifdef @SimpleEvents@AppHandleEvent
    %define! Description_%@SimpleEvents@AppHandleEvent  The event services the event of the inherited component and eventually invokes other events.
  %endif %- @SimpleEvents@AppHandleEvent
%endif %- SimpleEvents
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\App_SMAC_HelloSettings.Inc
%define! Abstract Common\App_SMAC_HelloAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"
%include sw\CommonSupport.prg

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
%-BW_CUSTOM_USERTYPE_END


%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN HandleState
%ifdef HandleState
void %'ModuleName'%.%HandleState(void);
%include Common\App_SMAC_HelloHandleState.Inc

%endif %- HandleState
%-BW_METHOD_END HandleState
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG Init
void %'ModuleName'%.Init(void);
%include Common\GeneralInternal.inc (Init)

%-INTERNAL_METHOD_END Init
%-INHERITED_EVENT_BEGIN SMAC ResetIndication
%ifdef @SMAC@ResetIndication
void %@SMAC@ResetIndication(void);

%endif %- @SMAC@ResetIndication
%-INHERITED_EVENT_END SMAC ResetIndication
%-INHERITED_EVENT_BEGIN SMAC DataIndicationPacket
%ifdef @SMAC@DataIndicationPacket
void %@SMAC@DataIndicationPacket(tRxPacket *sRxPacket);

%endif %- @SMAC@DataIndicationPacket
%-INHERITED_EVENT_END SMAC DataIndicationPacket
%-************************************************************************************************************
%-INHERITED_EVENT_BEGIN SimpleEvents AppHandleEvent
%ifdef @SimpleEvents@AppHandleEvent
void %@SimpleEvents@AppHandleEvent(byte event);

%endif %- @SimpleEvents@AppHandleEvent
%-INHERITED_EVENT_END SimpleEvents AppHandleEvent
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_METHOD_BEGIN ResetIndication
%ifdef ResetIndication
%INTERFACE ResetIndication
void %ResetIndication(void);
%include Common\App_SMAC_HelloResetIndication.Inc

%endif %- ResetIndication
%-BW_METHOD_END ResetIndication
%-BW_METHOD_BEGIN DataIndicationPacket
%ifdef DataIndicationPacket
%INTERFACE DataIndicationPacket
void %DataIndicationPacket(tRxPacket *sRxPacket);
%define! ParsRxPacket
%include Common\App_SMAC_HelloDataIndicationPacket.Inc

%endif %- DataIndicationPacket
%-BW_METHOD_END DataIndicationPacket
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\App_SMAC_HelloSettings.Inc
%define! Abstract Common\App_SMAC_HelloAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
#include <string.h> /* for strcmp() */
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%-
/* Radio state definitions */
#define INITIAL_STATE              1
#define RESET_STATE                2
#define TIMEOUT_STATE              3
%if AppIsSender='yes'
#define TX_STATE                   4
#define ACK_RECEIVED_STATE         5
#define DELAY_STATE                6
#define WAITING_FOR_ACK            7
%else
#define RX_STATE                   4
#define GOOD_PACKET                5
#define WAITING_FOR_PACKET         6
%endif

static volatile byte gi8AppStatus = 0;

static tRxPacket gsRxPacket;                                     %>40 /*!< SMAC structure for RX packets */
static byte au8RxDataBuffer[%@SMAC@'ModuleName'%.RADIO_BUF_SIZE];%>40 /*!< Data buffer to hold RX data */

static tTxPacket gsTxPacket;                                     %>40 /*!< SMAC structure for TX packets */
static byte gau8TxDataBuffer[%@SMAC@'ModuleName'%.RADIO_BUF_SIZE];%>40 /*!< Data buffer to hold TX data */

%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN HandleState
%ifdef HandleState
%include Common\App_SMAC_HelloHandleState.Inc
void %'ModuleName'%.%HandleState(void)
{
  %@SimpleEvents@'ModuleName'%.HandleEvent(); /* process pending events and call event handler. This will update gi8AppStatus */
  switch (gi8AppStatus) {
    case INITIAL_STATE:
      /* indicate at application startup that we are going to do something... */
%if LCDenabled='yes'
      %@LCD@'ModuleName'%.WriteLineStr(1, "SMAC Hello App");
  %if AppIsSender='yes'
      %@LCD@'ModuleName'%.WriteLineStr(2, "Sender");
  %else
      %@LCD@'ModuleName'%.WriteLineStr(2, "Receiver");
  %endif
%endif %- LCDenabled
%if TerminalEnabled='yes'
      %@Term@'ModuleName'%.SendStr("SMAC Hello Application\r\n");
  %if AppIsSender='yes'
      %@Term@'ModuleName'%.SendStr("I'm the Sender: I send '%HelloString' and expect '%AckString' as response.\r\n");
  %else
      %@Term@'ModuleName'%.SendStr("I'm the Receiver: I expect '%HelloString' and will respond with '%AckString'\r\n");
  %endif
%endif
      %if defined(LED0)
      %@LED0@'ModuleName'%.On();
      %endif
      %if defined(LED1)
      %@LED1@'ModuleName'%.On();
      %endif
      %if defined(LED2)
      %@LED2@'ModuleName'%.On();
      %endif
      %if defined(LED3)
      %@LED3@'ModuleName'%.On();
      %endif
      %@Wait@'ModuleName'%.Waitms(200);
      %if defined(LED0)
      %@LED0@'ModuleName'%.Off();
      %endif
      %if defined(LED1)
      %@LED1@'ModuleName'%.Off();
      %endif
      %if defined(LED2)
      %@LED2@'ModuleName'%.Off();
      %endif
      %if defined(LED3)
      %@LED3@'ModuleName'%.Off();
      %endif
%if AppIsSender='yes'
      gi8AppStatus = TX_STATE;    %>%CTAB /* Since we are tx: Set TX_STATE */
%else
      gi8AppStatus = RX_STATE;    %>%CTAB /* Since we are rx: Set RX_STATE */
%endif
      break;
%if AppIsSender='yes'
    case TX_STATE:
        /* Load the tx buffer with the packet */
        %@Utility@'ModuleName'%.strcpy((char *)gau8TxDataBuffer, sizeof(gau8TxDataBuffer), "%HelloString");
        gsTxPacket.u8DataLength = sizeof("%HelloString"); %>%CTAB /* Set the data length of the packet */
        if (%@SMAC@'ModuleName'%.MCPSDataRequest(&gsTxPacket) == %@SMAC@'ModuleName'%.SUCCESS) {
          /* TX Packet, blocking, will stay here until the packet is in the air */
          (void)%@SMAC@'ModuleName'%.MLMERXEnableRequest(&gsRxPacket, 0x%#w%RxSenderTimeout); %>%CTAB /* Now turn on the RX with a timeout value */
%if TerminalEnabled='yes'
          %@Term@'ModuleName'%.SendStr("Sent: '%HelloString', waiting for '%AckString'...\r\n");
%endif
        }
        gi8AppStatus= WAITING_FOR_ACK;  %>%CTAB /* Set status as waiting for ack. */
        break;
    case WAITING_FOR_ACK:
        /* At this point only two things happen, 1-we receive the ack packet or 2-timeout.
         * Either way the TX will leave this state and continue. Low power mode could be placed here
         * because both 1 and 2 are interrupt driven, in this case we keep it simple
         */
        break;
    case ACK_RECEIVED_STATE:
%if TerminalEnabled='yes'
        %@Term@'ModuleName'%.SendStr("Received: %AckString\r\n");
%endif
        gi8AppStatus = DELAY_STATE; %>%CTAB /* go to delay state */
        break;
    case DELAY_STATE:
        /* Sets the TX rate, small delay means TX rate is fast while larger values slow it down. */
        %@Wait@'ModuleName'%.Waitms(%DelayMs);
        gi8AppStatus = TX_STATE; %>%CTAB /* After the delay, retransmit */
        break;
%else
    case RX_STATE:
      %@SMAC@'ModuleName'%.MLMERXEnableRequest(&gsRxPacket, 0x%#w%RxReceiverTimeout); %>%CTAB /* Zero means wait forever with RX ON */
      gi8AppStatus = WAITING_FOR_PACKET;
      break;
    case WAITING_FOR_PACKET:
      break;
    case GOOD_PACKET:
%if TerminalEnabled='yes'
      %@Term@'ModuleName'%.SendStr("Received: %HelloString\r\nSending: %AckString\r\n");
%endif
      /* Build the ack packet. */
      %@Utility@'ModuleName'%.strcpy((char *)gau8TxDataBuffer, sizeof(gau8TxDataBuffer), "%AckString");
      gsTxPacket.u8DataLength = sizeof("%AckString");     %>%CTAB  /* Set the dataLength */
      gsTxPacket.pu8Data = &gau8TxDataBuffer[0];
      (void)%@SMAC@'ModuleName'%.MCPSDataRequest(&gsTxPacket);  %>%CTAB /* Request to TX data */
      gi8AppStatus = RX_STATE;
      break;
%endif
    case TIMEOUT_STATE:
    %if TerminalEnabled='yes'
      %@Term@'ModuleName'%.SendStr("Timeout\r\n");
    %endif
    %if AppIsSender='yes'
      gi8AppStatus = TX_STATE; %>%CTAB /* If timeout occurs, simply set back to TX_STATE to transmit again. */
    %else
      gi8AppStatus = RX_STATE;
    %endif
      break;
    case RESET_STATE:
      /* Transceiver reset, reinitialize and return to default state. */
      %@SMAC@'ModuleName'%.RadioInit();
%if AppIsSender='yes'
      gi8AppStatus = TX_STATE;
%else
      gi8AppStatus = RX_STATE;
%endif
      break;
    default:
        break;
  }
}

%endif %- HandleState
%-BW_METHOD_END HandleState
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG Init
%include Common\GeneralInternal.inc (Init)
void %'ModuleName'%.Init(void)
{
  (void)%@SMAC@'ModuleName'%.MLMESetMC13192ClockRate(%ClockRate);        %>%CTAB /* Set initial Clk speed from transceiver (CLKO)*/
  (void)%@SMAC@'ModuleName'%.MLMESetChannelRequest(%Channel);            %>%CTAB /* Set channel */
  (void)%@SMAC@'ModuleName'%.MLMEMC13192PAOutputAdjust(%OutputPower);    %>%CTAB /* Set output power setting */
  /*Initialize the packet.*/
  gsTxPacket.u8DataLength = 0;                 %>%CTAB /* Set TX default length to 0 */
  gsTxPacket.pu8Data = &gau8TxDataBuffer[0];   %>%CTAB /* Load the address of our txbuffer into the tx structure */

  gsRxPacket.u8DataLength = 0;                 %>%CTAB /* Set RX default to 0*/
  gsRxPacket.pu8Data = &au8RxDataBuffer[0];    %>%CTAB /* Load the address of our rxbuffer into rx structure*/
  gsRxPacket.u8MaxDataLength = %MaxDataLength; %>%CTAB /* Define the max buffer we are interested in.*/
  gsRxPacket.u8Status = 0;                     %>%CTAB /* initialize the status packet to 0.*/

  gi8AppStatus= INITIAL_STATE;        %>%CTAB /* Set the initial u8app_statusof the application state variable to INITIAL_STATE*/
}

%-INTERNAL_METHOD_END Init
%-INHERITED_EVENT_BEGIN SMAC ResetIndication
%ifdef @SMAC@ResetIndication
%include Common\GeneralInternal.inc (ResetIndication)
void %@SMAC@ResetIndication(void)
{
  %@SimpleEvents@'ModuleName'%.SetEvent(%@SimpleEvents@'ModuleName'%.RADIO_RESET); %>%CTAB /* MC13192 reset, re-initialize.*/
  %ifdef ResetIndication
  /* Calling inherited event */
  %ResetIndication();
  %endif ResetIndication
}

%endif %- @SMAC@ResetIndication
%-INHERITED_EVENT_END SMAC ResetIndication
%-INHERITED_EVENT_BEGIN SMAC DataIndicationPacket
%ifdef @SMAC@DataIndicationPacket
%include Common\GeneralInternal.inc (DataIndicationPacket)
void %@SMAC@DataIndicationPacket(tRxPacket *sRxPacket)
{
  if (sRxPacket->u8Status == %@SMAC@'ModuleName'%.TIMEOUT) { %>%CTAB /* Put timeout condition code here */
    %if defined(LED1)
    %@LED1@'ModuleName'%.Neg(); %>%CTAB /* indicator for bad or no communication */
    %endif
    %if defined(LED2)
    %@LED2@'ModuleName'%.Neg(); %>%CTAB /* indicator for bad or no communication */
    %endif
    %@SimpleEvents@'ModuleName'%.SetEvent(%@SimpleEvents@'ModuleName'%.RADIO_TIMEOUT);
  } else if (sRxPacket->u8Status == %@SMAC@'ModuleName'%.SUCCESS) { /* good packet received: handle it. */
%if AppIsSender='yes'
    /* check to see if it is an acknowledge packet...*/
    if (strcmp((const char*)sRxPacket->pu8Data, "%AckString") == 0) {
      %if defined(LED0)
      %@LED0@'ModuleName'%.Neg();  %>%CTAB /* toggle LED to show communication. */
      %endif
      %@SimpleEvents@'ModuleName'%.SetEvent(%@SimpleEvents@'ModuleName'%.RADIO_ACK);
    } else {
      /* A good packet was received but it is not the ack packet we want.
       * Whenever a good packet is received the radio will default back to idle, so
       * retransmit by setting state variable to TX_STATE in the event handler. This resets the machine.
       */
      %@SimpleEvents@'ModuleName'%.SetEvent(%@SimpleEvents@'ModuleName'%.RADIO_UNKNOWN);
    }
%else
    /* check if it is the packet we expect... */
    if (strcmp((const char*)sRxPacket->pu8Data, "%HelloString") == 0) {
      %if defined(LED0)
      %@LED0@'ModuleName'%.Neg(); %>%CTAB /* indicator for good communication */
      %endif
      %@SimpleEvents@'ModuleName'%.SetEvent(%@SimpleEvents@'ModuleName'%.RADIO_HELLO);
    } else {
      %if defined(LED1)
      %@LED1@'ModuleName'%.Neg(); %>%CTAB /* indicator for bad or no communication */
      %endif
      %if defined(LED2)
      %@LED2@'ModuleName'%.Neg(); %>%CTAB /* indicator for bad or no communication */
      %endif
      %@SimpleEvents@'ModuleName'%.SetEvent(%@SimpleEvents@'ModuleName'%.RADIO_UNKNOWN);
    }
%endif
  } else if (sRxPacket->u8Status == %@SMAC@'ModuleName'%.OVERFLOW) { /* received packet, but it was longer than what we expect. */
    %if defined(LED1)
    %@LED1@'ModuleName'%.Neg(); %>%CTAB /* indicator for bad or no communication */
    %endif
    %if defined(LED2)
    %@LED2@'ModuleName'%.Neg(); %>%CTAB /* indicator for bad or no communication */
    %endif
    %@SimpleEvents@'ModuleName'%.SetEvent(%@SimpleEvents@'ModuleName'%.RADIO_OVERFLOW);
  }
  %ifdef DataIndicationPacket
  /* Calling inherited event */
  %DataIndicationPacket(sRxPacket);
  %endif DataIndicationPacket
}

%endif %- @SMAC@DataIndicationPacket
%-INHERITED_EVENT_END SMAC DataIndicationPacket
%-************************************************************************************************************
%-INHERITED_EVENT_BEGIN SimpleEvents AppHandleEvent
%ifdef @SimpleEvents@AppHandleEvent
%include Common\GeneralInternal.inc (AppHandleEvent)
void %@SimpleEvents@AppHandleEvent(byte event)
{
  switch(event) {
    case %@SimpleEvents@'ModuleName'%.RADIO_RESET:
      gi8AppStatus = RESET_STATE;
      break;
    case %@SimpleEvents@'ModuleName'%.RADIO_TIMEOUT:
      gi8AppStatus = TIMEOUT_STATE;
      break;
%if AppIsSender='yes'
    case %@SimpleEvents@'ModuleName'%.RADIO_ACK:
      gi8AppStatus = ACK_RECEIVED_STATE;
      break;
%else
    case %@SimpleEvents@'ModuleName'%.RADIO_HELLO:
      gi8AppStatus = GOOD_PACKET;
      break;
%endif
    case %@SimpleEvents@'ModuleName'%.RADIO_OVERFLOW:
      break;
    case %@SimpleEvents@'ModuleName'%.RADIO_UNKNOWN:
%if AppIsSender='yes'
      gi8AppStatus = TX_STATE;
%else
      gi8AppStatus = RX_STATE;
%endif
      break;
  } /* switch */
}

%endif %- @SimpleEvents@AppHandleEvent
%-INHERITED_EVENT_END SimpleEvents AppHandleEvent
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_METHOD_BEGIN ResetIndication
%ifdef ResetIndication
%IMPLEMENTATION ResetIndication
%include Common\App_SMAC_HelloResetIndication.Inc
void %ResetIndication(void)
{
  /* Write your code here ... */
}

%endif %- ResetIndication
%-BW_METHOD_END ResetIndication
%-BW_METHOD_BEGIN DataIndicationPacket
%ifdef DataIndicationPacket
%IMPLEMENTATION DataIndicationPacket
%define! ParsRxPacket
%include Common\App_SMAC_HelloDataIndicationPacket.Inc
void %DataIndicationPacket(tRxPacket *sRxPacket)
{
  /* Write your code here ... */
}

%endif %- DataIndicationPacket
%-BW_METHOD_END DataIndicationPacket
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
  %'ModuleName'%.Init();
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This bean is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-

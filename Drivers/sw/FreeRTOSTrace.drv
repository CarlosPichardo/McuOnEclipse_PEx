%-Driver generated by the Component Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPESsend
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Component Wizard
%- If you change these lines, Component Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Martin Bucher
%define DriverVersion 01.00
%define DriverDate    19.04.2011
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\FreeRTOSTraceSettings.Inc
%define! Abstract Common\FreeRTOSTraceAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */
%-#include "FreeRTOSConfig.h"

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
#include "%ProcessorModule.h"
%if %PercipioTraceEnabled='yes'
#include "trcKernel.h"
#include "trcConfig.h"

extern portTickType uiTraceTickCount; /* variable holding the RTOS tick counter */
%endif

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
%-BW_CUSTOM_USERTYPE_END
%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN Reserve
%ifdef Reserve
void %'ModuleName'%.%Reserve(void);
%include Common\FreeRTOSTraceReserve.Inc

%endif %- Reserve
%-BW_METHOD_END Reserve
%-************************************************************************************************************
%-BW_METHOD_BEGIN Unreserve
%ifdef Unreserve
void %'ModuleName'%.%Unreserve(void);
%include Common\FreeRTOSTraceUnreserve.Inc

%endif %- Unreserve
%-BW_METHOD_END Unreserve
%-************************************************************************************************************
%-BW_METHOD_BEGIN Select
%ifdef Select
byte %'ModuleName'%.%Select(void);
%define! RetVal
%include Common\FreeRTOSTraceSelect.Inc

%endif %- Select
%-BW_METHOD_END Select
%-************************************************************************************************************
%-BW_METHOD_BEGIN Unselect
%ifdef Unselect
byte %'ModuleName'%.%Unselect(void);
%define! RetVal
%include Common\FreeRTOSTraceUnselect.Inc

%endif %- Unselect
%-BW_METHOD_END Unselect
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendByte
%ifdef SendByte
byte %'ModuleName'%.%SendByte(byte val);
%define! Parval
%define! RetVal
%include Common\FreeRTOSTraceSendByte.Inc

%endif %- SendByte
%-BW_METHOD_END SendByte
%-************************************************************************************************************
%-BW_METHOD_BEGIN Enable
%ifdef Enable
void %'ModuleName'%.%Enable(void);
%include Common\FreeRTOSTraceEnable.Inc

%endif %- Enable
%-BW_METHOD_END Enable
%-************************************************************************************************************
%-BW_METHOD_BEGIN Disable
%ifdef Disable
void %'ModuleName'%.%Disable(void);
%include Common\FreeRTOSTraceDisable.Inc

%endif %- Disable
%-BW_METHOD_END Disable
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
void %'ModuleName'%.%Init(void);
%include Common\FreeRTOSTraceInit.Inc

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\FreeRTOSTraceSettings.Inc
%define! Abstract Common\FreeRTOSTraceAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */
#include "FreeRTOS.h"
%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%if %PercipioTraceEnabled='no'
#define PRE_BYTE 99 /* this byte is send before a Message starts */
#define END_BYTE 98 /* this byte is send at the end of a Massage */
%endif
%-BW_CUSTOM_VARIABLE_START
static bool enableTrace = TRUE;
%if (%I2CEnabledSW = 'yes' & defined(SWI2C)) || (%I2CEnabledHW = 'yes' & defined(HWI2C))
static byte idxBuf = 10; /* 10 because the fist 10 byte of the I2C buffer shoud be 0 */
%if (%I2CEnabledSW = 'yes' & defined(SWI2C))
static byte buf1[%bufferI2CSW];
static byte buf2[%bufferI2CSW];
%endif
%if (%I2CEnabledHW = 'yes' & defined(HWI2C))
static byte buf1[%bufferI2CHW];
static byte buf2[%bufferI2CHW];
%endif
static word sendTemp; /* Temporary variable for SendChar (RecvChar) when they call SendBlock (RecvBlock) */
%endif
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%-
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN Reserve
%ifdef Reserve
%include Common\FreeRTOSTraceReserve.Inc
void %'ModuleName'%.%Reserve(void)
{
  /* If you see this comment in generated code, it means that method is not implemented yet ... */
}

%endif %- Reserve
%-BW_METHOD_END Reserve
%-************************************************************************************************************
%-BW_METHOD_BEGIN Unreserve
%ifdef Unreserve
%include Common\FreeRTOSTraceUnreserve.Inc
void %'ModuleName'%.%Unreserve(void)
{
  /* If you see this comment in generated code, it means that method is not implemented yet ... */
}

%endif %- Unreserve
%-BW_METHOD_END Unreserve
%-************************************************************************************************************
%-BW_METHOD_BEGIN Select
%ifdef Select
%define! RetVal
%include Common\FreeRTOSTraceSelect.Inc
byte %'ModuleName'%.%Select(void)
{
%if %TerminalEnabled='yes' & defined(Term)
  return ERR_OK;
%elif %I2CEnabledSW = 'yes' & defined(SWI2C)
  return %@SWI2C@'ModuleName'%.SelectSlave(%I2CSlaveAddressSW);
%elif %I2CEnabledHW = 'yes' & defined(HWI2C)
  return %@HWI2C@'ModuleName'%.SelectSlave(%I2CSlaveAddressHW);
%else
  return ERR_OK;
%endif
}

%endif %- Select
%-BW_METHOD_END Select
%-************************************************************************************************************
%-BW_METHOD_BEGIN Unselect
%ifdef Unselect
%define! RetVal
%include Common\FreeRTOSTraceUnselect.Inc
byte %'ModuleName'%.%Unselect(void)
{
  return ERR_OK;
}

%endif %- Unselect
%-BW_METHOD_END Unselect
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendByte
%ifdef SendByte
%define! Parval
%define! RetVal
%include Common\FreeRTOSTraceSendByte.Inc
byte %'ModuleName'%.%SendByte(byte val)
{
%if (%I2CEnabledSW = 'yes' & defined(SWI2C)) || (%I2CEnabledHW = 'yes' & defined(HWI2C))
  static bool selectBuf = TRUE;
  byte errTemp = 0;
%endif

  if(enableTrace) {
%if %TerminalEnabled='yes' & defined(Term)
    %@Term@'ModuleName'%.SendChar(val);
    return ERR_OK;
%elif %I2CEnabledSW = 'yes' & defined(SWI2C)
    if( selectBuf){
      if(idxBuf < sizeof(buf1)-1) {
        buf1[idxBuf] = val;
        idxBuf++;
        return ERR_OK;
      } else {
        buf1[sizeof(buf1)-1] = val;
        (void)%'ModuleName'%.%Select();
        errTemp = %@SWI2C@'ModuleName'%.SendBlock(buf1,sizeof(buf1),&sendTemp);
        idxBuf = 0;
        selectBuf = FALSE;
        return errTemp;
      }
    } else {
       if (idxBuf < sizeof(buf2)-1) {
        buf2[idxBuf] = val;
        idxBuf++;
        return ERR_OK;
      } else {
        buf2[sizeof(buf2)-1] = val;
        (void)%'ModuleName'%.%Select();
        errTemp = %@SWI2C@'ModuleName'%.SendBlock(buf2,sizeof(buf2),&sendTemp);
        idxBuf = 0;
        selectBuf = TRUE;
        return errTemp;
      }
    }
%elif %I2CEnabledHW = 'yes' & defined(HWI2C)
     if (selectBuf) {
      if (idxBuf < sizeof(buf1)-1) {
        buf1[idxBuf] = val;
        idxBuf++;
        return ERR_OK;
      } else {
        buf1[sizeof(buf1)-1] = val;
        (void)%'ModuleName'%.%Select();
        errTemp = %@HWI2C@'ModuleName'%.SendBlock(buf1,sizeof(buf1),&sendTemp);
        idxBuf = 0;
        selectBuf = FALSE;
        return errTemp;
      }
    } else {
       if (idxBuf < sizeof(buf2)-1) {
        buf2[idxBuf] = val;
        idxBuf++;
        return ERR_OK;
      } else {
        buf2[sizeof(buf2)-1] = val;
        (void)%'ModuleName'%.%Select();
        errTemp = %@HWI2C@'ModuleName'%.SendBlock(buf2,sizeof(buf2),&sendTemp);
        idxBuf = 0;
        selectBuf = TRUE;
        return errTemp;
      }
    }
%else
    /* no communication channel selected? */
    return ERR_DISABLED;
%endif
  } else {
    (void)val;
    return ERR_DISABLED;
  }
}

%endif %- SendByte
%-BW_METHOD_END SendByte
%-************************************************************************************************************
%-BW_METHOD_BEGIN Enable
%ifdef Enable
%include Common\FreeRTOSTraceEnable.Inc
void %'ModuleName'%.%Enable(void)
{
  enableTrace = TRUE;
}

%endif %- Enable
%-BW_METHOD_END Enable
%-************************************************************************************************************
%-BW_METHOD_BEGIN Disable
%ifdef Disable
%include Common\FreeRTOSTraceDisable.Inc
void %'ModuleName'%.%Disable(void)
{
  enableTrace = FALSE;
}

%endif %- Disable
%-BW_METHOD_END Disable
%if %PercipioTraceEnabled = 'no'
static uint32_t PerfCounter = 0;

static void send32BitNumber(uint32_t val){
  (void)%'ModuleName'%.%SendByte((byte)((val&0xFF000000)>>24));
  (void)%'ModuleName'%.%SendByte((byte)((val&0xFF0000)>>16));
  (void)%'ModuleName'%.%SendByte((byte)((val&0xFF00)>>8));
  (void)%'ModuleName'%.%SendByte((byte)(val&0xFF));
}

%if %PerformanceCounterIncrementTick = 'yes'
#if configGENERATE_RUN_TIME_STATS != 1
  #error Missing definition: if you want use the Performance Counter you need to enable the Collect Runtime Statistics in FreeRTOS
#endif
void tracePERFORMANCE_COUNTER_INC_FUNC(uint8_t id, dword perfTick) {
  (void)id;
  PerfCounter = perfTick;
}

%endif
%if %TaskIncrementTick = 'yes'
void traceTASK_INCREMENT_TICK_FUNC(uint8_t id, uint32_t Count){
  (void)%'ModuleName'%.%SendByte(PRE_BYTE);
  (void)%'ModuleName'%.%SendByte(id);
  send32BitNumber(Count);
  (void)%'ModuleName'%.%SendByte(END_BYTE);
}

%endif
%if %TaskSwitchedIn = 'yes'
void traceTASK_SWITCHED_IN_FUNC(uint8_t id, uint8_t TaskNr){
  (void)%'ModuleName'%.%SendByte(PRE_BYTE);
  (void)%'ModuleName'%.%SendByte(id);
  (void)%'ModuleName'%.%SendByte(TaskNr);
%if %PerfTimeSend = 'yes'
  send32BitNumber(PerfCounter);
%endif
  (void)%'ModuleName'%.%SendByte(END_BYTE);
}

%endif
%if %TaskSwitchedOut = 'yes'
void traceTASK_SWITCHED_OUT_FUNC(uint8_t id, uint8_t TaskNr) {
  (void)%'ModuleName'%.%SendByte(PRE_BYTE);
  (void)%'ModuleName'%.%SendByte(id);
  (void)%'ModuleName'%.%SendByte(TaskNr);
%if %PerfTimeSend = 'yes'
  send32BitNumber(PerfCounter);
%endif
  (void)%'ModuleName'%.%SendByte(END_BYTE);
}

%endif
%if %TaskCreate = 'yes'
void traceTASK_CREATE_FUNC(uint8_t id, int8_t TaskName[], uint8_t TaskNr){
  uint8_t i;
  uint8_t *ptr = (uint8_t*)TaskName;
  uint8_t count = 0;
  bool tempEnableTrace = enableTrace;

  enableTrace = TRUE;
  while (*ptr != 0x00U) {
    ptr++;
    count++;
  }
  (void)%'ModuleName'%.%SendByte(PRE_BYTE);
  (void)%'ModuleName'%.%SendByte(id);
  (void)%'ModuleName'%.%SendByte(TaskNr);
  (void)%'ModuleName'%.%SendByte(count);  /* count of charackter form TaskName */
  for(i=0; i < count; i++) {
    (void)%'ModuleName'%.%SendByte((byte) TaskName[i]);
  }
%if %PerfTimeSend = 'yes'
  send32BitNumber(PerfCounter);
%endif
  (void)%'ModuleName'%.%SendByte(END_BYTE);
  if (!tempEnableTrace) {
    enableTrace = FALSE;
  }
}

%endif
%if %BlockingOnQueueReceive = 'yes'
void traceBLOCKING_ON_QUEUE_RECEIVE_FUNC(uint8_t id, void *Queue){
  (void)%'ModuleName'%.%SendByte(PRE_BYTE);
  (void)%'ModuleName'%.%SendByte(id);
  send32BitNumber((uint32_t)Queue);
%if %PerfTimeSend = 'yes'
  send32BitNumber(PerfCounter);
%endif
  (void)%'ModuleName'%.%SendByte(END_BYTE);
}

%endif
%if %BlockingOnQueueSend = 'yes'
void traceBLOCKING_ON_QUEUE_SEND_FUNC(uint8_t id, void *Queue){
  (void)%'ModuleName'%.%SendByte(PRE_BYTE);
  (void)%'ModuleName'%.%SendByte(id);
  send32BitNumber((uint32_t)Queue);
%if %PerfTimeSend = 'yes'
  send32BitNumber(PerfCounter);
%endif
  (void)%'ModuleName'%.%SendByte(END_BYTE);
}

%endif
%if %QueueCreate = 'yes'
void traceQUEUE_CREATE_FUNC(uint8_t id,void *NewQueue){
  (void)%'ModuleName'%.%SendByte(PRE_BYTE);
  (void)%'ModuleName'%.%SendByte(id);
  send32BitNumber((uint32_t)NewQueue);
%if %PerfTimeSend = 'yes'
  send32BitNumber(PerfCounter);
%endif
  (void)%'ModuleName'%.%SendByte(END_BYTE);
}

%endif
%if %QueueCreateFailed = 'yes'
void traceQUEUE_CREATE_FAILED_FUNC(uint8_t id, uint8_t queueType){
  (void)%'ModuleName'%.%SendByte(PRE_BYTE);
  (void)%'ModuleName'%.%SendByte(id);
  (void)%'ModuleName'%.%SendByte(queueType);
%if %PerfTimeSend = 'yes'
  send32BitNumber(PerfCounter);
%endif
  (void)%'ModuleName'%.%SendByte(END_BYTE);
}

%endif
%if %MutexCreate = 'yes'
void traceCREATE_MUTEX_FUNC(uint8_t id, void *NewMutex){
  (void)%'ModuleName'%.%SendByte(PRE_BYTE);
  (void)%'ModuleName'%.%SendByte(id);
  send32BitNumber((uint32_t)NewMutex);
%if %PerfTimeSend = 'yes'
  send32BitNumber(PerfCounter);
%endif
  (void)%'ModuleName'%.%SendByte(END_BYTE);
}

%endif
%if %MutexCreateFailed = 'yes'
void traceCREATE_MUTEX_FAILED_FUNC(uint8_t id, void* NewMutex){
  (void)%'ModuleName'%.%SendByte(PRE_BYTE);
  (void)%'ModuleName'%.%SendByte(id);
  send32BitNumber((uint32_t)NewMutex);
%if %PerfTimeSend = 'yes'
  send32BitNumber(PerfCounter);
%endif
  (void)%'ModuleName'%.%SendByte(END_BYTE);
}

%endif
%if %MutexGiveRecursive = 'yes'
void traceGIVE_MUTEX_RECURSIVE_FUNC(uint8_t id,void* Mutex){
  (void)%'ModuleName'%.%SendByte(PRE_BYTE);
  (void)%'ModuleName'%.%SendByte(id);
  send32BitNumber((uint32_t)Mutex);
%if %PerfTimeSend = 'yes'
  send32BitNumber(PerfCounter);
%endif
  (void)%'ModuleName'%.%SendByte(END_BYTE);
}

%endif
%if %MutexGiveRecursiveFailed = 'yes'
void traceGIVE_MUTEX_RECURSIVE_FAILED_FUNC(uint8_t id, void* Mutex ){
  (void)%'ModuleName'%.%SendByte(PRE_BYTE);
  (void)%'ModuleName'%.%SendByte(id);
  send32BitNumber((uint32_t)Mutex);
%if %PerfTimeSend = 'yes'
  send32BitNumber(PerfCounter);
%endif
  (void)%'ModuleName'%.%SendByte(END_BYTE);
}

%endif
%if %MutexTakeRecursive = 'yes'
void traceTAKE_MUTEX_RECURSIVE_FUNC(uint8_t id, void* Mutex ){
  (void)%'ModuleName'%.%SendByte(PRE_BYTE);
  (void)%'ModuleName'%.%SendByte(id);
  send32BitNumber((uint32_t)Mutex);
%if %PerfTimeSend = 'yes'
  send32BitNumber(PerfCounter);
%endif
  (void)%'ModuleName'%.%SendByte(END_BYTE);
}

%endif
%if %SemaphoreCreateCounting = 'yes'
void traceCREATE_COUNTING_SEMAPHORE_FUNC(uint8_t id, void* Sema){
  (void) %'ModuleName'%.%SendByte(PRE_BYTE);
  (void) %'ModuleName'%.%SendByte(id);
  send32BitNumber((uint32_t)Sema);
%if %PerfTimeSend = 'yes'
  send32BitNumber(PerfCounter);
%endif
  (void) %'ModuleName'%.%SendByte(END_BYTE);
}

%endif
%if %SemaphoreCreateCountingFailed = 'yes'
void traceCREATE_COUNTING_SEMAPHORE_FAILED_FUNC(uint8_t id, void* Sema){
  (void)%'ModuleName'%.%SendByte(PRE_BYTE);
  (void)%'ModuleName'%.%SendByte(id);
  send32BitNumber((uint32_t)Sema);
%if %PerfTimeSend = 'yes'
  send32BitNumber(PerfCounter);
%endif
  (void)%'ModuleName'%.%SendByte(END_BYTE);
}

%endif
%if %QueueSend = 'yes'
void traceQUEUE_SEND_FUNC(uint8_t id, void* Queue){
  (void)%'ModuleName'%.%SendByte(PRE_BYTE);
  (void)%'ModuleName'%.%SendByte(id);
  send32BitNumber((uint32_t)Queue);
%if %PerfTimeSend = 'yes'
  send32BitNumber(PerfCounter);
%endif
  (void)%'ModuleName'%.%SendByte(END_BYTE);
}

%endif
%if %QueueSendFailed = 'yes'
void traceQUEUE_SEND_FAILED_FUNC(uint8_t id, void* Queue){
  (void)%'ModuleName'%.%SendByte(PRE_BYTE);
  (void)%'ModuleName'%.%SendByte(id);
  send32BitNumber((uint32_t)Queue);
%if %PerfTimeSend = 'yes'
  send32BitNumber(PerfCounter);
  %endif
  (void)%'ModuleName'%.%SendByte(END_BYTE);
}
%endif
%if %QueueReceive = 'yes'

void traceQUEUE_RECEIVE_FUNC(uint8_t id, void* Queue){
  (void)%'ModuleName'%.%SendByte(PRE_BYTE);
  (void)%'ModuleName'%.%SendByte(id);
  send32BitNumber((uint32_t)Queue);
%if %PerfTimeSend = 'yes'
  send32BitNumber(PerfCounter);
%endif
  (void)%'ModuleName'%.%SendByte(END_BYTE);
}
%endif
%if %QueueReceiveFailed = 'yes'

void traceQUEUE_RECEIVE_FAILED_FUNC(uint8_t id, void* Queue ){
  (void)%'ModuleName'%.%SendByte(PRE_BYTE);
  (void)%'ModuleName'%.%SendByte(id);
  send32BitNumber((uint32_t)Queue);
%if %PerfTimeSend = 'yes'
  send32BitNumber(PerfCounter);
%endif
  (void)%'ModuleName'%.%SendByte(END_BYTE);
}

%endif
%if %QueuePeek = 'yes'
void traceQUEUE_PEEK_FUNC(uint8_t id, void *Queue) {
  (void)%'ModuleName'%.%SendByte(PRE_BYTE);
  (void)%'ModuleName'%.%SendByte(id);
  send32BitNumber((uint32_t)Queue);
%if %PerfTimeSend = 'yes'
  send32BitNumber(PerfCounter);
%endif
  (void)%'ModuleName'%.%SendByte(END_BYTE);
}

%endif
%if %QueueSendFromISR = 'yes'
void traceQUEUE_SEND_FROM_ISR_FUNC(uint8_t id, void *Queue) {
  (void)%'ModuleName'%.%SendByte(PRE_BYTE);
  (void)%'ModuleName'%.%SendByte(id);
  send32BitNumber((uint32_t)Queue);
%if %PerfTimeSend = 'yes'
  send32BitNumber(PerfCounter);
%endif
  (void)%'ModuleName'%.%SendByte(END_BYTE);
}

%endif
%if %QueueReceiveFromISR = 'yes'
void traceQUEUE_RECEIVE_FROM_ISR_FUNC(uint8_t id, void *Queue) {
  (void)%'ModuleName'%.%SendByte(PRE_BYTE);
  (void)%'ModuleName'%.%SendByte(id);
  send32BitNumber((uint32_t)Queue);
%if %PerfTimeSend = 'yes'
  send32BitNumber(PerfCounter);
%endif
  (void)%'ModuleName'%.%SendByte(END_BYTE);
}

%endif
%if %QueueSendFromISRFailed = 'yes'
void traceQUEUE_SEND_FROM_ISR_FAILED_FUNC(uint8_t id, void *Queue) {
  (void)%'ModuleName'%.%SendByte(PRE_BYTE);
  (void)%'ModuleName'%.%SendByte(id);
  send32BitNumber((uint32_t)Queue);
%if %PerfTimeSend = 'yes'
  send32BitNumber(PerfCounter);
%endif
  (void)%'ModuleName'%.%SendByte(END_BYTE);
}

%endif
%if %QueueReceiveFromISRFailed = 'yes'
void traceQUEUE_RECEIVE_FROM_ISR_FAILED_FUNC(uint8_t id, void *Queue) {
  (void)%'ModuleName'%.%SendByte(PRE_BYTE);
  (void)%'ModuleName'%.%SendByte(id);
  send32BitNumber((uint32_t)Queue);
%if %PerfTimeSend = 'yes'
  send32BitNumber(PerfCounter);
%endif
  (void)%'ModuleName'%.%SendByte(END_BYTE);
}

%endif
%if %QueueDelete = 'yes'
void traceQUEUE_DELETE_FUNC(uint8_t id, void* Queue) {
  (void)%'ModuleName'%.%SendByte(PRE_BYTE);
  (void)%'ModuleName'%.%SendByte(id);
  send32BitNumber((uint32_t)Queue);
%if %PerfTimeSend = 'yes'
  send32BitNumber(PerfCounter);
%endif
  (void)%'ModuleName'%.%SendByte(END_BYTE);
}

%endif
%if %TaskCreateFailed = 'yes'
void traceTASK_CREATE_FAILED_FUNC(uint8_t id, uint8_t TaskNr) {
  (void)%'ModuleName'%.%SendByte(PRE_BYTE);
  (void)%'ModuleName'%.%SendByte(id);
  (void)%'ModuleName'%.%SendByte(TaskNr);
%if %PerfTimeSend = 'yes'
  send32BitNumber(PerfCounter);
%endif
  (void)%'ModuleName'%.%SendByte(END_BYTE);
}

%endif
%if %TaskDelete = 'yes'
#if INCLUDE_vTaskDelete
void traceTASK_DELETE_FUNC(uint8_t id, uint8_t TaskNr) {
  (void)%'ModuleName'%.%SendByte(PRE_BYTE);
  (void)%'ModuleName'%.%SendByte(id);
  (void)%'ModuleName'%.%SendByte(TaskNr);
%if %PerfTimeSend = 'yes'
  send32BitNumber(PerfCounter);
%endif
  (void)%'ModuleName'%.%SendByte(END_BYTE);
}
#endif

%endif
%if %TaskDelayUntil = 'yes'
void traceTASK_DELAY_UNTIL_FUNC(uint8_t id, uint8_t TaskNr) {
  (void)%'ModuleName'%.%SendByte(PRE_BYTE);
  (void)%'ModuleName'%.%SendByte(id);
  (void)%'ModuleName'%.%SendByte(TaskNr);
%if %PerfTimeSend = 'yes'
  send32BitNumber(PerfCounter);
%endif
  (void)%'ModuleName'%.%SendByte(END_BYTE);
}

%endif
%if %TaskDelay = 'yes'
void traceTASK_DELAY_FUNC(uint8_t id, uint8_t TaskNr) {
  (void)%'ModuleName'%.%SendByte(PRE_BYTE);
  (void)%'ModuleName'%.%SendByte(id);
  (void)%'ModuleName'%.%SendByte(TaskNr);
%if %PerfTimeSend = 'yes'
  send32BitNumber(PerfCounter);
%endif
  (void)%'ModuleName'%.%SendByte(END_BYTE);
}

%endif
%if %TaskPrioritySet = 'yes'
void traceTASK_PRIORITY_SET_FUNC(uint8_t id, void* Task, uint8_t NewPriority, uint8_t TaskNr) {
  (void)%'ModuleName'%.%SendByte(PRE_BYTE);
  (void)%'ModuleName'%.%SendByte(id);
  send32BitNumber((uint32_t)Task);
  (void)%'ModuleName'%.%SendByte(NewPriority);
  (void)%'ModuleName'%.%SendByte(TaskNr);
%if %PerfTimeSend = 'yes'
  send32BitNumber(PerfCounter);
%endif
  (void)%'ModuleName'%.%SendByte(END_BYTE);
}

%endif
%if %TaskSuspend = 'yes'
void traceTASK_SUSPEND_FUNC(uint8_t id, uint8_t TaskNr) {
  (void)%'ModuleName'%.%SendByte(PRE_BYTE);
  (void)%'ModuleName'%.%SendByte(id);
  (void)%'ModuleName'%.%SendByte(TaskNr);
%if %PerfTimeSend = 'yes'
  send32BitNumber(PerfCounter);
%endif
  (void)%'ModuleName'%.%SendByte(END_BYTE);
}

%endif
%if %TaskResume = 'yes'
void traceTASK_RESUME_FUNC(uint8_t id, uint8_t TaskNr) {
  (void)%'ModuleName'%.%SendByte(PRE_BYTE);
  (void)%'ModuleName'%.%SendByte(id);
  (void)%'ModuleName'%.%SendByte(TaskNr);
%if %PerfTimeSend = 'yes'
  send32BitNumber(PerfCounter);
%endif
  (void)%'ModuleName'%.%SendByte(END_BYTE);
}

%endif
%if %TaskResumeFromISR = 'yes'
void traceTASK_RESUME_FROM_ISR_FUNC(uint8_t id, uint8_t TaskNr) {
  (void)%'ModuleName'%.%SendByte(PRE_BYTE);
  (void)%'ModuleName'%.%SendByte(id);
  (void)%'ModuleName'%.%SendByte(TaskNr);
%if %PerfTimeSend = 'yes'
  send32BitNumber(PerfCounter);
%endif
  (void)%'ModuleName'%.%SendByte(END_BYTE);
}

%endif
%endif %- %PercipioTraceEnabled = 'no'
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%include Common\FreeRTOSTraceInit.Inc
void %'ModuleName'%.%Init(void)
{
 /* Nothing to init */
}

%endif %- Init
%-BW_METHOD_END Init
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
  %'ModuleName'%.%Init();
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%-*****************************************************************************************************
%FILE %'DirRel_Code'FreeRTOSTraceMacros.h
%-*****************************************************************************************************
#include "PE_Types.h"
%if %PercipioTraceEnabled='yes'
#include "trcKernel.h"
%endif

%- --------------------------------------------------------------------------
%if %PerformanceCounterIncrementTick = 'yes'
%if %PercipioTraceEnabled='yes'
%- Not needed for Percepio Trace
%else
#define tracePERFORMANCE_COUNTER_INC_ID                          %>55 10
#define tracePERFORMANCE_COUNTER_INC(perfTickCnt) \
        tracePERFORMANCE_COUNTER_INC_FUNC(tracePERFORMANCE_COUNTER_INC_ID,perfTickCnt)
void tracePERFORMANCE_COUNTER_INC_FUNC(uint8_t id, dword perfTick);

%endif
%endif
%- --------------------------------------------------------------------------
%if %TaskIncrementTick = 'yes'
%if %PercipioTraceEnabled='yes'
%- #undef traceTASK_INCREMENT_TICK
#define traceTASK_INCREMENT_TICK(xTickCount) \
  { \
    extern uint32_t uiTraceTickCount; \
    uiTraceTickCount = xTickCount; \
  }

%else
#define traceTASK_INCREMENT_TICK_ID                              %>55 11
#define traceTASK_INCREMENT_TICK(xTickCount) \
    traceTASK_INCREMENT_TICK_FUNC(traceTASK_INCREMENT_TICK_ID,xTickCount)
void traceTASK_INCREMENT_TICK_FUNC(uint8_t id, uint32_t Count);

%endif
%endif
%- --------------------------------------------------------------------------
%if %TaskSwitchedIn = 'yes'
/* Called after a task has been selected to run.  pxCurrentTCB holds a pointer
 * to the task control block of the selected task.
 */
%if %PercipioTraceEnabled='yes'
%- #undef traceTASK_SWITCHED_IN
#define traceTASK_SWITCHED_IN() \
  vTraceStoreTaskswitch();

%else
#define traceTASK_SWITCHED_IN_ID                                 %>55 12
#define traceTASK_SWITCHED_IN() \
        traceTASK_SWITCHED_IN_FUNC(traceTASK_SWITCHED_IN_ID, pxCurrentTCB->uxTCBNumber)
void traceTASK_SWITCHED_IN_FUNC(uint8_t id, uint8_t TaskNr);

%endif
%endif
%- --------------------------------------------------------------------------
%if %TaskSwitchedOut = 'yes'
/* Called before a task has been selected to run.  pxCurrentTCB holds a pointer
 * to the task control block of the task being switched out.
 */
%if %PercipioTraceEnabled='yes'
/* traceTASK_SWITCHED_OUT not implemented yet */

%else
#define traceTASK_SWITCHED_OUT_ID                                %>55 13
#define traceTASK_SWITCHED_OUT() \
        traceTASK_SWITCHED_OUT_FUNC(traceTASK_SWITCHED_OUT_ID, pxCurrentTCB->uxTCBNumber)
void traceTASK_SWITCHED_OUT_FUNC(uint8_t id, uint8_t TaskNr);

%endif
%endif
%- --------------------------------------------------------------------------
%if %BlockingOnQueueReceive = 'yes'
/* Task is about to block because it cannot read from a
 * queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
 * upon which the read was attempted.  pxCurrentTCB points to the TCB of the
 * task that attempted the read.
 */
%if %PercipioTraceEnabled='yes'
%- #undef traceBLOCKING_ON_QUEUE_RECEIVE
#define traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue ) \
  portENTER_CRITICAL(); \
  vTraceStoreKernelCall((uint32_t)(EVENTGROUP_BLOCK_ON_RECEIVE + TraceObjectClassTable[pxQueue->ucQueueType]), pxQueue->ucQueueNumber); \
  if (TraceObjectClassTable[pxQueue->ucQueueType] != TRACE_CLASS_MUTEX){\
    extern volatile void * volatile pxCurrentTCB; \
    vTraceSetTaskInstanceFinished((objectHandleType)uxTaskGetTaskNumber((xTaskHandle)pxCurrentTCB)); \
  }\
  portEXIT_CRITICAL();

%else
#define traceBLOCKING_ON_QUEUE_RECEIVE_ID                        %>55 14
#define traceBLOCKING_ON_QUEUE_RECEIVE(pxQueue) \
        traceBLOCKING_ON_QUEUE_RECEIVE_FUNC(traceBLOCKING_ON_QUEUE_RECEIVE_ID, pxQueue)
void traceBLOCKING_ON_QUEUE_RECEIVE_FUNC(uint8_t id, void* Queue);

%endif
%endif
%- --------------------------------------------------------------------------
%if %BlockingOnQueueSend = 'yes'
/* Task is about to block because it cannot write to a
 * queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
 * upon which the write was attempted.  pxCurrentTCB points to the TCB of the
 * task that attempted the write.
 */
%if %PercipioTraceEnabled='yes'
%- #undef traceBLOCKING_ON_QUEUE_SEND
#define traceBLOCKING_ON_QUEUE_SEND( pxQueue ) \
  portENTER_CRITICAL();\
  vTraceStoreKernelCall((uint32_t)(EVENTGROUP_BLOCK_ON_SEND + TraceObjectClassTable[pxQueue->ucQueueType]), pxQueue->ucQueueNumber); \
  portEXIT_CRITICAL();

%else
#define traceBLOCKING_ON_QUEUE_SEND_ID                           %>55 15
#define traceBLOCKING_ON_QUEUE_SEND( pxQueue ) \
        traceBLOCKING_ON_QUEUE_SEND_FUNC(traceBLOCKING_ON_QUEUE_SEND_ID, pxQueue)
void traceBLOCKING_ON_QUEUE_SEND_FUNC(uint8_t id, void* Queue);

%endif
%endif
%- --------------------------------------------------------------------------
%if %QueueCreate = 'yes'
%if %PercipioTraceEnabled='yes'
%- #undef traceQUEUE_CREATE
#define traceQUEUE_CREATE( pxNewQueue )\
  portENTER_CRITICAL(); \
  pxNewQueue->ucQueueNumber = xTraceGetObjectHandle(TraceObjectClassTable[pxNewQueue->ucQueueType]);\
  vTraceSetObjectState(TraceObjectClassTable[pxNewQueue->ucQueueType], pxNewQueue->ucQueueNumber, 0); \
  vTraceStoreKernelCall((uint32_t)(EVENTGROUP_CREATE + TraceObjectClassTable[pxNewQueue->ucQueueType]), pxNewQueue->ucQueueNumber); \
  portEXIT_CRITICAL();

%else
#define traceQUEUE_CREATE_ID                                     %>55 16
#define traceQUEUE_CREATE( pxNewQueue ) \
        traceQUEUE_CREATE_FUNC(traceQUEUE_CREATE_ID, pxNewQueue)
void traceQUEUE_CREATE_FUNC(uint8_t id, void* NewQueue);

%endif
%endif
%- --------------------------------------------------------------------------
%if %QueueCreateFailed = 'yes'
%if %PercipioTraceEnabled='yes'
%- #undef traceQUEUE_CREATE_FAILED
#define traceQUEUE_CREATE_FAILED( queueType ) \
  portENTER_CRITICAL();\
  vTraceStoreKernelCall((uint32_t)(EVENTGROUP_FAILED_CREATE + TraceObjectClassTable[queueType]), (objectHandleType)0); \
  portEXIT_CRITICAL();

%else
#define traceQUEUE_CREATE_FAILED_ID                              %>55 17
#define traceQUEUE_CREATE_FAILED(queueType) \
        traceQUEUE_CREATE_FAILED_FUNC(traceQUEUE_CREATE_FAILED_ID, queueType)
void traceQUEUE_CREATE_FAILED_FUNC(uint8_t id, uint8_t queueType);

%endif
%endif
%- --------------------------------------------------------------------------
%if %MutexCreate = 'yes'
%if %PercipioTraceEnabled='yes'
%- #undef traceCREATE_MUTEX
#define traceCREATE_MUTEX( pxNewQueue ) \
  portENTER_CRITICAL();\
  pxNewQueue->ucQueueNumber = xTraceGetObjectHandle(TRACE_CLASS_MUTEX); \
  vTraceStoreKernelCall((uint32_t)(EVENTGROUP_CREATE + TraceObjectClassTable[pxNewQueue->ucQueueType]), pxNewQueue->ucQueueNumber); \
  vTraceSetObjectState(TRACE_CLASS_MUTEX, pxNewQueue->ucQueueNumber, 0); \
  portEXIT_CRITICAL();

%else
#define traceCREATE_MUTEX_ID                                     %>55 18
#define traceCREATE_MUTEX( pxNewQueue ) \
        traceCREATE_MUTEX_FUNC(traceCREATE_MUTEX_ID, pxNewQueue)
void traceCREATE_MUTEX_FUNC(uint8_t id, void* NewQueue);

%endif
%endif
%- --------------------------------------------------------------------------
%if %MutexCreateFailed = 'yes'
%if %PercipioTraceEnabled='yes'
%- #undef traceCREATE_MUTEX_FAILED
#define traceCREATE_MUTEX_FAILED() \
  portENTER_CRITICAL();\
  vTraceStoreKernelCall((uint32_t)(EVENTGROUP_FAILED_CREATE + TRACE_CLASS_MUTEX), 0);\
  portEXIT_CRITICAL();

%else
#define traceCREATE_MUTEX_FAILED_ID                              %>55 19
#define traceCREATE_MUTEX_FAILED() \
        traceCREATE_MUTEX_FAILED_FUNC(traceCREATE_MUTEX_FAILED_ID, pxNewQueue)
void traceCREATE_MUTEX_FAILED_FUNC(uint8_t id, void* NewQueue);

%endif
%endif
%- --------------------------------------------------------------------------
%if %MutexGiveRecursive = 'yes'
%if %PercipioTraceEnabled='yes'
/* traceGIVE_MUTEX_RECURSIVE not implemented yet */

%else
#define traceGIVE_MUTEX_RECURSIVE_ID                             %>55 20
#define traceGIVE_MUTEX_RECURSIVE( pxMutex ) \
        traceGIVE_MUTEX_RECURSIVE_FUNC(traceGIVE_MUTEX_RECURSIVE_ID, pxMutex)
void traceGIVE_MUTEX_RECURSIVE_FUNC(uint8_t id, void* Mutex);

%endif
%endif
%- --------------------------------------------------------------------------
%if %MutexGiveRecursiveFailed = 'yes'
%if %PercipioTraceEnabled='yes'
%- #undef traceGIVE_MUTEX_RECURSIVE_FAILED
#define traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex ) \
  portENTER_CRITICAL();\
  vTraceStoreKernelCall((uint32_t)(EVENTGROUP_FAILED_SEND + TRACE_CLASS_MUTEX), pxMutex->ucQueueNumber); \
  portEXIT_CRITICAL();

%else
#define traceGIVE_MUTEX_RECURSIVE_FAILED_ID                      %>55 21
#define traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex ) \
        traceGIVE_MUTEX_RECURSIVE_FAILED_FUNC(traceGIVE_MUTEX_RECURSIVE_FAILED_ID, pxMutex )
void traceGIVE_MUTEX_RECURSIVE_FAILED_FUNC(uint8_t id, void* Mutex );

%endif
%endif
%- --------------------------------------------------------------------------
%if %MutexTakeRecursive = 'yes'
%if %PercipioTraceEnabled='yes'
/* traceTAKE_MUTEX_RECURSIVE not implemented yet */

%else
#define traceTAKE_MUTEX_RECURSIVE_ID                             %>55 22
#define traceTAKE_MUTEX_RECURSIVE( pxMutex ) \
        traceTAKE_MUTEX_RECURSIVE_FUNC(traceTAKE_MUTEX_RECURSIVE_ID, pxMutex )
void traceTAKE_MUTEX_RECURSIVE_FUNC(uint8_t id, void* Mutex );
%endif
%endif
%- --------------------------------------------------------------------------
%if %SemaphoreCreateCounting = 'yes'
%if %PercipioTraceEnabled='yes'
/* traceCREATE_COUNTING_SEMAPHORE not implemented yet */

%else
#define traceCREATE_COUNTING_SEMAPHORE_ID                        %>55 23
#define traceCREATE_COUNTING_SEMAPHORE() \
        traceCREATE_COUNTING_SEMAPHORE_FUNC(traceCREATE_COUNTING_SEMAPHORE_ID, pxHandle)
void traceCREATE_COUNTING_SEMAPHORE_FUNC(uint8_t id, void* Sema);

%endif
%endif
%- --------------------------------------------------------------------------
%if %SemaphoreCreateCountingFailed = 'yes'
%if %PercipioTraceEnabled='yes'
/* traceCREATE_COUNTING_SEMAPHORE_FAILED not implemented yet */

%else
#define traceCREATE_COUNTING_SEMAPHORE_FAILED_ID                 %>55 24
#define traceCREATE_COUNTING_SEMAPHORE_FAILED() \
        traceCREATE_COUNTING_SEMAPHORE_FAILED_FUNC(traceCREATE_COUNTING_SEMAPHORE_FAILED_ID, pxHandle)
void traceCREATE_COUNTING_SEMAPHORE_FAILED_FUNC(uint8_t id, void* Sema);

%endif
%endif
%- --------------------------------------------------------------------------
%if %QueueSend = 'yes'
%if %PercipioTraceEnabled='yes'
%- #undef traceQUEUE_SEND
#define traceQUEUE_SEND( pxQueue ) \
  vTraceStoreKernelCall((uint32_t)(EVENTGROUP_SEND + TraceObjectClassTable[pxQueue->ucQueueType]), pxQueue->ucQueueNumber); \
  if (TraceObjectClassTable[pxQueue->ucQueueType] == TRACE_CLASS_MUTEX){\
    vTraceSetObjectState(TraceObjectClassTable[pxQueue->ucQueueType], (uint8_t)pxQueue->ucQueueNumber, (uint8_t)0); \
  }else{\
    vTraceSetObjectState(TraceObjectClassTable[pxQueue->ucQueueType], (uint8_t)pxQueue->ucQueueNumber, (uint8_t)(pxQueue->uxMessagesWaiting + 1)); \
  }

%else
#define traceQUEUE_SEND_ID                                       %>55 25
#define traceQUEUE_SEND( pxQueue ) \
        traceQUEUE_SEND_FUNC(traceQUEUE_SEND_ID, pxQueue)
void traceQUEUE_SEND_FUNC(uint8_t id, void* Queue);

%endif
%endif
%- --------------------------------------------------------------------------
%if %QueueSendFailed = 'yes'
%if %PercipioTraceEnabled='yes'
%- #undef traceQUEUE_SEND_FAILED
#define traceQUEUE_SEND_FAILED( pxQueue ) \
  portENTER_CRITICAL();\
  vTraceStoreKernelCall((uint32_t)(EVENTGROUP_FAILED_SEND + TraceObjectClassTable[pxQueue->ucQueueType]), pxQueue->ucQueueNumber); \
  portEXIT_CRITICAL();

%else
#define traceQUEUE_SEND_FAILED_ID                                %>55 26
#define traceQUEUE_SEND_FAILED( pxQueue ) \
        traceQUEUE_SEND_FAILED_FUNC(traceQUEUE_SEND_FAILED_ID, pxQueue)
void traceQUEUE_SEND_FAILED_FUNC(uint8_t id, void* Queue);

%endif
%endif
%- --------------------------------------------------------------------------
%if %QueueReceive = 'yes'
%if %PercipioTraceEnabled='yes'
%- #undef traceQUEUE_RECEIVE
#define traceQUEUE_RECEIVE( pxQueue ) \
  vTraceStoreKernelCall((uint32_t)(EVENTGROUP_RECEIVE + TraceObjectClassTable[pxQueue->ucQueueType]), pxQueue->ucQueueNumber); \
  if (TraceObjectClassTable[pxQueue->ucQueueType] == TRACE_CLASS_MUTEX){\
    extern volatile void * volatile pxCurrentTCB; \
    vTraceSetObjectState(TraceObjectClassTable[pxQueue->ucQueueType], (objectHandleType)pxQueue->ucQueueNumber, (objectHandleType)uxTaskGetTaskNumber((xTaskHandle)pxCurrentTCB)); /*For mutex, store the new owner rather than queue length */ \
  }else{\
    vTraceSetObjectState(TraceObjectClassTable[pxQueue->ucQueueType], (objectHandleType)pxQueue->ucQueueNumber, (uint8_t)(pxQueue->uxMessagesWaiting - 1)); \
  }

%else
#define traceQUEUE_RECEIVE_ID                                    %>55 27
#define traceQUEUE_RECEIVE( pxQueue ) \
        traceQUEUE_RECEIVE_FUNC(traceQUEUE_RECEIVE_ID,pxQueue)
void traceQUEUE_RECEIVE_FUNC(uint8_t id, void* Queue);

%endif
%endif
%- --------------------------------------------------------------------------
%if %QueueReceiveFailed = 'yes'
%if %PercipioTraceEnabled='yes'
%- #undef traceQUEUE_RECEIVE_FAILED
#define traceQUEUE_RECEIVE_FAILED( pxQueue ) \
  portENTER_CRITICAL(); \
  vTraceStoreKernelCall((uint32_t)(EVENTGROUP_FAILED_RECEIVE + TraceObjectClassTable[pxQueue->ucQueueType]),  pxQueue->ucQueueNumber); \
  portEXIT_CRITICAL();

%else
#define traceQUEUE_RECEIVE_FAILED_ID                             %>55 28
#define traceQUEUE_RECEIVE_FAILED( pxQueue ) \
        traceQUEUE_RECEIVE_FAILED_FUNC(traceQUEUE_RECEIVE_FAILED_ID, pxQueue )
void traceQUEUE_RECEIVE_FAILED_FUNC(uint8_t id, void* Queue );

%endif
%endif
%- --------------------------------------------------------------------------
%if %QueuePeek = 'yes'
%if %PercipioTraceEnabled='yes'
%- #undef traceQUEUE_PEEK
#define traceQUEUE_PEEK( pxQueue ) \
  vTraceStoreKernelCall((uint32_t)(EVENTGROUP_PEEK + TraceObjectClassTable[pxQueue->ucQueueType]), pxQueue->ucQueueNumber);

%else
#define traceQUEUE_PEEK_ID                                       %>55 29
#define traceQUEUE_PEEK( pxQueue ) \
        traceQUEUE_PEEK_FUNC(traceQUEUE_PEEK_ID, pxQueue )
void traceQUEUE_PEEK_FUNC(uint8_t id, void* Queue );

%endif
%endif
%- --------------------------------------------------------------------------
%if %QueueSendFromISR = 'yes'
%if %PercipioTraceEnabled='yes'
%- #undef traceQUEUE_SEND_FROM_ISR
#define traceQUEUE_SEND_FROM_ISR( pxQueue ) \
  vTraceStoreKernelCall((uint32_t)(EVENTGROUP_SEND_FROM_ISR + TraceObjectClassTable[pxQueue->ucQueueType]), pxQueue->ucQueueNumber); \
  vTraceSetObjectState(TRACE_CLASS_QUEUE, (objectHandleType)pxQueue->ucQueueNumber, (uint8_t)(pxQueue->uxMessagesWaiting + 1));

%else
#define traceQUEUE_SEND_FROM_ISR_ID                              %>55 30
#define traceQUEUE_SEND_FROM_ISR( pxQueue ) \
        traceQUEUE_SEND_FROM_ISR_FUNC(traceQUEUE_SEND_FROM_ISR_ID, pxQueue )
void traceQUEUE_SEND_FROM_ISR_FUNC(uint8_t id, void* Queue );

%endif
%endif
%- --------------------------------------------------------------------------
%if %QueueReceiveFromISR = 'yes'
%if %PercipioTraceEnabled='yes'
%- #undef traceQUEUE_RECEIVE_FROM_ISR
#define traceQUEUE_RECEIVE_FROM_ISR( pxQueue )  \
  vTraceStoreKernelCall((uint32_t)(EVENTGROUP_RECEIVE_FROM_ISR + TraceObjectClassTable[pxQueue->ucQueueType]), pxQueue->ucQueueNumber); \
  vTraceSetObjectState(TRACE_CLASS_QUEUE, (objectHandleType)pxQueue->ucQueueNumber, (uint8_t)(pxQueue->uxMessagesWaiting - 1));

%else
#define traceQUEUE_RECEIVE_FROM_ISR_ID                           %>55 31
#define traceQUEUE_RECEIVE_FROM_ISR( pxQueue ) \
        traceQUEUE_RECEIVE_FROM_ISR_FUNC(traceQUEUE_RECEIVE_FROM_ISR_ID, pxQueue )
void traceQUEUE_RECEIVE_FROM_ISR_FUNC(uint8_t id, void* Queue );

%endif
%endif
%- --------------------------------------------------------------------------
%if %QueueSendFromISRFailed = 'yes'
%if %PercipioTraceEnabled='yes'
%- #undef traceQUEUE_SEND_FROM_ISR_FAILED
#define traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue ) \
  vTraceStoreKernelCall((uint32_t)(EVENTGROUP_FAILED_SEND_FROM_ISR + TraceObjectClassTable[pxQueue->ucQueueType]), pxQueue->ucQueueNumber);

%else
#define traceQUEUE_SEND_FROM_ISR_FAILED_ID                       %>55 32
#define traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue ) \
        traceQUEUE_SEND_FROM_ISR_FAILED_FUNC(traceQUEUE_SEND_FROM_ISR_FAILED_ID, pxQueue )
void traceQUEUE_SEND_FROM_ISR_FAILED_FUNC(uint8_t id, void* Queue );

%endif
%endif
%- --------------------------------------------------------------------------
%if %QueueReceiveFromISRFailed= 'yes'
%if %PercipioTraceEnabled='yes'
%- #undef traceQUEUE_RECEIVE_FROM_ISR_FAILED
#define traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue ) \
  vTraceStoreKernelCall((uint32_t)(EVENTGROUP_FAILED_RECEIVE_FROM_ISR + TraceObjectClassTable[pxQueue->ucQueueType]), pxQueue->ucQueueNumber);

%else
#define traceQUEUE_RECEIVE_FROM_ISR_FAILED_ID                    %>55 33
#define traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue ) \
        traceQUEUE_RECEIVE_FROM_ISR_FAILED_FUNC(traceQUEUE_RECEIVE_FROM_ISR_FAILED_ID, pxQueue )
void traceQUEUE_RECEIVE_FROM_ISR_FAILED_FUNC(uint8_t id, void* Queue );

%endif
%endif
%- --------------------------------------------------------------------------
%if %QueueDelete = 'yes'
%if %PercipioTraceEnabled='yes'
#if (INCLUDE_OBJECT_DELETE == 1)
%- #undef traceQUEUE_DELETE
#define traceQUEUE_DELETE( pxQueue ) \
{ \
  portENTER_CRITICAL();\
  vTraceStoreKernelCall(EVENTGROUP_DELETE + TraceObjectClassTable[pxQueue->ucQueueType], pxQueue->ucQueueNumber); \
  vTraceStoreObjectNameOnCloseEvent((objectHandleType)pxQueue->ucQueueNumber, TraceObjectClassTable[pxQueue->ucQueueType]); \
  vTraceStoreObjectPropertiesOnCloseEvent((objectHandleType)pxQueue->ucQueueNumber, TraceObjectClassTable[pxQueue->ucQueueType]); \
  if (TraceObjectClassTable[pxQueue->ucQueueType] == TRACE_CLASS_MUTEX){ \
    vTraceSetObjectState(TraceObjectClassTable[pxQueue->ucQueueType], (objectHandleType)pxQueue->ucQueueNumber, (objectHandleType)uxTaskGetTaskNumber((xTaskHandle)pxQueue->pxMutexHolder)); \
  }else{ \
    vTraceSetObjectState(TraceObjectClassTable[pxQueue->ucQueueType], (objectHandleType)pxQueue->ucQueueNumber, (uint8_t)uxQueueMessagesWaiting(pxQueue)); \
  } \
  vTraceFreeObjectHandle(TraceObjectClassTable[pxQueue->ucQueueType], (objectHandleType)pxQueue->ucQueueNumber); \
  portEXIT_CRITICAL();\
}
#endif

%else
#define traceQUEUE_DELETE_ID                                     %>55 34
#define traceQUEUE_DELETE( pxQueue ) \
        traceQUEUE_DELETE_FUNC(traceQUEUE_DELETE_ID, pxQueue )
void traceQUEUE_DELETE_FUNC(uint8_t id, void* Queue );

%endif
%endif
%- --------------------------------------------------------------------------
%if %TaskCreate = 'yes'
%if %PercipioTraceEnabled='yes'
%- #undef traceTASK_CREATE
#define traceTASK_CREATE( pxNewTCB ) \
  if (pxNewTCB != NULL){ \
    pxNewTCB->uxTaskNumber = xTraceGetObjectHandle(TRACE_CLASS_TASK); \
    vTraceSetObjectName(TRACE_CLASS_TASK, (objectHandleType)pxNewTCB->uxTaskNumber, (char*)pxNewTCB->pcTaskName); \
    vTraceSetPriorityProperty(TRACE_CLASS_TASK, (objectHandleType)pxNewTCB->uxTaskNumber, (uint8_t)pxNewTCB->uxPriority); \
    vTraceStoreKernelCall((uint32_t)(EVENTGROUP_CREATE + TRACE_CLASS_TASK), (objectHandleType)pxNewTCB->uxTaskNumber);\
  }

%else
#define traceTASK_CREATE_ID                                      %>55 35
#define traceTASK_CREATE( pxNewTCB ) \
        traceTASK_CREATE_FUNC(traceTASK_CREATE_ID, pxNewTCB->pcTaskName, pxNewTCB->uxTCBNumber)
void traceTASK_CREATE_FUNC(uint8_t id, int8_t TaskName[], uint8_t TaskNr);

%endif
%endif
%- --------------------------------------------------------------------------
%if %TaskCreateFailed = 'yes'
%if %PercipioTraceEnabled='yes'
%- #undef traceTASK_CREATE_FAILED
#define traceTASK_CREATE_FAILED() \
  portENTER_CRITICAL();\
  vTraceStoreKernelCall((uint32_t)(EVENTGROUP_FAILED_CREATE + TRACE_CLASS_TASK), 0); \
  portEXIT_CRITICAL();

%else
#define traceTASK_CREATE_FAILED_ID                               %>55 36
#define traceTASK_CREATE_FAILED() \
        traceTASK_CREATE_FAILED_FUNC(traceTASK_CREATE_FAILED_ID, pxCurrentTCB->uxTCBNumber)
void traceTASK_CREATE_FAILED_FUNC(uint8_t id, uint8_t TaskNr);

%endif
%endif
%- --------------------------------------------------------------------------
%if %TaskDelete = 'yes'
#if INCLUDE_vTaskDelete
%if %PercipioTraceEnabled='yes'
%- #undef traceTASK_DELETE
#define traceTASK_DELETE( pxTaskToDelete ) \
  vTraceStoreKernelCall(EVENTGROUP_DELETE + TRACE_CLASS_TASK, pxTaskToDelete->uxTaskNumber); \
  vTraceStoreObjectNameOnCloseEvent((objectHandleType)pxTaskToDelete->uxTaskNumber, TRACE_CLASS_TASK); \
  vTraceStoreObjectPropertiesOnCloseEvent((objectHandleType)pxTaskToDelete->uxTaskNumber, TRACE_CLASS_TASK); \
  vTraceSetPriorityProperty(TRACE_CLASS_TASK, (objectHandleType)pxTaskToDelete->uxTaskNumber, (uint8_t)pxTaskToDelete->uxPriority); \
  vTraceSetObjectState(TRACE_CLASS_TASK, (objectHandleType)pxTaskToDelete->uxTaskNumber, TASK_STATE_INSTANCE_NOT_ACTIVE); \
  vTraceFreeObjectHandle(TRACE_CLASS_TASK, (objectHandleType)pxTaskToDelete->uxTaskNumber);

%else
#define traceTASK_DELETE_ID                                      %>55 37
#define traceTASK_DELETE( pxTaskToDelete ) \
       traceTASK_DELETE_FUNC(traceTASK_DELETE_ID, pxTaskToDelete->uxTCBNumber )
void traceTASK_DELETE_FUNC(uint8_t id, uint8_t TaskNr );

%endif
#endif
%endif
%- --------------------------------------------------------------------------
%if %TaskDelayUntil = 'yes'
%if %PercipioTraceEnabled='yes'
%- #undef traceTASK_DELAY_UNTIL
#define traceTASK_DELAY_UNTIL() \
  portENTER_CRITICAL(); \
  vTraceStoreKernelCallWithNumericParamOnly(TASK_DELAY_UNTIL, (uint16_t)xTimeToWake); \
  vTraceSetTaskInstanceFinished((uint8_t)pxCurrentTCB->uxTaskNumber); \
  portEXIT_CRITICAL();

%else
#define traceTASK_DELAY_UNTIL_ID                                 %>55 38
#define traceTASK_DELAY_UNTIL() \
        traceTASK_DELAY_UNTIL_FUNC(traceTASK_DELAY_UNTIL_ID, pxCurrentTCB->uxTCBNumber)
void traceTASK_DELAY_UNTIL_FUNC(uint8_t id, uint8_t TaskNr);

%endif
%endif
%if %TaskDelay = 'yes'
%- --------------------------------------------------------------------------
%if %PercipioTraceEnabled='yes'
%- #undef traceTASK_DELAY
#define traceTASK_DELAY() \
  portENTER_CRITICAL(); \
  vTraceStoreKernelCallWithNumericParamOnly(TASK_DELAY, (uint16_t)xTicksToDelay);\
  vTraceSetTaskInstanceFinished((uint8_t)pxCurrentTCB->uxTaskNumber);\
  portEXIT_CRITICAL();

%else
#define traceTASK_DELAY_ID                                       %>55 39
#define traceTASK_DELAY() \
        traceTASK_DELAY_FUNC(traceTASK_DELAY_ID, pxCurrentTCB->uxTCBNumber)
void traceTASK_DELAY_FUNC(uint8_t id, uint8_t TaskNr);

%endif
%endif
%- --------------------------------------------------------------------------
%if %TaskPrioritySet = 'yes'
%if %PercipioTraceEnabled='yes'
%- #undef traceTASK_PRIORITY_SET
#define traceTASK_PRIORITY_SET( pxTask, uxNewPriority ) \
  vTraceStoreKernelCallWithParam(TASK_PRIORITY_SET, pxTask->uxTaskNumber, uiTraceGetPriorityProperty(TRACE_CLASS_TASK, (uint8_t)pxTask->uxTaskNumber));\
  vTraceSetPriorityProperty( TRACE_CLASS_TASK, (uint8_t)pxTask->uxTaskNumber, (uint8_t)uxNewPriority);

%else
#define traceTASK_PRIORITY_SET_ID                                %>55 40
#define traceTASK_PRIORITY_SET( pxTask, uxNewPriority ) \
        traceTASK_PRIORITY_SET_FUNC(traceTASK_PRIORITY_SET_ID, pxTask, uxNewPriority, pxCurrentTCB->uxTCBNumber)
void traceTASK_PRIORITY_SET_FUNC(uint8_t id, void* Task, uint8_t NewPriority, uint8_t TaskNr);

%endif
%endif
%- --------------------------------------------------------------------------
%if %TaskSuspend = 'yes'
%if %PercipioTraceEnabled='yes'
%- #undef traceTASK_SUSPEND
#define traceTASK_SUSPEND( pxTaskToSuspend ) \
  vTraceStoreKernelCall(TASK_SUSPEND, pxTaskToSuspend->uxTaskNumber); \
  vTraceSetTaskInstanceFinished((uint8_t)pxTaskToSuspend->uxTaskNumber);

%else
#define traceTASK_SUSPEND_ID                                     %>55 41
#define traceTASK_SUSPEND( pxTaskToSuspend ) \
        traceTASK_SUSPEND_FUNC(traceTASK_SUSPEND_ID, pxTaskToSuspend->uxTCBNumber)
void traceTASK_SUSPEND_FUNC(uint8_t id, uint8_t TaskNr);

%endif
%endif
%- --------------------------------------------------------------------------
%if %TaskResume = 'yes'
%if %PercipioTraceEnabled='yes'
%- #undef traceTASK_RESUME
#define traceTASK_RESUME( pxTaskToResume ) \
  vTraceStoreKernelCall(TASK_RESUME, pxTaskToResume->uxTaskNumber);

%else
#define traceTASK_RESUME_ID                                      %>55 42
#define traceTASK_RESUME( pxTaskToResume ) \
        traceTASK_RESUME_FUNC(traceTASK_RESUME_ID, pxTaskToResume->uxTCBNumber)
void traceTASK_RESUME_FUNC(uint8_t id, uint8_t TaskNr);

%endif
%endif
%- --------------------------------------------------------------------------
%if %TaskResumeFromISR = 'yes'
%if %PercipioTraceEnabled='yes'
%- #undef traceTASK_RESUME_FROM_ISR
#define traceTASK_RESUME_FROM_ISR( pxTaskToResume ) \
  vTraceStoreKernelCall(TASK_RESUME_FROM_ISR, pxTaskToResume->uxTaskNumber);

%else
#define traceTASK_RESUME_FROM_ISR_ID                             %>55 43
#define traceTASK_RESUME_FROM_ISR( pxTaskToResume ) \
        traceTASK_RESUME_FROM_ISR_FUNC(traceTASK_RESUME_FROM_ISR_ID, pxTaskToResume->uxTCBNumber)
void traceTASK_RESUME_FROM_ISR_FUNC(uint8_t id, uint8_t TaskNr);

%endif
%endif
%- --------------------------------------------------------------------------
%if %TaskPriorityInherit = 'yes'
%if %PercipioTraceEnabled='yes'
%- #undef traceTASK_PRIORITY_INHERIT
#define traceTASK_PRIORITY_INHERIT( pxTask, uxNewPriority ) \
  vTraceStoreKernelCallWithParam(TASK_PRIORITY_INHERIT, pxTask->uxTaskNumber, uiTraceGetPriorityProperty(TRACE_CLASS_TASK, (uint8_t)pxTask->uxTaskNumber));\
  vTraceSetPriorityProperty( TRACE_CLASS_TASK, (uint8_t)pxTask->uxTaskNumber, (uint8_t)uxNewPriority );

%else
/* traceTASK_PRIORITY_INHERIT not implemented yet */

%endif
%endif
%- --------------------------------------------------------------------------
%if %TaskPriorityDisinherit = 'yes'
%if %PercipioTraceEnabled='yes'
%- #undef traceTASK_PRIORITY_DISINHERIT
#define traceTASK_PRIORITY_DISINHERIT( pxTask, uxNewPriority ) \
  vTraceStoreKernelCallWithParam(TASK_PRIORITY_DISINHERIT, pxTask->uxTaskNumber, uiTraceGetPriorityProperty(TRACE_CLASS_TASK, (uint8_t)pxTask->uxTaskNumber));\
  vTraceSetPriorityProperty( TRACE_CLASS_TASK, (uint8_t)pxTask->uxTaskNumber, (uint8_t)uxNewPriority );

%else
/* traceTASK_PRIORITY_DISINHERIT not implemented yet */

%endif
%endif
%-************************************************************************************************************
%else %- Language (& Compiler)
  %error^ This component is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-

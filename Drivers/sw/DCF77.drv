%-Driver generated by the Bean Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Bean Wizard
%- If you change these lines, Bean Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    18.11.2008
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%define! Description_ConsumeBit Consumes an bit coming from the DCF signal.
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\DCF77Settings.Inc
%define! Abstract Common\DCF77Abstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
typedef struct {
  byte hour, minute, second;
  byte day, month, year;
  byte weekday;
} DCF77_TimeInfo;

/* some useful definitions of bit numbers of the DCF77 signal */
#define %'ModuleName'%.BITNO_FIRST             0   /* first valid bit */
#define %'ModuleName'%.BITNO_START_INFO       20   /* this bit is always 1 */
#define %'ModuleName'%.BITNO_MINUTE           21   /* 7 bits, the minute bits start with this bit */
#define %'ModuleName'%.BITNO_PARITY_MINUTE    28   /* parity bit of minute information */
#define %'ModuleName'%.BITNO_HOUR             29   /* 6 bits, the hour bits start with this bit */
#define %'ModuleName'%.BITNO_PARITY_HOUR      35   /* parity bit of hour information */
#define %'ModuleName'%.BITNO_DAY              36   /* 6 bits, the day bits start with this bit */
#define %'ModuleName'%.BITNO_WEEKDAY          42   /* 3 bits, the week day bits start with this bit */
#define %'ModuleName'%.BITNO_MONTH            45   /* 5 bits, the month bits start with this bit */
#define %'ModuleName'%.BITNO_YEAR             50   /* 8 bits, the hour bits start with this bit */
#define %'ModuleName'%.BITNO_PARITY_DATE      58   /* parity bit of date information */
#define %'ModuleName'%.BITNO_LAST             58   /* last bit number */
#define %'ModuleName'%.BITNO_NONE            100   /* special artificial bit number (>60) passed to DCF771_OnBit() event in order to indicate that we are scanning bits, but do not have a stop condition yet. */
#define %'ModuleName'%.BITNO_START_DUAL_SCAN 101   /* special artificial bit number (>60) passed to DCF771_OnBit() event in order to indicate second round of scan. */

%ifdef OnFailure
/* %OnFailure() error codes */
#define %'ModuleName'%.FAILURE_START_INFO    %'ModuleName'%.BITNO_START_INFO     /* start information bit was not 1 */
#define %'ModuleName'%.FAILURE_PARITY_MINUTE %'ModuleName'%.BITNO_PARITY_MINUTE  /* parity error for minute information */
#define %'ModuleName'%.FAILURE_PARITY_HOUR   %'ModuleName'%.BITNO_PARITY_HOUR    /* parity error for hour information */
#define %'ModuleName'%.FAILURE_PARITY_DATE   %'ModuleName'%.BITNO_PARITY_DATE    /* parity error for date information */
#define %'ModuleName'%.FAILURE_DUAL_SCAN     200                        /* dual scan did not return same date/time */
%endif

%-BW_CUSTOM_USERTYPE_END

%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN Start
%ifdef Start
void %'ModuleName'%.%Start(void);
%include Common\DCF77Start.Inc

%endif %- Start
%-BW_METHOD_END Start
%-************************************************************************************************************
%-BW_METHOD_BEGIN Stop
%ifdef Stop
void %'ModuleName'%.%Stop(void);
%include Common\DCF77Stop.Inc

%endif %- Stop
%-BW_METHOD_END Stop
%-************************************************************************************************************
%-BW_METHOD_BEGIN IsPresent
%ifdef IsPresent
bool %'ModuleName'%.%IsPresent(void);
%define! RetVal
%include Common\DCF77IsPresent.Inc

%endif %- IsPresent
%-BW_METHOD_END IsPresent
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScanBit
%ifdef ScanBit
void %'ModuleName'%.%ScanBit(void);
%include Common\DCF77ScanBit.Inc

%endif %- ScanBit
%-BW_METHOD_END ScanBit
%-************************************************************************************************************
%-BW_METHOD_BEGIN IsScanning
%ifdef IsScanning
bool %'ModuleName'%.%IsScanning(void);
%define! RetVal
%include Common\DCF77IsScanning.Inc

%endif %- IsScanning
%-BW_METHOD_END IsScanning
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_METHOD_BEGIN OnFinish
%ifdef OnFinish
%INTERFACE OnFinish
void %OnFinish(DCF77_TimeInfo *time);
%define! Partime
%include Common\DCF77OnFinish.Inc

%endif %- OnFinish
%-BW_METHOD_END OnFinish
%-BW_METHOD_BEGIN OnBit
%ifdef OnBit
%INTERFACE OnBit
void %OnBit(bool bit, byte bitNumber);
%define! Parbit
%define! ParbitNumber
%include Common\DCF77OnBit.Inc

%endif %- OnBit
%-BW_METHOD_END OnBit
%-BW_METHOD_BEGIN OnFailure
%ifdef OnFailure
%INTERFACE OnFailure
void %OnFailure(byte reason);
%define! Parreason
%include Common\DCF77OnFailure.Inc

%endif %- OnFailure
%-BW_METHOD_END OnFailure
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\DCF77Settings.Inc
%define! Abstract Common\DCF77Abstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%-
/* Note: the HKW Electronik GmbH AA S DCF active antenna is having following characteristics:
    100 ms DCF signal:  min 70 ms and max 130 ms
    200 ms DCF signal:  min 170 ms and max 230 ms */
#define MIN_ZERO_PULSE_MS  70.0  /* 70 ms */
#define MIN_ONE_PULSE_MS  170.0  /* 170 ms */
#define MAX_ONE_PULSE_MS  230.0  /* 230 ms */

#define %'ModuleName'%.TIMER_SCAN_PERIOD_MS %TimerPeriod /* timer period used in periodic interrupt to scan signal. The value should be in the range 1..25 ms */
static DCF77_TimeInfo time; /* Struct holding the time scanned in */
%if %DualScan='yes'
static DCF77_TimeInfo prevTime; /* Previous time stamp. Used for error checking to verify that we receive two consecuitive time stamps */
%endif
static byte bitCounter = 0;  /* Counts the number of received bits Bits DCF77_BITNO_FIRST..DCF77_BITNO_LAST */
static word syncTime;        /* Number of times we are called from the timer interrupt. */
static struct { /* we are using bit fields in order to reduce the amount of RAM needed for the driver */
  byte enabled:1;   /* Flag to indicate if we are scanning the signal or not */
  byte started:1;   /* Flag to indicate that we have synchronized on a start signal */
%if %DualScan='yes'
  byte scanAgain:1; /* Flag to indicate if we are shall scan again after this scan time */
%endif
%if defined(OnFailure)
  byte checkbit; /* Flag to check the sequence of bits coming in. We use here a byte (instead of a single bit) as EXOR on bits may be expensive operations */
%endif
} status;

%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-UNLOCKED
/* Internal method prototypes */
%-INTERNAL_LOC_METHOD_BEG ConsumeBit
static void ConsumeBit(byte bit);
%-INTERNAL_LOC_METHOD_END ConsumeBit
%-

%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN Start
%ifdef Start
%include Common\DCF77Start.Inc
void %'ModuleName'%.%Start(void)
{
  /* reset variables */
  status.enabled = 1; /* enable scanning from now on */
  status.started = 0; /* we do not have scanned a start signal yet */
  time.second = time.minute = time.hour = time.day = time.month = time.year = time.weekday = 0;
%if %DualScan='yes'
  status.scanAgain = 1; /* we are doing two scans */
%endif
}

%endif %- Start
%-BW_METHOD_END Start
%-************************************************************************************************************
%-BW_METHOD_BEGIN Stop
%ifdef Stop
%include Common\DCF77Stop.Inc
void %'ModuleName'%.%Stop(void)
{
  status.enabled = 0; /* disable scanning from now on */
}

%endif %- Stop
%-BW_METHOD_END Stop
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG ConsumeBit
%define! Parbit
%include Common\GeneralInternalGlobal.inc (ConsumeBit)
static void ConsumeBit(byte bit)
{
%if defined(OnBit)
  %OnBit(bit, bitCounter);
%endif
  switch(bitCounter) {
    /* scan minutes */
    case %'ModuleName'%.BITNO_MINUTE:
      time.minute = bit;
%if defined(OnFailure)
      status.checkbit = bit; /* start checksum sequence */
%endif
      break;
    case %'ModuleName'%.BITNO_MINUTE+1:
      time.minute += bit*2;
%if defined(OnFailure)
      status.checkbit ^= bit;
%endif
      break;
    case %'ModuleName'%.BITNO_MINUTE+2:
      time.minute += bit*4;
%if defined(OnFailure)
      status.checkbit ^= bit;
%endif
      break;
    case %'ModuleName'%.BITNO_MINUTE+3:
      time.minute += bit*8;
%if defined(OnFailure)
      status.checkbit ^= bit;
%endif
      break;
    case %'ModuleName'%.BITNO_MINUTE+4:
      time.minute += bit*10;
%if defined(OnFailure)
      status.checkbit ^= bit;
%endif
      break;
    case %'ModuleName'%.BITNO_MINUTE+5:
      time.minute += bit*20;
%if defined(OnFailure)
      status.checkbit ^= bit;
%endif
      break;
    case %'ModuleName'%.BITNO_MINUTE+6:
      time.minute += bit*40;
%if defined(OnFailure)
      status.checkbit ^= bit;
%endif
      break;
    /* scan hours */
    case %'ModuleName'%.BITNO_HOUR:
      time.hour = bit;
%if defined(OnFailure)
      status.checkbit ^= bit;
%endif
      break;
    case %'ModuleName'%.BITNO_HOUR+1:
      time.hour += bit*2;
%if defined(OnFailure)
      status.checkbit ^= bit;
%endif
      break;
    case %'ModuleName'%.BITNO_HOUR+2:
      time.hour += bit*4;
%if defined(OnFailure)
      status.checkbit ^= bit;
%endif
      break;
    case %'ModuleName'%.BITNO_HOUR+3:
      time.hour += bit*8;
%if defined(OnFailure)
      status.checkbit ^= bit;
%endif
      break;
    case %'ModuleName'%.BITNO_HOUR+4:
      time.hour += bit*10;
%if defined(OnFailure)
      status.checkbit ^= bit;
%endif
      break;
    case %'ModuleName'%.BITNO_HOUR+5:
      time.hour += bit*20;
%if defined(OnFailure)
      status.checkbit ^= bit;
%endif
      break;
    /* Scan day */
    case %'ModuleName'%.BITNO_DAY:
      time.day = bit;
%if defined(OnFailure)
      status.checkbit ^= bit;
%endif
      break;
    case %'ModuleName'%.BITNO_DAY+1:
      time.day += bit*2;
%if defined(OnFailure)
      status.checkbit ^= bit;
%endif
      break;
    case %'ModuleName'%.BITNO_DAY+2:
      time.day += bit*4;
%if defined(OnFailure)
      status.checkbit ^= bit;
%endif
      break;
    case %'ModuleName'%.BITNO_DAY+3:
      time.day += bit*8;
%if defined(OnFailure)
      status.checkbit ^= bit;
%endif
      break;
    case %'ModuleName'%.BITNO_DAY+4:
      time.day += bit*10;
%if defined(OnFailure)
      status.checkbit ^= bit;
%endif
      break;
    case %'ModuleName'%.BITNO_DAY+5:
      time.day += bit*20;
%if defined(OnFailure)
      status.checkbit ^= bit;
%endif
      break;
    /* Scan week day */
    case %'ModuleName'%.BITNO_WEEKDAY:
      time.weekday = bit;
%if defined(OnFailure)
      status.checkbit ^= bit;
%endif
      break;
    case %'ModuleName'%.BITNO_WEEKDAY+1:
      time.weekday += bit*2;
%if defined(OnFailure)
      status.checkbit ^= bit;
%endif
      break;
    case %'ModuleName'%.BITNO_WEEKDAY+2:
      time.weekday += bit*4;
%if defined(OnFailure)
      status.checkbit ^= bit;
%endif
      break;
    /* Scan month */
    case %'ModuleName'%.BITNO_MONTH:
      time.month = bit;
%if defined(OnFailure)
      status.checkbit ^= bit;
%endif
      break;
    case %'ModuleName'%.BITNO_MONTH+1:
      time.month += bit*2;
%if defined(OnFailure)
      status.checkbit ^= bit;
%endif
      break;
    case %'ModuleName'%.BITNO_MONTH+2:
      time.month += bit*4;
%if defined(OnFailure)
      status.checkbit ^= bit;
%endif
      break;
    case %'ModuleName'%.BITNO_MONTH+3:
      time.month += bit*8;
%if defined(OnFailure)
      status.checkbit ^= bit;
%endif
      break;
    case %'ModuleName'%.BITNO_MONTH+4:
      time.month += bit*10;
%if defined(OnFailure)
      status.checkbit ^= bit;
%endif
      break;
    /* Scan year */
    case %'ModuleName'%.BITNO_YEAR:
      time.year = bit;
%if defined(OnFailure)
      status.checkbit ^= bit;
%endif
      break;
    case %'ModuleName'%.BITNO_YEAR+1:
      time.year += bit*2;
%if defined(OnFailure)
      status.checkbit ^= bit;
%endif
      break;
    case %'ModuleName'%.BITNO_YEAR+2:
      time.year += bit*4;
%if defined(OnFailure)
      status.checkbit ^= bit;
%endif
      break;
    case %'ModuleName'%.BITNO_YEAR+3:
      time.year += bit*8;
%if defined(OnFailure)
      status.checkbit ^= bit;
%endif
      break;
    case %'ModuleName'%.BITNO_YEAR+4:
      time.year += bit*10;
%if defined(OnFailure)
      status.checkbit ^= bit;
%endif
      break;
    case %'ModuleName'%.BITNO_YEAR+5:
      time.year += bit*20;
%if defined(OnFailure)
      status.checkbit ^= bit;
%endif
      break;
    case %'ModuleName'%.BITNO_YEAR+6:
      time.year += bit*40;
%if defined(OnFailure)
      status.checkbit ^= bit;
%endif
      break;
    case %'ModuleName'%.BITNO_YEAR+7:
      time.year += bit*80;
%if defined(OnFailure)
      status.checkbit ^= bit;
%endif
      break;
%if defined(OnFailure)
    case %'ModuleName'%.BITNO_START_INFO: /* this bit shall always be 1 */
      if (bit != 1) { /* bit always has to be one! */
        %OnFailure(bitCounter); /* call failure event: user may call %'ModuleName'%.%Start() again.  */
        return;
      }
      break;
    case %'ModuleName'%.BITNO_PARITY_MINUTE:
    case %'ModuleName'%.BITNO_PARITY_HOUR:
    case %'ModuleName'%.BITNO_PARITY_DATE:
      status.checkbit ^= bit;
      if(status.checkbit) {
        %OnFailure(bitCounter); /* call failure event: user may call %'ModuleName'%.%Start() again.  */
        return;
      }
      break;
%endif
  }  /* switch */
  if (bitCounter==%'ModuleName'%.BITNO_LAST) { /* with parity check we scan until bit 58 (last bit) */
    if (  syncTime >= (word)(58000.0/%'ModuleName'%.TIMER_SCAN_PERIOD_MS)
       && syncTime <= (word)(61000.0/%'ModuleName'%.TIMER_SCAN_PERIOD_MS)
     )
    { /* check for the time we have scanned, if it is in the boundary */
      /* the DCF-77 signal is for the NEXT minute, so need to reflect this (subtract one minute) */
      time.second = 59; /* just have passed second 58 */
%if %DualScan='yes'
      if (status.scanAgain) { /* scan again the time stamp. It shall only differ by one minute. */
        prevTime = time; /* struct copy to save current time. Well, the 'current' time here is the time for the next minute/scan as we did not subtract one minute yet (below). */
        status.scanAgain = 0;
        status.started = 0; /* start scanning again */
%if defined(OnBit)
        %OnBit(0, %'ModuleName'%.BITNO_START_DUAL_SCAN);
%endif
        return;
      }
%endif
      /* subtract one minute as the DCF time signal is for the NEXT minute */
      time.minute--;
      if (time.minute == 0xff) { /* underflow */
        time.minute = 59;
        time.hour--;
        if (time.hour == 0xff) { /* underflow */
          time.hour = 23;
          time.day--;
          if (time.day == 0xff) { /* underflow: we are NOT handling this here, we simply restart scanning */
            %'ModuleName'%.%Start(); /* discard data and start over again */
            return;
          }
        }
      }
      /* now we have the real current time (this current minute) */
%if %DualScan='yes'
      if (!status.scanAgain) { /* second time stamp scan. now the time shall differ by one minute only */
        if (   time.day == prevTime.day
            && time.month == prevTime.month
            && time.year == prevTime.year
            && time.weekday == prevTime.weekday
            && time.hour == prevTime.hour
            && time.minute == prevTime.minute
           ) /* prevTime was NOT adjusted by the one minute offset, so we can compare on equality */
        {
          %'ModuleName'%.%Stop(); /* stop reception of the signal */
          %OnFinish(&time); /* call user event. This is done around the second 58! */
        } else {
%if defined(OnFailure)
          %OnFailure(%'ModuleName'%.FAILURE_DUAL_SCAN); /* call failure event: user may call %'ModuleName'%.%Start() again.  */
%endif
          %'ModuleName'%.%Start(); /* discard data and start over again */
          return;
        }
      }
%else
      %'ModuleName'%.%Stop(); /* stop reception of the signal */
  %if defined(OnFinish)
      %OnFinish(&time); /* call user event. This is done around the second 58! */
  %endif
%endif
      return;
    }
    %'ModuleName'%.%Start(); /* discard data and start over again */
  } else {
    bitCounter++; /* continue to scan the bits */
  }
}
%-INTERNAL_METHOD_END ConsumeBit
%-************************************************************************************************************
%-BW_METHOD_BEGIN IsPresent
%ifdef IsPresent
%define! RetVal
%include Common\DCF77IsPresent.Inc
bool %'ModuleName'%.%IsPresent(void)
{
  byte i = (byte)MAX_ONE_PULSE_MS/10; /* wait at maximum ~200 ms (depending on receiver), as the longest signal will be 200 ms */

  while(i>0) {
    if (!%@InputPin@'ModuleName'%.GetVal()) { /* low signal detected */
      return TRUE; /* we have a signal and as such there is a receiver */
    }
    %@Wait@'ModuleName'%.Waitms(10);
    i--;
  }
  return FALSE; /* no receiver attached */
}

%endif %- IsPresent
%-BW_METHOD_END IsPresent
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScanBit
%ifdef ScanBit
%include Common\DCF77ScanBit.Inc
void %'ModuleName'%.%ScanBit(void)
{
  static word pulse = 0; /* used to measure the width of a pulse */

  if (!status.enabled) {
    return; /* %'ModuleName'%.Start() have not been called yet, do nothing */
  }
  if (!status.started) { /* no startsignal yet: wait for the 2 second pause */
    if(!%@InputPin@'ModuleName'%.GetVal()) { /* have low high signal */
      pulse++;
      %if defined(OnBit)
      %OnBit(0, DCF77_BITNO_NONE); /* indicator for signal we get */
      %endif
      if(pulse > (word)(1500/%'ModuleName'%.TIMER_SCAN_PERIOD_MS)) { /* 2 second pause: start! */
        status.started = 1; /* start signal detected */
        bitCounter = 0; /* start counting the bits */
        syncTime = 0; /* start counting the time */
        pulse = 0; /* set back to zero for the scanning phase */
      }
    } else {
      %if defined(OnBit)
      %OnBit(1, DCF77_BITNO_NONE); /* indicator for signal we get */
      %endif
      pulse = 0; /* continue to wait for a low signal */
    }
  } else {
    syncTime++;
    if(%@InputPin@'ModuleName'%.GetVal()) {
      pulse++;
    } else {
      if(pulse > (word)(MIN_ZERO_PULSE_MS/%'ModuleName'%.TIMER_SCAN_PERIOD_MS)) { /* 100 ms or 200 ms signal detected */
        if(pulse > (word)(MIN_ONE_PULSE_MS/%'ModuleName'%.TIMER_SCAN_PERIOD_MS)) { /* 200 ms signal detected */
          ConsumeBit(1); /* 200 ms signal is a logical 1 */
        } else {
          ConsumeBit(0); /* 100 ms signal is a logical 1 */
        }
        pulse = 0;
      }
    }
  }
}

%endif %- ScanBit
%-BW_METHOD_END ScanBit
%-************************************************************************************************************
%-BW_METHOD_BEGIN IsScanning
%ifdef IsScanning
%define! RetVal
%include Common\DCF77IsScanning.Inc
bool %'ModuleName'%.%IsScanning(void)
{
  return status.enabled; /* true if we are scanning the signal */
}

%endif %- IsScanning
%-BW_METHOD_END IsScanning
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_METHOD_BEGIN OnFinish
%ifdef OnFinish
%IMPLEMENTATION OnFinish
%define! Partime
%include Common\DCF77OnFinish.Inc
void %OnFinish(DCF77_TimeInfo *time)
{
  /* Write your code here ... */
}

%endif %- OnFinish
%-BW_METHOD_END OnFinish
%-BW_METHOD_BEGIN OnBit
%ifdef OnBit
%IMPLEMENTATION OnBit
%define! Parbit
%define! ParbitNumber
%include Common\DCF77OnBit.Inc
void %OnBit(bool bit, byte bitNumber)
{
  /* Write your code here ... */
#if 0 /* some example code how this could look like.... */
  if (bitNumber == DCF77_BITNO_NONE) { /* we do not have a valid stop condition yet */
    LED0_Put(bit); /* simply indicate that we are getting some signals */
    return;
  } else if (bitNumber == DCF77_BITNO_FIRST) { /* ah, now we have a stop condition detected and we are starting counting bits... */
    /* indicate that we have started... */
  } else if (bitNumber >= DCF77_BITNO_MINUTE && bitNumber <= DCF77_BITNO_LAST) { /* we are scanning the time and date information */
    LED0_Neg(); /* blink ever second to indicate that we are getting data */
    LED1_Neg();
  }
#endif
}

%endif %- OnBit
%-BW_METHOD_END OnBit
%-BW_METHOD_BEGIN OnFailure
%ifdef OnFailure
%IMPLEMENTATION OnFailure
%define! Parreason
%include Common\DCF77OnFailure.Inc
void %OnFailure(byte reason)
{
  /* Write your code here ... */
#if 0 /* example code */
  %'ModuleName'%.%Start(); /* on failure try to scan again */
#endif
}

%endif %- OnFailure
%-BW_METHOD_END OnFailure
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
  /* Write code here ... */
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This bean is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-

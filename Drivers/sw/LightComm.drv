%-Driver generated by the Bean Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Bean Wizard
%- If you change these lines, Bean Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    26.06.2008
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%define! Description_SyncOnBit This method waits until it founds a falling edge, followed by a quite period for one MARK duration.
%define! Description_PutOne 
%define! Description_PutZero 
%define! Description_Communicate Used to send and receive data.
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\LightCommSettings.Inc
%define! Abstract Common\LightCommAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"
#include <stddef.h> /* for NULL */
%include sw\CommonSupport.prg
%-
%define INLINE_ME
%-
%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

#ifndef __BWUserType_%'ModuleName'_tTxRxDesc
#define __BWUserType_%'ModuleName'_tTxRxDesc
  typedef struct {                                               %>40/* structure describing receiving and sending packets. */
    byte nofBytes;                                               %>40/* Number of bytes of data. */
    byte* data;                                                  %>40/* Pointer to the data itself. */
  } %'ModuleName'_tTxRxDesc;
#endif

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
#define %'ModuleName'%.STATUS_NONE               0               %>40/* initial state */
#define %'ModuleName'%.STATUS_IDLE               1               %>40/* entering idle phase */
#define %'ModuleName'%.STATUS_IDLE_BIT           2               %>40/* sending idle bits */
#define %'ModuleName'%.STATUS_TXRX               3               %>40/* entering Tx/Rx phase */
#define %'ModuleName'%.STATUS_POST_IDLE_BIT      4               %>40/* after we have done tx, we optionally idle for a while */
#define %'ModuleName'%.STATUS_RX_START           5               %>40/* start bit received */
#define %'ModuleName'%.STATUS_RX_STOP            6               %>40/* stop bit received */
#define %'ModuleName'%.STATUS_RX_BIT_1           7               %>40/* 1 bit received */
#define %'ModuleName'%.STATUS_RX_BIT_0           8               %>40/* 0 bit received */
#define %'ModuleName'%.STATUS_TX_START           9               %>40/* start bit sent */
#define %'ModuleName'%.STATUS_TX_STOP           10               %>40/* stop bit sent */
#define %'ModuleName'%.STATUS_TX_BIT_1          11               %>40/* 1 bit sent */
#define %'ModuleName'%.STATUS_TX_BIT_0          12               %>40/* 0 bit sent */
#define %'ModuleName'%.STATUS_ERROR_RX_BIT      13               %>40/* error receiving bit (cannot determine if zero or one) */
#define %'ModuleName'%.STATUS_ERROR_RX_STOP     14               %>40/* error receiving bit stop bit (was not a one) */
#define %'ModuleName'%.STATUS_ERROR_OVERFLOW    15               %>40/* error receiving data bytes: not enough space in rx buffer */

%-BW_CUSTOM_USERTYPE_END


%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN EnableRequest
%ifdef EnableRequest
byte %'ModuleName'%.%EnableRequest(%'ModuleName'_tTxRxDesc *tx, %'ModuleName'_tTxRxDesc *rx, byte nofAttempts);
%define! Partx
%define! Parrx
%define! ParnofAttempts
%define! RetVal
%include Common\LightCommEnableRequest.Inc

%endif %- EnableRequest
%-BW_METHOD_END EnableRequest
%-************************************************************************************************************
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_METHOD_BEGIN OnRxByte
%ifdef OnRxByte
%INTERFACE OnRxByte
void %OnRxByte(byte data);
%define! Pardata
%include Common\LightCommOnRxByte.Inc

%endif %- OnRxByte
%-BW_METHOD_END OnRxByte
%-BW_METHOD_BEGIN OnStatus
%ifdef OnStatus
%INTERFACE OnStatus
void %OnStatus(byte status);
%define! Parstatus
%include Common\LightCommOnStatus.Inc

%endif %- OnStatus
%-BW_METHOD_END OnStatus
%-BW_METHOD_BEGIN OnTxByte
%ifdef OnTxByte
%INTERFACE OnTxByte
void %OnTxByte(byte data);
%define! Pardata
%include Common\LightCommOnTxByte.Inc

%endif %- OnTxByte
%-BW_METHOD_END OnTxByte
%-BW_METHOD_BEGIN OnData
%ifdef OnData
%INTERFACE OnData
void %OnData(%'ModuleName'_tTxRxDesc *data);
%define! Pardata
%include Common\LightCommOnData.Inc

%endif %- OnData
%-BW_METHOD_END OnData
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\LightCommSettings.Inc
%define! Abstract Common\LightCommAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
/*
  Communication scheme
  ====================

  IDLE Phase
   send a MARK (sending light-on for 10 measuring periods)
   followed by a 40 light-off periods.
                      ----                     ----
  ____ ____ ____ ____ |  | ____ ____ ____ ____ |  | ____ ....

  If we see for 2 measuring periods in a row light-on followed by 10 measuring periods a light-off,
  we go into the SYNC phase:

  SYNC phase:
   Each device tries to 'attach' after a MARK phase of the other device.
   If they are in sync then they send a MARK followed by not-light on period of 3 MARK duration
            ----                ----
A ____ ____ |  | ____ ____ ____ |  | ____ ....

  ----                ----                ----
B |  | ____ ____ ____ |  | ____ ____ ____ |  | ....

  TRANS phase:
  In order to transmit a bit, the MARK block is used to send a bit (MARK lenght for a 1, SPACE=MARK/2 for 0.
  During the middle of the 'low' phase a device is reading (rrrr) the bits incoming.
  7 or less measurements of light on is recognized as 0 (SPACE), 8 or more are detected as a one (MARK).

            ----                 --
A rrrr ____ | 1| ____ rrrr ____ | 0| ____ ....

  ----                ----                ----
B | 1| ____ rrrr ____ | 1| ____ rrrr ____ | 1| ____ ....


Data transmission starts with a SPACE, followed by 8 data bits and a closing MARK bit.
*/
#define LIGHT_ON(x)  ((x)!=%@LED@'ModuleName'%.LIGHT_MASK)
#define LIGHT_OFF(x) ((x)==%@LED@'ModuleName'%.LIGHT_MASK)

#define DEBUG  0  /* data collection debug */

#if DEBUG
static byte dbgSyncOnBits[128];
static byte dbgSyncOnBitsIdx = 0;
static byte dbgOneZero[160];
static byte dbgOneZeroIdx = 0;
#endif

#define DISCHARGE_USE_MS (%@LED@'ModuleName'%.Threshold_us > 1000)
#if DISCHARGE_USE_MS
%if %UseUCOS='yes'
  #include <ucos_ii.h>
  #define WAIT(ms) (void)OSTimeDlyHMSM(0,0,0,ms)
%else
  #define WAIT(ms)  %@Wait@'ModuleName'%.Waitms(ms)
%endif
  /* use milliseconds */
#else
  #define WAIT(us)  %@Wait@'ModuleName'%.Waitus(us)
#endif



#if DISCHARGE_USE_MS
  #define DISCHARGE       (%@LED@'ModuleName'%.Threshold_us/1000)%>40/* minimal duration we can detect an on/off. lower value means more light is needed to get discharge to zero. */
#else
  #define DISCHARGE       (%@LED@'ModuleName'%.Threshold_us)     %>40/* minimal duration we can detect an on/off. lower value means more light is needed to get discharge to zero. */
#endif
#define PULSE_WIDTH     10                                       %>40/* Width of a '1' pulse */
#define LIGHT_SEEN_TIME DISCHARGE                                %>40/* time we need to see if light is seen or not */
#define MARK            (PULSE_WIDTH*DISCHARGE)                  %>40/* mark pulse */
#define IDLE            (4*MARK)                                 %>40/* idle phase, scanning for signal */
#define SPACE           (MARK/2)                                 %>40/* space bit (zero), MARK is a one */
#define MIN_BIT_0_COUNT  3                                       %>40/* we need to see at least 3..6 measurement with a light on to count it as a zero */
#define MAX_BIT_0_COUNT  6                                       %>40/* we need to see at least 3..6 measurement with a light on to count it as a zero */
#define MIN_BIT_1_COUNT  7                                       %>40/* we need to see at least 7..12 measurement with a light on to count it as a one */
#define MAX_BIT_1_COUNT 12                                       %>40/* maximum light counts for a one bit */

%-
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-UNLOCKED
/* Internal method prototypes */
%-INTERNAL_LOC_METHOD_BEG SyncOnBit
static bool SyncOnBit(bool *bit);
%-INTERNAL_LOC_METHOD_END SyncOnBit
%-INTERNAL_LOC_METHOD_BEG PutOne
static void PutOne(void);
%-INTERNAL_LOC_METHOD_END PutOne
%-INTERNAL_LOC_METHOD_BEG PutZero
static void PutZero(void);
%-INTERNAL_LOC_METHOD_END PutZero
%-INTERNAL_LOC_METHOD_BEG Communicate
static byte Communicate(%'ModuleName'_tTxRxDesc *tx, %'ModuleName'_tTxRxDesc *rx);
%-INTERNAL_LOC_METHOD_END Communicate
%-

%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG SyncOnBit
%define! Parbit
%define! RetVal
%include Common\GeneralInternalGlobal.inc (SyncOnBit)
static bool SyncOnBit(bool *bit)
{
  /* returns true if we have found a valid bit. The bit value is returned in the parameter. */
  byte cnt;                                                      %>40/* we will count up to 40*100us=4ms to detect a 1ms pulse */
  %@LED@'ModuleName'%.SensorValType light;                       %>40/* if we have seen the light or not */
  byte onCnt;                                                    %>40/* counter how many times we count a 'on' level */
  byte offCnt;                                                   %>40/* counter how many times we count an 'off' level after the 'on' sequence */
  byte phase;
  #define PHASE_INIT               0   /* start phase */
  #define PHASE_WAIT_RASING_EDGE   1   /* having low level, and waiting for a raising edge */
  #define PHASE_WAIT_FALLING_EDGE  2   /* on a high level/edge, counting the edge duration and waiting for the falling edge */
  #define PHASE_WAIT_MARK_LOW      3   /* had an edge, and counting zeros after the edge for a MARK period */

#if DEBUG
  dbgSyncOnBits[dbgSyncOnBitsIdx] = 0x33;                        %>40/* special marker */
  dbgSyncOnBitsIdx++;
  if (dbgSyncOnBitsIdx == sizeof(dbgSyncOnBits)) {               %>40/* circular buffer */
    dbgSyncOnBitsIdx = 0;
  }
#endif
  phase = PHASE_INIT;
  for(cnt=0;cnt<3*MARK;cnt++) {
    light = %@LED@'ModuleName'%.GetVal();                        %>40/* do we have a light or not? */
#if DEBUG
    dbgSyncOnBits[dbgSyncOnBitsIdx] = (bool)LIGHT_ON(light);
    dbgSyncOnBitsIdx++;
    if (dbgSyncOnBitsIdx == sizeof(dbgSyncOnBits)) {             %>40/* circular buffer */
      dbgSyncOnBitsIdx = 0;
    }
#endif
    if (phase==PHASE_INIT && LIGHT_OFF(light)) {                 %>40/* started scanning, and having a zero: wait for raising edge */
      phase = PHASE_WAIT_RASING_EDGE;                            %>40/* wait for a raising edge */
    } else if (phase==PHASE_WAIT_RASING_EDGE && LIGHT_ON(light)) {%>40/* have found a raising edge */
      phase = PHASE_WAIT_FALLING_EDGE;
      onCnt = 1;                                                 %>40/* counting high/on level */
    } else if (phase==PHASE_WAIT_FALLING_EDGE && LIGHT_ON(light)) {
      onCnt++;                                                   %>40/* counting high/on level */
    } else if (phase==PHASE_WAIT_FALLING_EDGE && LIGHT_OFF(light)) {
      phase = PHASE_WAIT_MARK_LOW;
      offCnt = 1;                                                %>40/* counting low/off level */
    } else if (phase==PHASE_WAIT_MARK_LOW && LIGHT_OFF(light)) {
      offCnt++;                                                  %>40/* counting low/off level */
      if (offCnt>=PULSE_WIDTH-1) {                               %>40/* have a low phase long enough after an edge */
        if (onCnt>=MIN_BIT_1_COUNT && onCnt<=MAX_BIT_1_COUNT) {
#if DEBUG
          dbgOneZero[dbgOneZeroIdx] = 1;
          dbgOneZeroIdx++;
          if (dbgOneZeroIdx == sizeof(dbgOneZero)) {             %>40/* circular buffer */
            dbgOneZeroIdx = 0;
          }
#endif
          *bit = TRUE; /* one bit */
          return TRUE;
        } else if (onCnt>=MIN_BIT_0_COUNT && onCnt<=MAX_BIT_0_COUNT) {
#if DEBUG
          dbgOneZero[dbgOneZeroIdx] = 0;
          dbgOneZeroIdx++;
          if (dbgOneZeroIdx == sizeof(dbgOneZero)) {             %>40/* circular buffer */
            dbgOneZeroIdx = 0;
          }
#endif
          *bit = FALSE;                                          %>40/* zero bit */
          return TRUE;
        } else {                                                 %>40/* illegal bit */
#if DEBUG
          dbgOneZero[dbgOneZeroIdx] = 0x8;
          dbgOneZeroIdx++;
          if (dbgOneZeroIdx == sizeof(dbgOneZero)) {             %>40/* circular buffer */
            dbgOneZeroIdx = 0;
          }
#endif
          return FALSE;
        }
      }
    } else if (phase==PHASE_WAIT_MARK_LOW && LIGHT_ON(light)) {  %>40/* waiting low period to complete, but got a one bit? */
      phase = PHASE_INIT;                                        %>40/* start scanning again */
    }
  } /* for */
#if DEBUG
  dbgOneZero[dbgOneZeroIdx] = 0xee;
  dbgOneZeroIdx++;
  if (dbgOneZeroIdx == sizeof(dbgOneZero)) {                     %>40/* circular buffer */
    dbgOneZeroIdx = 0;
  }
#endif
  return FALSE;
}

%-INTERNAL_METHOD_END SyncOnBit
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG PutOne
%include Common\GeneralInternalGlobal.inc (PutOne)
static void PutOne(void)
{
  %@LED@'ModuleName'%.On();                                      %>40/* turn on LEDs to start IDLE cycle with a MARK */
  WAIT((word)MARK);                                              %>40/* have light turned on for MARK */
  %@LED@'ModuleName'%.Off();                                     %>40/* turn off LED */
}

%-INTERNAL_METHOD_END PutOne
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG PutZero
%include Common\GeneralInternalGlobal.inc (PutZero)
static void PutZero(void)
{
  WAIT((word)SPACE);                                             %>40/* wait half of a MARK period (which is a SPACE period) */
  %@LED@'ModuleName'%.On();                                      %>40/* turn on LEDs to start IDLE cycle with a MARK */
  WAIT((word)SPACE);                                             %>40/* have light turned on for SPACE (0 bit) */
  %@LED@'ModuleName'%.Off();                                     %>40/* turn off LED */
}

%-INTERNAL_METHOD_END PutZero
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG Communicate
%define! Partx
%define! Parrx
%define! RetVal
%include Common\GeneralInternalGlobal.inc (Communicate)
static byte Communicate(%'ModuleName'_tTxRxDesc *tx, %'ModuleName'_tTxRxDesc *rx)
{
  #define TX_PRE_IDLE_COUNT  %TxStartMarks                       %>40/* send first some idle bits */
  #define TX_POST_IDLE_COUNT %TxEndMarks                         %>40/* after we are finished, send some idle bits in case communication partner has still something for us */
  #define TX_POST_OPT_IDLE   %TxEndIdleMarks                     %>40/* some optional idle counts to the end */
  #define NOF_COMM_ATTEMPTS  %NofCommAttempts                    %>40/* how many times we shall try to communicate */
  byte idleCnt;                                                  %>40/* counting down as long we have to send some idle bits */
  byte phase;                                                    %>40/* describes in which phase we are: IDLE or TXRX (which does SYNC as well) */
  byte txTmp;                                                    %>40/* temporary variable for receiving byte */
  byte txBitCnt;                                                 %>40/* counter for rx/tx bits */
  bool bit, gotBit;
  byte rxTmp, rxBitCnt;
  bool doTx;                                                     %>40/* if we have bytes to transmit */
  byte txDataIdx;                                                %>40/* index into tx->data[] */
  byte rxDataIdx;                                                %>40/* index into rx->data[] */
  byte res = ERR_OK;                                             %>40/* error return code */
  byte nofCommAttempts;                                          %>40/* counter for communication attempts */
  byte oneBitCount;                                              %>40/* counting the number of one bits we get in a row to have an exit criteria */
  byte errorBitCnt;                                              %>40/* number of errors (we were not able to detect a one or zero bit */

  phase = %'ModuleName'%.STATUS_IDLE;
  %ifdef OnStatus
  %OnStatus(phase);                                              %>40/* inform about new status */
  %endif
  phase = %'ModuleName'%.STATUS_IDLE;
  nofCommAttempts=0;
  for(;;) { /* breaks */
    while(phase==%'ModuleName'%.STATUS_IDLE) {                   %>40/* send out a mark and listen for 4*MARKs if there is someone out there */
      /* idle cycle: We send a MARK and then during 4 MARK periods we check if we have somebody sending (putting out a mark.
         If we see this twice in a row, we go to RX/TX phase */
      byte cnt, i;

      PutOne();                                                  %>40/* put out mark */
      cnt = 0;
      for(i=0;i<4*PULSE_WIDTH;i++) {                             %>40/* scan for 4*MARK */
        if(LIGHT_ON(%@LED@'ModuleName'%.GetVal())) {             %>40/* a zero bit means we have seen a light */
          cnt++;
        }
      } /* for */
      if (cnt>0 && cnt<=MAX_BIT_1_COUNT) {                       %>40/* have seen light in our listening period, and only one bit (or little bit more). Check again */
        PutOne();                                                %>40/* put out mark */
        cnt = 0;
        for(i=0;i<4*PULSE_WIDTH;i++) {                           %>40/* scan for 4*MARK */
          if(LIGHT_ON(%@LED@'ModuleName'%.GetVal())) {           %>40/* a zero bit means we have seen a light */
            cnt++;
          }
        } /* for */
        if (cnt>0 && cnt<=MAX_BIT_1_COUNT) {                     %>40/* twice we have seen something */
          phase = %'ModuleName'%.STATUS_TXRX;
          %ifdef OnStatus
          %OnStatus(phase);                                      %>40/* inform about new status */
          %endif
        }
      }
      nofCommAttempts++;
      if (nofCommAttempts>NOF_COMM_ATTEMPTS) {
        return ERR_NOTAVAIL;                                     %>40/* no communication partner available */
      }
    } /* while %'ModuleName'%.STATUS_IDLE */

    txBitCnt = 0; rxBitCnt = 0;                                  %>40/* reset tx/rx bit counters */
    txDataIdx = 0; rxDataIdx = 0;                                %>40/* reset rx/tx byte counters */
    errorBitCnt = 0;
    doTx = (bool)(tx!=NULL);                                     %>40/* only transmit if we have some data */
    oneBitCount = 0;                                             %>40/* start counting the one bits */
    if (doTx) {
      idleCnt = TX_PRE_IDLE_COUNT;
    } else {
      idleCnt = 0; /* no idle count needed for rx */
    }
    while (phase==%'ModuleName'%.STATUS_TXRX) {                  %>40/* synchronized now, can do tx and rx */
      /* TX phase */
      if (!doTx || idleCnt>0) {
        %ifdef OnStatus
        %OnStatus(%'ModuleName'%.STATUS_IDLE_BIT);
        %endif
        PutOne();                                                %>40/* put out idling mark */
        if (idleCnt>0) {
          idleCnt--;                                             %>40/* first send some idle bits for communication partner to synchronize */
        }
      } else if (doTx) {                                         %>40/* TX: we don't have to idle and we have something to send... */
        if (txBitCnt==0) {                                       %>40/* send start bit */
          PutZero();                                             %>40/* start bit */
          %ifdef OnStatus
          %OnStatus(%'ModuleName'%.STATUS_TX_START);             %>40/* inform about new status */
          %endif
          txTmp = tx->data[txDataIdx];
          txBitCnt++;                                            %>40/* count to next bit */
        } else if (txBitCnt==9) {                                %>40/* send stop bit after start bit followed by 8 data bits */
          PutOne();                                              %>40/* stop bit */
          %ifdef OnStatus
          %OnStatus(%'ModuleName'%.STATUS_TX_STOP);              %>40/* call user event */
          %endif
          %ifdef OnTxByte
          %OnTxByte(tx->data[txDataIdx]);                        %>40/* call user event */
          %endif
          txDataIdx++;                                           %>40/* next byte */
          if (txDataIdx == tx->nofBytes) {                       %>40/* have sent all bytes */
            doTx = FALSE;                                        %>40/* we are done */
            idleCnt = TX_POST_IDLE_COUNT;                        %>40/* send idle bits at the end, so partner knows we are done */
          }
          txBitCnt = 0;                                          %>40/* start bit counter again */
        } else {                                                 %>40/* send 8 data bits (MSB first) */
          if (txTmp&0x80) {                                      %>40/* what is the bit value? */
            PutOne();                                            %>40/* send a 1 bit */
            %ifdef OnStatus
            %OnStatus(%'ModuleName'%.STATUS_TX_BIT_1);
            %endif
          } else {
            PutZero();                                           %>40/* send a 0 bit */
            %ifdef OnStatus
            %OnStatus(%'ModuleName'%.STATUS_TX_BIT_0);
            %endif
          }
          txBitCnt++;                                            %>40/* count to next bit */
          txTmp <<= 1;                                           %>40/* shift to next bit */
        }
      }

      /* RX phase: scan incoming bits */
      gotBit = SyncOnBit(&bit);

      if (!gotBit) {                                             %>40/* unable to get bit value :-( */
        errorBitCnt++;
        if  (    (doTx && idleCnt==0)                            %>40/* we lost connection while sending */
              || rxBitCnt!=0                                     %>40/* we lost connection while receiving bits */
              || (!doTx && errorBitCnt>%NofCommAttempts)         %>40/* we are waiting for incoming bits, but unable to get them */
            )
        {
          %ifdef OnStatus
          %OnStatus(%'ModuleName'%.STATUS_ERROR_RX_BIT);         %>40/* inform about new status */
          %endif
          phase = %'ModuleName'%.STATUS_IDLE;                    %>40/* try to sync again */
          %ifdef OnStatus
          %OnStatus(phase);                                      %>40/* inform about new status */
          %endif
        }
      } /* !gotBit */
      /* start counting for termination condition: if we receive more than 10 one bits after received last byte */
      if (gotBit && bit && rxDataIdx>0) {                        %>40/* we have received something. Start counting ones */
        oneBitCount++;                                           %>40/* counting the idle one bits */
        if (oneBitCount > %TxEndMarks) {
          oneBitCount = %TxEndMarks;                             %>40/* cap value to avoid overflow */
        }
      } else {
        oneBitCount=0;                                           %>40/* counting the idle one bits */
      }
      if (gotBit) {                                              %>40/* have scanned either a zero or one */
        if (rxBitCnt==0 && bit) {                                %>40/* we do not have a start condition yet, and a one bit: this is an IDLE bit */
          /* nothing to do */
        } else if (rxBitCnt==0 && !bit) {                        %>40/* we do not have a start bit yet and now a zero bit: start bit! */
          rxBitCnt = 1;                                          %>40/* start counting and receiving bits */
          rxTmp = 0;
          %ifdef OnStatus
          %OnStatus(%'ModuleName'%.STATUS_RX_START);             %>40/* inform about new status */
          %endif
        } else if (rxBitCnt>0) {                                 %>40/* receiving data bits */
          if (rxBitCnt == 9) {                                   %>40/* this must be the stop bit */
            if (bit) {                                           %>40/* everything ok as the stop bit has to be a one bit */
              if (rx != NULL) {                                  %>40/* we are interested in the received bits */
                if (rxDataIdx < rx->nofBytes) {
                  rx->data[rxDataIdx++] = rxTmp;                 %>40/* store received byte */
                } else {                                         %>40/* to much data: we cannot handle it! */
                  %ifdef OnStatus
                  %OnStatus(%'ModuleName'%.STATUS_ERROR_OVERFLOW);%>40/* inform about new status */
                  %endif
                  res = ERR_OVERFLOW;                            %>40/* rx buffer not large enough to store the data */
                }
              }
              %ifdef OnStatus
              %OnStatus(%'ModuleName'%.STATUS_RX_STOP);          %>40/* inform about new status */
              %endif
              %ifdef OnRxByte
              %OnRxByte(rxTmp);                                  %>40/* call user event */
              %endif
            } else {                                             %>40/* error case: the stop bit shall be a one bit! */
              %ifdef OnStatus
              %OnStatus(%'ModuleName'%.STATUS_ERROR_RX_STOP);    %>40/* error: expected the stop bit (one bit), but received a zero bit! */
              %endif
              phase = %'ModuleName'%.STATUS_IDLE;                %>40/* try to sync again */
              %ifdef OnStatus
              %OnStatus(phase);                                  %>40/* inform about new status */
              %endif
            }
            rxBitCnt = 0;                                        %>40/* reset bit counter for next incoming byte */
          } else {                                               %>40/* data bits */
            rxTmp |= bit;
            %ifdef OnStatus
            %OnStatus((byte)(bit?%'ModuleName'%.STATUS_RX_BIT_1:%'ModuleName'%.STATUS_RX_BIT_0));%>40/* inform about new status */
            %endif
            if (rxBitCnt<=7) {                                   %>40/* not the last bit of the 8 data bits yet... */
              rxTmp <<= 1;                                       %>40/* shift for next bit */
            }
            rxBitCnt++;                                          %>40/* count receiving bits */
          }
        }
      } /* gotBit */
      WAIT((word)MARK);                                          %>40/* have light turned off for MARK period */

      /* check now if we are done */
      if ( (  (tx!=NULL && !doTx)                                %>40/* tx, and we finished sending data */
            ||(tx==NULL && rxDataIdx>0 && oneBitCount>=%TxEndMarks)%>40/* rx only, and we received enough post idle bits */
           )
          && idleCnt==0                                          %>40/* and we finished sending idle bits */
          && rxBitCnt==0                                         %>40/* and we are not currently receiving bits */
         )
      {                                                          %>40/* if we are not receiving bits and not have to do tailing idle bits, we could return. */
        %ifdef OnData
        if (rxDataIdx != 0 && rx != NULL) { /* we received data */
          %'ModuleName'_tTxRxDesc rxResult;                      %>40/* variable for the user event */

          rxResult.nofBytes = rxDataIdx;
          rxResult.data = rx->data;
          %OnData(&rxResult);                                    %>40/* call user event */
        }
        %endif
        if (tx!=NULL) {                                          %>40/* we had to send something */
          idleCnt = TX_POST_OPT_IDLE;
          phase = %'ModuleName'%.STATUS_POST_IDLE_BIT;
          %ifdef OnStatus
          %OnStatus(%'ModuleName'%.STATUS_POST_IDLE_BIT);        %>40/* inform about new status */
          %endif
        } else {
          phase = %'ModuleName'%.STATUS_NONE;
          %ifdef OnStatus
          %OnStatus(%'ModuleName'%.STATUS_NONE);                 %>40/* inform about new status */
          %endif
          return res;
        }
      }
    } /* while %'ModuleName'%.STATUS_TXRX */
    while (phase==%'ModuleName'%.STATUS_POST_IDLE_BIT) {         %>40/* synchronized now, can do tx and rx */
      %ifdef OnStatus
      %OnStatus(%'ModuleName'%.STATUS_IDLE_BIT);
      %endif
      PutOne();                                                  %>40/* put out idling mark */
      WAIT(3*(word)MARK);                                        %>40/* have light turned off 3 MARK period */
      if (idleCnt>0) {
        idleCnt--;                                               %>40/* first send some idle bits for communication partner to synchronize */
      } else { /* done!*/
        return res;
      }
    } /* while %'ModuleName'%.STATUS_POST_IDLE_BIT */
  } /* for(;;) */
}

%-INTERNAL_METHOD_END Communicate
%-************************************************************************************************************
%-BW_METHOD_BEGIN EnableRequest
%ifdef EnableRequest
%define! Partx
%define! Parrx
%define! ParnofAttempts
%define! RetVal
%include Common\LightCommEnableRequest.Inc
byte %'ModuleName'%.%EnableRequest(%'ModuleName'_tTxRxDesc *tx, %'ModuleName'_tTxRxDesc *rx, byte nofAttempts)
{
  byte res;

  for(;nofAttempts>0; nofAttempts--) {
    res = Communicate(tx, rx);
    if (res == ERR_OK) {
      return res;
    }
  } /* for */
  return res;
}

%endif %- EnableRequest
%-BW_METHOD_END EnableRequest
%-************************************************************************************************************
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_METHOD_BEGIN OnRxByte
%ifdef OnRxByte
%IMPLEMENTATION OnRxByte
%define! Pardata
%include Common\LightCommOnRxByte.Inc
void %OnRxByte(byte data)
{
  /* Write your code here ... */
}

%endif %- OnRxByte
%-BW_METHOD_END OnRxByte
%-BW_METHOD_BEGIN OnStatus
%ifdef OnStatus
%IMPLEMENTATION OnStatus
%define! Parstatus
%include Common\LightCommOnStatus.Inc
void %OnStatus(byte status)
{
  /* Write your code here ... */
#if 0 /* example code */
  switch(status) {
    case %'ModuleName'%.STATUS_NONE:
      LED1_Off();
      LED2_Off();
      LED3_Off();
      LED4_Off();
      LED5_Off();
      break;
    case %'ModuleName'%.STATUS_IDLE:
      LED1_On();
      LED2_Off();
      LED3_Off();
      LED4_Off();
      LED5_Off();
      break;
    case %'ModuleName'%.STATUS_TXRX:
      LED1_Off();
      LED2_Off();
      LED3_On();
      break;
    case %'ModuleName'%.STATUS_TX_START:
    case %'ModuleName'%.STATUS_RX_START:
      LED4_Neg();
      break;
    case %'ModuleName'%.STATUS_TX_STOP:
    case %'ModuleName'%.STATUS_RX_STOP:
      LED4_Neg();
      break;
    case %'ModuleName'%.STATUS_TX_BIT_1:
    case %'ModuleName'%.STATUS_RX_BIT_1:
      LED5_On();
      break;
    case %'ModuleName'%.STATUS_TX_BIT_0:
    case %'ModuleName'%.STATUS_RX_BIT_0:
      LED5_Off();
      break;
  }
#endif
}

%endif %- OnStatus
%-BW_METHOD_END OnStatus
%-BW_METHOD_BEGIN OnTxByte
%ifdef OnTxByte
%IMPLEMENTATION OnTxByte
%define! Pardata
%include Common\LightCommOnTxByte.Inc
void %OnTxByte(byte data)
{
  /* Write your code here ... */
}

%endif %- OnTxByte
%-BW_METHOD_END OnTxByte
%-BW_METHOD_BEGIN OnData
%ifdef OnData
%IMPLEMENTATION OnData
%define! Pardata
%include Common\LightCommOnData.Inc
void %OnData(%'ModuleName'_tTxRxDesc *data)
{
  /* Write your code here ... */
}

%endif %- OnData
%-BW_METHOD_END OnData
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This bean is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-

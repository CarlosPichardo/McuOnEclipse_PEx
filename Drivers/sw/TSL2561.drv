%-Driver generated by the Component Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Component Wizard
%- If you change these lines, Component Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    02.06.2017
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\TSL2561Settings.Inc
%define! Abstract Common\TSL2561Abstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */
#include "%@sdk@ModuleName.h" /* SDK and API used */
#include "%'ModuleName'config.h" /* configuration */

#if %'ModuleName'%.CONFIG_PARSE_COMMAND_ENABLED
%if defined(Shell)
  #include "%@Shell@ModuleName.h"
%else
  #include "Shell.h"
%endif
#endif

%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
#ifdef __cplusplus
extern "C" {
#endif

#define %'ModuleName'%.PARSE_COMMAND_ENABLED    %'ModuleName'%.CONFIG_PARSE_COMMAND_ENABLED
  /*!< set to 1 if method ParseCommand() is present, 0 otherwise */

#define TSL2561_LUX_SATURATED_VALUE  0x10000  /* special lux value in case sensor is saturated */

#define TSL2561_GAIN_1X                 0x00  // no gain
#define TSL2561_GAIN_16X                0x10  // 16x gain
#define TSL2561_INTEGRATION_TIME_13MS   0  // 13.7ms
#define TSL2561_INTEGRATION_TIME_101MS  1  // 101ms
#define TSL2561_INTEGRATION_TIME_402MS  2  // 402ms

%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
%-BW_CUSTOM_USERTYPE_END

%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
void %'ModuleName'%.%Deinit(void);
%include Common\TSL2561Deinit.Inc

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
void %'ModuleName'%.%Init(void);
%include Common\TSL2561Init.Inc

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN Disable
%ifdef Disable
uint8_t %'ModuleName'%.%Disable(void);
%define! RetVal
%include Common\TSL2561Disable.Inc

%endif %- Disable
%-BW_METHOD_END Disable
%-************************************************************************************************************
%-BW_METHOD_BEGIN Enable
%ifdef Enable
uint8_t %'ModuleName'%.%Enable(void);
%define! RetVal
%include Common\TSL2561Enable.Inc

%endif %- Enable
%-BW_METHOD_END Enable
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseCommand
%ifdef ParseCommand
uint8_t %'ModuleName'%.%ParseCommand(const unsigned char* cmd, bool *handled, const %@Shell@'ModuleName'%.StdIOType *io);
%define! Parcmd
%define! Parhandled
%define! Pario
%define! RetVal
%include Common\TSL2561ParseCommand.Inc

%endif %- ParseCommand
%-BW_METHOD_END ParseCommand
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetIntegrationTime
%ifdef SetIntegrationTime
uint8_t %'ModuleName'%.%SetIntegrationTime(uint8_t timing);
%define! Partiming
%define! RetVal
%include Common\TSL2561SetIntegrationTime.Inc

%endif %- SetIntegrationTime
%-BW_METHOD_END SetIntegrationTime
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetGain
%ifdef SetGain
uint8_t %'ModuleName'%.%SetGain(uint8_t gain);
%define! Pargain
%define! RetVal
%include Common\TSL2561SetGain.Inc

%endif %- SetGain
%-BW_METHOD_END SetGain
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadRawDataFull
%ifdef ReadRawDataFull
uint8_t %'ModuleName'%.%ReadRawDataFull(uint16_t *data);
%define! Pardata
%define! RetVal
%include Common\TSL2561ReadRawDataFull.Inc

%endif %- ReadRawDataFull
%-BW_METHOD_END ReadRawDataFull
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadRawDataInfrared
%ifdef ReadRawDataInfrared
uint8_t %'ModuleName'%.%ReadRawDataInfrared(uint16_t *data);
%define! Pardata
%define! RetVal
%include Common\TSL2561ReadRawDataInfrared.Inc

%endif %- ReadRawDataInfrared
%-BW_METHOD_END ReadRawDataInfrared
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadData
%ifdef ReadData
uint8_t %'ModuleName'%.%ReadData(uint16_t *broadband, uint16_t *ir);
%define! Parbroadband
%define! Parir
%define! RetVal
%include Common\TSL2561ReadData.Inc

%endif %- ReadData
%-BW_METHOD_END ReadData
%-************************************************************************************************************
%-BW_METHOD_BEGIN CalculateLux
%ifdef CalculateLux
uint32_t %'ModuleName'%.%CalculateLux(uint16_t broadband, uint16_t ir);
%define! Parbroadband
%define! Parir
%define! RetVal
%include Common\TSL2561CalculateLux.Inc

%endif %- CalculateLux
%-BW_METHOD_END CalculateLux
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetLuminosity
%ifdef GetLuminosity
void %'ModuleName'%.%GetLuminosity(uint16_t *broadband, uint16_t *ir);
%define! Parbroadband
%define! Parir
%include Common\TSL2561GetLuminosity.Inc

%endif %- GetLuminosity
%-BW_METHOD_END GetLuminosity
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetLux
%ifdef GetLux
uint8_t %'ModuleName'%.%GetLux(uint32_t *lux);
%define! Parlux
%define! RetVal
%include Common\TSL2561GetLux.Inc

%endif %- GetLux
%-BW_METHOD_END GetLux
%-************************************************************************************************************
%-BW_METHOD_BEGIN LuxToAmbientPercentage
%ifdef LuxToAmbientPercentage
void %'ModuleName'%.%LuxToAmbientPercentage(uint32_t luxVal, uint8_t *ambient);
%define! ParluxVal
%define! Parambient
%include Common\TSL2561LuxToAmbientPercentage.Inc

%endif %- LuxToAmbientPercentage
%-BW_METHOD_END LuxToAmbientPercentage
%-BW_DEFINITION_END
/* END %ModuleName. */

#ifdef __cplusplus
}  /* extern "C" */
#endif

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\TSL2561Settings.Inc
%define! Abstract Common\TSL2561Abstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

#include "%'ModuleName'.h"
#include "%@I2C@ModuleName.h"
#include "%@Wait@ModuleName.h"
#include "%@Utility@ModuleName.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
#define TSL2561_COMMAND_BIT (0x80)    // Must be 1
#define TSL2561_CLEAR_BIT   (0x40)    // Clears any pending interrupt (write 1 to clear)
#define TSL2561_WORD_BIT    (0x20)    // read/write word (rather than byte)
#define TSL2561_BLOCK_BIT   (0x10)    // using block read/write

#define TSL2561_CONTROL_POWERON  (0x03)
#define TSL2561_CONTROL_POWEROFF (0x00)

#define TSL2561_LUX_SCALE     (14)      // Scale by 2^14
#define TSL2561_RATIO_SCALE   (9)       // Scale ratio by 2^9
#define TSL2561_CHSCALE       (10)      // Scale channel values by 2^10
#define TSL2561_CHSCALE_TINT0 (0x7517)  // 322/11 * 2^TSL2561_LUX_CHSCALE
#define TSL2561_CHSCALE_TINT1 (0x0FE7)  // 322/81 * 2^TSL2561_LUX_CHSCALE

// T, FN and CL package values
#define TSL2561_LUX_K1T           (0x0040)  // 0.125 * 2^RATIO_SCALE
#define TSL2561_LUX_B1T           (0x01f2)  // 0.0304 * 2^LUX_SCALE
#define TSL2561_LUX_M1T           (0x01be)  // 0.0272 * 2^LUX_SCALE
#define TSL2561_LUX_K2T           (0x0080)  // 0.250 * 2^RATIO_SCALE
#define TSL2561_LUX_B2T           (0x0214)  // 0.0325 * 2^LUX_SCALE
#define TSL2561_LUX_M2T           (0x02d1)  // 0.0440 * 2^LUX_SCALE
#define TSL2561_LUX_K3T           (0x00c0)  // 0.375 * 2^RATIO_SCALE
#define TSL2561_LUX_B3T           (0x023f)  // 0.0351 * 2^LUX_SCALE
#define TSL2561_LUX_M3T           (0x037b)  // 0.0544 * 2^LUX_SCALE
#define TSL2561_LUX_K4T           (0x0100)  // 0.50 * 2^RATIO_SCALE
#define TSL2561_LUX_B4T           (0x0270)  // 0.0381 * 2^LUX_SCALE
#define TSL2561_LUX_M4T           (0x03fe)  // 0.0624 * 2^LUX_SCALE
#define TSL2561_LUX_K5T           (0x0138)  // 0.61 * 2^RATIO_SCALE
#define TSL2561_LUX_B5T           (0x016f)  // 0.0224 * 2^LUX_SCALE
#define TSL2561_LUX_M5T           (0x01fc)  // 0.0310 * 2^LUX_SCALE
#define TSL2561_LUX_K6T           (0x019a)  // 0.80 * 2^RATIO_SCALE
#define TSL2561_LUX_B6T           (0x00d2)  // 0.0128 * 2^LUX_SCALE
#define TSL2561_LUX_M6T           (0x00fb)  // 0.0153 * 2^LUX_SCALE
#define TSL2561_LUX_K7T           (0x029a)  // 1.3 * 2^RATIO_SCALE
#define TSL2561_LUX_B7T           (0x0018)  // 0.00146 * 2^LUX_SCALE
#define TSL2561_LUX_M7T           (0x0012)  // 0.00112 * 2^LUX_SCALE
#define TSL2561_LUX_K8T           (0x029a)  // 1.3 * 2^RATIO_SCALE
#define TSL2561_LUX_B8T           (0x0000)  // 0.000 * 2^LUX_SCALE
#define TSL2561_LUX_M8T           (0x0000)  // 0.000 * 2^LUX_SCALE

// CS package values
#define TSL2561_LUX_K1C           (0x0043)  // 0.130 * 2^RATIO_SCALE
#define TSL2561_LUX_B1C           (0x0204)  // 0.0315 * 2^LUX_SCALE
#define TSL2561_LUX_M1C           (0x01ad)  // 0.0262 * 2^LUX_SCALE
#define TSL2561_LUX_K2C           (0x0085)  // 0.260 * 2^RATIO_SCALE
#define TSL2561_LUX_B2C           (0x0228)  // 0.0337 * 2^LUX_SCALE
#define TSL2561_LUX_M2C           (0x02c1)  // 0.0430 * 2^LUX_SCALE
#define TSL2561_LUX_K3C           (0x00c8)  // 0.390 * 2^RATIO_SCALE
#define TSL2561_LUX_B3C           (0x0253)  // 0.0363 * 2^LUX_SCALE
#define TSL2561_LUX_M3C           (0x0363)  // 0.0529 * 2^LUX_SCALE
#define TSL2561_LUX_K4C           (0x010a)  // 0.520 * 2^RATIO_SCALE
#define TSL2561_LUX_B4C           (0x0282)  // 0.0392 * 2^LUX_SCALE
#define TSL2561_LUX_M4C           (0x03df)  // 0.0605 * 2^LUX_SCALE
#define TSL2561_LUX_K5C           (0x014d)  // 0.65 * 2^RATIO_SCALE
#define TSL2561_LUX_B5C           (0x0177)  // 0.0229 * 2^LUX_SCALE
#define TSL2561_LUX_M5C           (0x01dd)  // 0.0291 * 2^LUX_SCALE
#define TSL2561_LUX_K6C           (0x019a)  // 0.80 * 2^RATIO_SCALE
#define TSL2561_LUX_B6C           (0x0101)  // 0.0157 * 2^LUX_SCALE
#define TSL2561_LUX_M6C           (0x0127)  // 0.0180 * 2^LUX_SCALE
#define TSL2561_LUX_K7C           (0x029a)  // 1.3 * 2^RATIO_SCALE
#define TSL2561_LUX_B7C           (0x0037)  // 0.00338 * 2^LUX_SCALE
#define TSL2561_LUX_M7C           (0x002b)  // 0.00260 * 2^LUX_SCALE
#define TSL2561_LUX_K8C           (0x029a)  // 1.3 * 2^RATIO_SCALE
#define TSL2561_LUX_B8C           (0x0000)  // 0.000 * 2^LUX_SCALE
#define TSL2561_LUX_M8C           (0x0000)  // 0.000 * 2^LUX_SCALE

#define TSL2561_REG_CONTROL          (0x00)
#define TSL2561_REG_TIMING           (0x01)
#define TSL2561_REG_THRESHHOLDL_LOW  (0x02)
#define TSL2561_REG_THRESHHOLDL_HIGH (0x03)
#define TSL2561_REG_THRESHHOLDH_LOW  (0x04)
#define TSL2561_REG_THRESHHOLDH_HIGH (0x05)
#define TSL2561_REG_INTERRUPT        (0x06)
#define TSL2561_REG_CRC              (0x08)
#define TSL2561_REG_ID               (0x0A)
#define TSL2561_REG_CHAN0_LOW        (0x0C)
#define TSL2561_REG_CHAN0_HIGH       (0x0D)
#define TSL2561_REG_CHAN1_LOW        (0x0E)
#define TSL2561_REG_CHAN1_HIGH       (0x0F)

// Auto-gain thresholds
#define TSL2561_AGC_THI_13MS      (4850)    // Max value at Ti 13ms = 5047
#define TSL2561_AGC_TLO_13MS      (100)
#define TSL2561_AGC_THI_101MS     (36000)   // Max value at Ti 101ms = 37177
#define TSL2561_AGC_TLO_101MS     (200)
#define TSL2561_AGC_THI_402MS     (63000)   // Max value at Ti 402ms = 65535
#define TSL2561_AGC_TLO_402MS     (500)

// Clipping thresholds
#define TSL2561_CLIPPING_13MS     (4900)
#define TSL2561_CLIPPING_101MS    (37000)
#define TSL2561_CLIPPING_402MS    (65000)

#define TSL2561_LUX_LUXSCALE      (14)      // Scale by 2^14
#define TSL2561_LUX_RATIOSCALE    (9)       // Scale ratio by 2^9
#define TSL2561_LUX_CHSCALE       (10)      // Scale channel values by 2^10
#define TSL2561_LUX_CHSCALE_TINT0 (0x7517)  // 322/11 * 2^TSL2561_LUX_CHSCALE
#define TSL2561_LUX_CHSCALE_TINT1 (0x0FE7)  // 322/81 * 2^TSL2561_LUX_CHSCALE

static uint8_t _tsl2561IntegrationTime = TSL2561_INTEGRATION_TIME_13MS;
static uint8_t _tsl2561Gain = TSL2561_GAIN_16X;

%if defined(Shell)
#if %'ModuleName'%.CONFIG_PARSE_COMMAND_ENABLED
static uint8_t PrintStatus(const %@Shell@'ModuleName'%.StdIOType *io) {
  uint8_t buf[32], ambient;
  uint16_t broadband, ir;
  uint32_t lux;

  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"%'ModuleName'", (unsigned char*)"\r\n", io->stdOut);

  if (_tsl2561Gain==TSL2561_GAIN_1X) {
    %@Utility@'ModuleName'%.Num8uToStr(buf, sizeof(buf), _tsl2561Gain+1); /* 1x is zero value */
  } else {
    %@Utility@'ModuleName'%.Num8uToStr(buf, sizeof(buf), _tsl2561Gain);
  }
  %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)"\r\n");
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  gain", buf, io->stdOut);

  if (_tsl2561IntegrationTime==TSL2561_INTEGRATION_TIME_13MS) {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)"0: 13.7 ms\r\n");
  } else if (_tsl2561IntegrationTime==TSL2561_INTEGRATION_TIME_101MS) {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)"1: 101 ms\r\n");
  } else if (_tsl2561IntegrationTime==TSL2561_INTEGRATION_TIME_402MS) {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)"2: 402 ms\r\n");
  } else {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)"WRONG VALUE?\r\n");
  }
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  integration", buf, io->stdOut);

  if (%'ModuleName'%.%ReadRawDataFull(&broadband)==ERR_OK) {
    %@Utility@'ModuleName'%.Num16uToStr(buf, sizeof(buf), broadband);
    %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)"\r\n");
  } else {
    broadband = 0;
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)"ERROR\r\n");
  }
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  broadband", buf, io->stdOut);
  if (%'ModuleName'%.%ReadRawDataInfrared(&ir)==ERR_OK) {
    %@Utility@'ModuleName'%.Num16uToStr(buf, sizeof(buf), ir);
    %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)"%%\r\n");
  } else {
    ir = 0;
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)"ERROR\r\n");
  }
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  infrared", buf, io->stdOut);

  lux = %'ModuleName'%.%CalculateLux(broadband, ir);
  if (lux!=TSL2561_LUX_SATURATED_VALUE) {
    %@Utility@'ModuleName'%.Num32uToStr(buf, sizeof(buf), lux);
  } else {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)"saturated");
  }
  %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)"\r\n");
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  lux", buf, io->stdOut);

  %'ModuleName'%.%LuxToAmbientPercentage(lux, &ambient);
  %@Utility@'ModuleName'%.Num8uToStr(buf, sizeof(buf), ambient);
  %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)"\r\n");
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  ambient", buf, io->stdOut);

  %'ModuleName'%.%GetLuminosity(&broadband, &ir);
  %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)"broad: ");
  %@Utility@'ModuleName'%.strcatNum16u(buf, sizeof(buf), broadband);
  %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)" IR: ");
  %@Utility@'ModuleName'%.strcatNum16u(buf, sizeof(buf), ir);
  %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)"\r\n");
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  luminosity", buf, io->stdOut);

  return ERR_OK;
}

static uint8_t PrintHelp(const %@Shell@'ModuleName'%.StdIOType *io) {
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"%'ModuleName'", (unsigned char*)"Group of %'ModuleName' commands\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  help|status", (unsigned char*)"Print help or status information\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  gain (1|16)", (unsigned char*)"Set gain value\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  integration (13|101|402)", (unsigned char*)"Set intergration time (ms)\r\n", io->stdOut);
  return ERR_OK;
}
#endif /* %'ModuleName'%.CONFIG_PARSE_COMMAND_ENABLED */
%endif %- Shell
%-
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
%include Common\TSL2561Deinit.Inc
void %'ModuleName'%.%Deinit(void)
{
  /* nothing needed */
}

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%include Common\TSL2561Init.Inc
void %'ModuleName'%.%Init(void)
{
  /* initialize sensor from the application */
}

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN Disable
%ifdef Disable
%define! RetVal
%include Common\TSL2561Disable.Inc
uint8_t %'ModuleName'%.%Disable(void)
{
  return %@I2C@'ModuleName'%.WriteByteAddress8(TSL2561_CONFIG_I2C_DEVICE_ADDRESS, TSL2561_COMMAND_BIT|TSL2561_REG_CONTROL, TSL2561_CONTROL_POWEROFF);
}

%endif %- Disable
%-BW_METHOD_END Disable
%-************************************************************************************************************
%-BW_METHOD_BEGIN Enable
%ifdef Enable
%define! RetVal
%include Common\TSL2561Enable.Inc
uint8_t %'ModuleName'%.%Enable(void)
{
  return %@I2C@'ModuleName'%.WriteByteAddress8(TSL2561_CONFIG_I2C_DEVICE_ADDRESS, TSL2561_COMMAND_BIT|TSL2561_REG_CONTROL, TSL2561_CONTROL_POWERON);
}

%endif %- Enable
%-BW_METHOD_END Enable
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseCommand
%ifdef ParseCommand
%define! Parcmd
%define! Parhandled
%define! Pario
%define! RetVal
%include Common\TSL2561ParseCommand.Inc
uint8_t %'ModuleName'%.%ParseCommand(const unsigned char* cmd, bool *handled, const %@Shell@'ModuleName'%.StdIOType *io)
{
#if %'ModuleName'%.CONFIG_PARSE_COMMAND_ENABLED
  uint8_t res = ERR_OK;
  uint8_t buf[32];

  if (%@Utility@'ModuleName'%.strcmp((char*)cmd, %@Shell@'ModuleName'%.CMD_HELP) == 0
    || %@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' help") == 0)
  {
    *handled = TRUE;
    return PrintHelp(io);
  } else if (   (%@Utility@'ModuleName'%.strcmp((char*)cmd, %@Shell@'ModuleName'%.CMD_STATUS)==0)
             || (%@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' status")==0)
            )
  {
    *handled = TRUE;
    res = PrintStatus(io);
  } else if (%@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' gain 1")==0) {
    *handled = TRUE;
    res = %'ModuleName'%.%SetGain(TSL2561_GAIN_1X);
  } else if (%@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' gain 16")==0) {
    *handled = TRUE;
    res = %'ModuleName'%.%SetGain(TSL2561_GAIN_16X);
  } else if (%@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' integration 13")==0) {
    *handled = TRUE;
    res = %'ModuleName'%.%SetIntegrationTime(TSL2561_INTEGRATION_TIME_13MS);
  } else if (%@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' integration 101")==0) {
    *handled = TRUE;
    res = %'ModuleName'%.%SetIntegrationTime(TSL2561_INTEGRATION_TIME_101MS);
  } else if (%@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' integration 402")==0) {
    *handled = TRUE;
    res = %'ModuleName'%.%SetIntegrationTime(TSL2561_INTEGRATION_TIME_402MS);
  }
  return res;
#else
  (void)cmd;
  (void)handled;
  (void)io;
  return ERR_OK;
#endif
}

%endif %- ParseCommand
%-BW_METHOD_END ParseCommand
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetIntegrationTime
%ifdef SetIntegrationTime
%define! Partiming
%define! RetVal
%include Common\TSL2561SetIntegrationTime.Inc
uint8_t %'ModuleName'%.%SetIntegrationTime(uint8_t timing)
{
  _tsl2561IntegrationTime = timing;
  return %@I2C@'ModuleName'%.WriteByteAddress8(TSL2561_CONFIG_I2C_DEVICE_ADDRESS, TSL2561_COMMAND_BIT|TSL2561_REG_TIMING, timing|_tsl2561Gain);
}

%endif %- SetIntegrationTime
%-BW_METHOD_END SetIntegrationTime
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetGain
%ifdef SetGain
%define! Pargain
%define! RetVal
%include Common\TSL2561SetGain.Inc
uint8_t %'ModuleName'%.%SetGain(uint8_t gain)
{
  _tsl2561Gain = gain;
  return %@I2C@'ModuleName'%.WriteByteAddress8(TSL2561_CONFIG_I2C_DEVICE_ADDRESS, TSL2561_COMMAND_BIT|TSL2561_REG_TIMING, gain|_tsl2561IntegrationTime);
}

%endif %- SetGain
%-BW_METHOD_END SetGain
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadRawDataFull
%ifdef ReadRawDataFull
%define! Pardata
%define! RetVal
%include Common\TSL2561ReadRawDataFull.Inc
uint8_t %'ModuleName'%.%ReadRawDataFull(uint16_t *data)
{
  /* read IR and visible light channel */
  uint8_t res;

  *data = 0;
  res = %@I2C@'ModuleName'%.ReadWordAddress8(TSL2561_CONFIG_I2C_DEVICE_ADDRESS, TSL2561_COMMAND_BIT|TSL2561_REG_CHAN0_LOW, data);
  if (res!=ERR_OK) {
    return res;
  }
  return ERR_OK;
}

%endif %- ReadRawDataFull
%-BW_METHOD_END ReadRawDataFull
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadRawDataInfrared
%ifdef ReadRawDataInfrared
%define! Pardata
%define! RetVal
%include Common\TSL2561ReadRawDataInfrared.Inc
uint8_t %'ModuleName'%.%ReadRawDataInfrared(uint16_t *data)
{
  uint8_t res;

  *data = 0;
  res = %@I2C@'ModuleName'%.ReadWordAddress8(TSL2561_CONFIG_I2C_DEVICE_ADDRESS, TSL2561_COMMAND_BIT|TSL2561_REG_CHAN1_LOW, data);
  if (res!=ERR_OK) {
    return res;
  }
  return ERR_OK;
}

%endif %- ReadRawDataInfrared
%-BW_METHOD_END ReadRawDataInfrared
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadData
%ifdef ReadData
%define! Parbroadband
%define! Parir
%define! RetVal
%include Common\TSL2561ReadData.Inc
uint8_t %'ModuleName'%.%ReadData(uint16_t *broadband, uint16_t *ir)
{
  uint8_t res;

  *broadband = 0;
  *ir = 0;
  res = %'ModuleName'%.ReadRawDataFull(broadband);
  if (res!=ERR_OK) {
    return res;
  }
  res = %'ModuleName'%.ReadRawDataInfrared(ir);
  if (res!=ERR_OK) {
    return res;
  }
  return ERR_OK;
}

%endif %- ReadData
%-BW_METHOD_END ReadData
%-************************************************************************************************************
%-BW_METHOD_BEGIN CalculateLux
%ifdef CalculateLux
%define! Parbroadband
%define! Parir
%define! RetVal
%include Common\TSL2561CalculateLux.Inc
uint32_t %'ModuleName'%.%CalculateLux(uint16_t broadband, uint16_t ir)
{
  unsigned long chScale;
  unsigned long channel1;
  unsigned long channel0;

  /* Make sure the sensor isn't saturated! */
  uint16_t clipThreshold;

  switch (_tsl2561IntegrationTime) {
    case TSL2561_INTEGRATION_TIME_13MS:
      clipThreshold = TSL2561_CLIPPING_13MS;
      break;
    case TSL2561_INTEGRATION_TIME_101MS:
      clipThreshold = TSL2561_CLIPPING_101MS;
      break;
    default:
      clipThreshold = TSL2561_CLIPPING_402MS;
      break;
  }

  /* Return 65536 lux if the sensor is saturated */
  if ((broadband > clipThreshold) || (ir > clipThreshold)) {
    return TSL2561_LUX_SATURATED_VALUE;
  }

  /* Get the correct scale depending on the integration time */
  switch (_tsl2561IntegrationTime) {
    case TSL2561_INTEGRATION_TIME_13MS:
      chScale = TSL2561_LUX_CHSCALE_TINT0;
      break;
    case TSL2561_INTEGRATION_TIME_101MS:
      chScale = TSL2561_LUX_CHSCALE_TINT1;
      break;
    default: /* No scaling ... integration time = 402ms */
      chScale = (1 << TSL2561_LUX_CHSCALE);
      break;
  }

  /* Scale for gain (1x or 16x) */
  if (!_tsl2561Gain) {
    chScale = chScale << 4;
  }

  /* Scale the channel values */
  channel0 = (broadband * chScale) >> TSL2561_LUX_CHSCALE;
  channel1 = (ir * chScale) >> TSL2561_LUX_CHSCALE;

  /* Find the ratio of the channel values (Channel1/Channel0) */
  unsigned long ratio1 = 0;
  if (channel0 != 0) ratio1 = (channel1 << (TSL2561_LUX_RATIOSCALE+1)) / channel0;

  /* round the ratio value */
  unsigned long ratio = (ratio1 + 1) >> 1;

  unsigned int b, m;

#if TSL2561_CONFIG_PACKAGE_CS
  if ((ratio >= 0) && (ratio <= TSL2561_LUX_K1C))
    {b=TSL2561_LUX_B1C; m=TSL2561_LUX_M1C;}
  else if (ratio <= TSL2561_LUX_K2C)
    {b=TSL2561_LUX_B2C; m=TSL2561_LUX_M2C;}
  else if (ratio <= TSL2561_LUX_K3C)
    {b=TSL2561_LUX_B3C; m=TSL2561_LUX_M3C;}
  else if (ratio <= TSL2561_LUX_K4C)
    {b=TSL2561_LUX_B4C; m=TSL2561_LUX_M4C;}
  else if (ratio <= TSL2561_LUX_K5C)
    {b=TSL2561_LUX_B5C; m=TSL2561_LUX_M5C;}
  else if (ratio <= TSL2561_LUX_K6C)
    {b=TSL2561_LUX_B6C; m=TSL2561_LUX_M6C;}
  else if (ratio <= TSL2561_LUX_K7C)
    {b=TSL2561_LUX_B7C; m=TSL2561_LUX_M7C;}
  else if (ratio > TSL2561_LUX_K8C)
    {b=TSL2561_LUX_B8C; m=TSL2561_LUX_M8C;}
#else
  if ((ratio >= 0) && (ratio <= TSL2561_LUX_K1T))
    {b=TSL2561_LUX_B1T; m=TSL2561_LUX_M1T;}
  else if (ratio <= TSL2561_LUX_K2T)
    {b=TSL2561_LUX_B2T; m=TSL2561_LUX_M2T;}
  else if (ratio <= TSL2561_LUX_K3T)
    {b=TSL2561_LUX_B3T; m=TSL2561_LUX_M3T;}
  else if (ratio <= TSL2561_LUX_K4T)
    {b=TSL2561_LUX_B4T; m=TSL2561_LUX_M4T;}
  else if (ratio <= TSL2561_LUX_K5T)
    {b=TSL2561_LUX_B5T; m=TSL2561_LUX_M5T;}
  else if (ratio <= TSL2561_LUX_K6T)
    {b=TSL2561_LUX_B6T; m=TSL2561_LUX_M6T;}
  else if (ratio <= TSL2561_LUX_K7T)
    {b=TSL2561_LUX_B7T; m=TSL2561_LUX_M7T;}
  else if (ratio > TSL2561_LUX_K8T)
    {b=TSL2561_LUX_B8T; m=TSL2561_LUX_M8T;}
#endif

  unsigned long temp;
  temp = ((channel0 * b) - (channel1 * m));

  /* Do not allow negative lux value */
  if (temp < 0) {
    temp = 0;
  }

  /* Round lsb (2^(LUX_SCALE-1)) */
  temp += (1 << (TSL2561_LUX_LUXSCALE-1));

  /* Strip off fractional portion */
  uint32_t lux = temp >> TSL2561_LUX_LUXSCALE;

  return lux;
}

%endif %- CalculateLux
%-BW_METHOD_END CalculateLux
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetLuminosity
%ifdef GetLuminosity
%define! Parbroadband
%define! Parir
%include Common\TSL2561GetLuminosity.Inc
void %'ModuleName'%.%GetLuminosity(uint16_t *broadband, uint16_t *ir)
{
  bool valid = FALSE;

  /* Read data until we find a valid range */
  bool _agcCheck = FALSE;
  do {
    uint16_t _b, _ir;
    uint16_t _hi, _lo;
    uint8_t _it = _tsl2561IntegrationTime;

    /* Get the hi/low threshold for the current integration time */
    switch(_it) {
      case TSL2561_INTEGRATION_TIME_13MS:
        _hi = TSL2561_AGC_THI_13MS;
        _lo = TSL2561_AGC_TLO_13MS;
        break;
      case TSL2561_INTEGRATION_TIME_101MS:
        _hi = TSL2561_AGC_THI_101MS;
        _lo = TSL2561_AGC_TLO_101MS;
        break;
      default:
        _hi = TSL2561_AGC_THI_402MS;
        _lo = TSL2561_AGC_TLO_402MS;
        break;
    }
    (void)%'ModuleName'%.ReadData(&_b, &_ir);
    /* Run an auto-gain check if we haven't already done so ... */
    if (!_agcCheck){
      if ((_b < _lo) && (_tsl2561Gain == TSL2561_GAIN_1X)) {
        /* Increase the gain and try again */
        %'ModuleName'%.SetGain(TSL2561_GAIN_16X);
        /* Drop the previous conversion results */
        (void)%'ModuleName'%.ReadData(&_b, &_ir);
        /* Set a flag to indicate we've adjusted the gain */
        _agcCheck = TRUE;
      } else if ((_b > _hi) && (_tsl2561Gain == TSL2561_GAIN_16X)) {
        /* Drop gain to 1x and try again */
        %'ModuleName'%.SetGain(TSL2561_GAIN_1X);
        /* Drop the previous conversion results */
        (void)%'ModuleName'%.ReadData(&_b, &_ir);
        /* Set a flag to indicate we've adjusted the gain */
        _agcCheck = TRUE;
      } else {
        /* Nothing to look at here, keep moving ....
           Reading is either valid, or we're already at the chips limits */
        *broadband = _b;
        *ir = _ir;
        valid = TRUE;
      }
    } else {
      /* If we've already adjusted the gain once, just return the new results.
         This avoids endless loops where a value is at one extreme pre-gain,
         and the the other extreme post-gain */
      *broadband = _b;
      *ir = _ir;
      valid = TRUE;
    }
  } while (!valid);
}

%endif %- GetLuminosity
%-BW_METHOD_END GetLuminosity
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetLux
%ifdef GetLux
%define! Parlux
%define! RetVal
%include Common\TSL2561GetLux.Inc
uint8_t %'ModuleName'%.%GetLux(uint32_t *lux)
{
  uint8_t res;
  uint16_t broadband, infrared;

  *lux = 0; /* init */
  res = %'ModuleName'%.%ReadRawDataFull(&broadband);
  if (res!=ERR_OK) {
    return res;
  }
  res = %'ModuleName'%.%ReadRawDataInfrared(&infrared);
  if (res!=ERR_OK) {
    return res;
  }
  *lux = %'ModuleName'%.%CalculateLux(broadband, infrared);
  return ERR_OK;
}

%endif %- GetLux
%-BW_METHOD_END GetLux
%-************************************************************************************************************
%-BW_METHOD_BEGIN LuxToAmbientPercentage
%ifdef LuxToAmbientPercentage
%define! ParluxVal
%define! Parambient
%include Common\TSL2561LuxToAmbientPercentage.Inc
void %'ModuleName'%.%LuxToAmbientPercentage(uint32_t luxVal, uint8_t *ambient)
{
  if (luxVal<128) {
    *ambient = (luxVal*100)>>7;
  } else {
    *ambient = 100;
  }
}

%endif %- LuxToAmbientPercentage
%-BW_METHOD_END LuxToAmbientPercentage
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
  /* Write code here ... */
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%-----------------------------------------------------------------------------------------
%if defined(sdk) & %@sdk@ConfigFilesFolderName <> ""
  %define  ConfigSrcDirFolder %%@sdk@ConfigFilesFolderName/
%else
  %define  ConfigSrcDirFolder
%endif
%----------------------------
%FILE %'DirRel_Code'%'ConfigSrcDirFolder'%'ModuleName'config.h
#ifndef __%'ModuleName'_CONFIG_H
#define __%'ModuleName'_CONFIG_H

%if defined(is_CS_package) & %is_CS_package='yes'
#define TSL2561_CONFIG_PACKAGE_CS       (1)
%else
#define TSL2561_CONFIG_PACKAGE_CS       (0)
%endif
  /*!< 1: device is in CS package. 0: device is in normal package */

%if defined(i2cDeviceAddress)
#define TSL2561_CONFIG_I2C_DEVICE_ADDRESS  %i2cDeviceAddress
%endif
  /*!< Device I2C address */
//#define TSL2561_CONFIG_I2C_DEVICE_ADDRESS  0b0101001  /* device address with ADDR pin set to GND */
//#define TSL2561_CONFIG_I2C_DEVICE_ADDRESS  0b0111001  /* device address with ADDR pin floating */
//#define TSL2561_CONFIG_I2C_DEVICE_ADDRESS  0b1001001  /* device address with ADDR pin set to VDD */

#if !defined(%'ModuleName'%.CONFIG_PARSE_COMMAND_ENABLED)
%ifdef ParseCommand
  #define %'ModuleName'%.CONFIG_PARSE_COMMAND_ENABLED            %>60(1)
%else
  #define %'ModuleName'%.CONFIG_PARSE_COMMAND_ENABLED            %>60(0)
%endif %- ParseCommand
    /*!< 1: shell support enabled, 0: otherwise */
#endif

#endif /* __%'ModuleName'_CONFIG_H */
%-----------------------------------------------------------------------------------------
%else %- Language (& Compiler)
  %error^ This component is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-

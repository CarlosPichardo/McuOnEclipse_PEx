%-Driver generated by the Component Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Component Wizard
%- If you change these lines, Component Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Andreas Schoepfer
%define DriverVersion 01.00
%define DriverDate    16.11.2011
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%define! Description_ReadAccel 
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\MMA7455LSettings.Inc
%define! Abstract Common\MMA7455LAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
%-BW_CUSTOM_USERTYPE_END


%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadByte
%ifdef ReadByte
byte %'ModuleName'%.%ReadByte(byte addr, byte *val);
%define! Paraddr
%define! Parval
%define! RetVal
%include Common\MMA7455LReadByte.Inc

%endif %- ReadByte
%-BW_METHOD_END ReadByte
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteByte
%ifdef WriteByte
byte %'ModuleName'%.%WriteByte(byte addr, byte *val);
%define! Paraddr
%define! Parval
%define! RetVal
%include Common\MMA7455LWriteByte.Inc

%endif %- WriteByte
%-BW_METHOD_END WriteByte
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadBlock
%ifdef ReadBlock
byte %'ModuleName'%.%ReadBlock(byte addr, byte *buf, byte bufSize);
%define! Paraddr
%define! Parbuf
%define! ParbufSize
%define! RetVal
%include Common\MMA7455LReadBlock.Inc

%endif %- ReadBlock
%-BW_METHOD_END ReadBlock
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteBlock
%ifdef WriteBlock
byte %'ModuleName'%.%WriteBlock(byte addr, byte *buf, byte bufSize);
%define! Paraddr
%define! Parbuf
%define! ParbufSize
%define! RetVal
%include Common\MMA7455LWriteBlock.Inc

%endif %- WriteBlock
%-BW_METHOD_END WriteBlock
%-************************************************************************************************************
%-BW_METHOD_BEGIN CalibrateAxes
%ifdef CalibrateAxes
byte %'ModuleName'%.%CalibrateAxes(void);
%define! RetVal
%include Common\MMA7455LCalibrateAxes.Inc

%endif %- CalibrateAxes
%-BW_METHOD_END CalibrateAxes
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetRawX
%ifdef GetRawX
byte %'ModuleName'%.%GetRawX(signed char *accelX);
%define! ParaccelX
%define! RetVal
%include Common\MMA7455LGetRawX.Inc

%endif %- GetRawX
%-BW_METHOD_END GetRawX
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetRawY
%ifdef GetRawY
byte %'ModuleName'%.%GetRawY(signed char *accelY);
%define! ParaccelY
%define! RetVal
%include Common\MMA7455LGetRawY.Inc

%endif %- GetRawY
%-BW_METHOD_END GetRawY
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetRawZ
%ifdef GetRawZ
byte %'ModuleName'%.%GetRawZ(signed char *accelZ);
%define! ParaccelZ
%define! RetVal
%include Common\MMA7455LGetRawZ.Inc

%endif %- GetRawZ
%-BW_METHOD_END GetRawZ
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetXmg
%ifdef GetXmg
byte %'ModuleName'%.%GetXmg(int16_t *accelX);
%define! ParaccelX
%define! RetVal
%include Common\MMA7455LGetXmg.Inc

%endif %- GetXmg
%-BW_METHOD_END GetXmg
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetYmg
%ifdef GetYmg
byte %'ModuleName'%.%GetYmg(int16_t *accelY);
%define! ParaccelY
%define! RetVal
%include Common\MMA7455LGetYmg.Inc

%endif %- GetYmg
%-BW_METHOD_END GetYmg
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetZmg
%ifdef GetZmg
byte %'ModuleName'%.%GetZmg(int16_t *accelZ);
%define! ParaccelZ
%define! RetVal
%include Common\MMA7455LGetZmg.Inc

%endif %- GetZmg
%-BW_METHOD_END GetZmg
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
byte %'ModuleName'%.%Init(void);
%define! RetVal
%include Common\MMA7455LInit.Inc

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetXYZmg
%ifdef GetXYZmg
byte %'ModuleName'%.%GetXYZmg(int16_t *accel);
%define! Paraccel
%define! RetVal
%include Common\MMA7455LGetXYZmg.Inc

%endif %- GetXYZmg
%-BW_METHOD_END GetXYZmg
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\MMA7455LSettings.Inc
%define! Abstract Common\MMA7455LAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
#define %'ModuleName'%.DEV_ADDR                      %DeviceAddress   /* I2C-Adress of the acceleration sensor*/
#define %'ModuleName'%.MODE_CONTROLL_REGISTER        0x16             /* Address of the mode controll register*/
#define %'ModuleName'%.OFFSET_TOLERANCE              3                /* Offset tolerance*/
#define %'ModuleName'%.Z_OFFSET                      64               /*Value for calibrate the Z-Axis to 1g*/
#define %'ModuleName'%.X_AXIS_REG                    0x06
#define %'ModuleName'%.Y_AXIS_REG                    0x07
#define %'ModuleName'%.Z_AXIS_REG                    0x08
#define %'ModuleName'%.STATUS_REG                    0x09
%-
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-UNLOCKED
/* Internal method prototypes */
%-INTERNAL_LOC_METHOD_BEG ReadAccel
static byte ReadAccel(byte reg_addr, signed char *accel);
%-INTERNAL_LOC_METHOD_END ReadAccel
%-

%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadByte
%ifdef ReadByte
%define! Paraddr
%define! Parval
%define! RetVal
%include Common\MMA7455LReadByte.Inc
byte %'ModuleName'%.%ReadByte(byte addr, byte *val)
{
  uint8_t errCode;

  %@SWI2C@'ModuleName'%.SelectSlave(%'ModuleName'%.DEV_ADDR);
  errCode = %@SWI2C@'ModuleName'%.SendChar(addr);
  if (errCode!=ERR_OK) {
    return errCode;
  }
  errCode = %@SWI2C@'ModuleName'%.RecvChar(val);
  if (errCode!=ERR_OK) {
    return errCode;
  }
  return ERR_OK;
}

%endif %- ReadByte
%-BW_METHOD_END ReadByte
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteByte
%ifdef WriteByte
%define! Paraddr
%define! Parval
%define! RetVal
%include Common\MMA7455LWriteByte.Inc
byte %'ModuleName'%.%WriteByte(byte addr, byte *val)
{
  uint16_t cnt = 0;
  uint8_t toSend[2];

  %@SWI2C@'ModuleName'%.SelectSlave(%'ModuleName'%.DEV_ADDR);
  toSend[0] = addr;
  toSend[1] = *val;
  return (%@SWI2C@'ModuleName'%.SendBlock(&toSend, sizeof(toSend), &cnt)); /*return ERR-Code*/
}

%endif %- WriteByte
%-BW_METHOD_END WriteByte
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadBlock
%ifdef ReadBlock
%define! Paraddr
%define! Parbuf
%define! ParbufSize
%define! RetVal
%include Common\MMA7455LReadBlock.Inc
byte %'ModuleName'%.%ReadBlock(byte addr, byte *buf, byte bufSize)
{
  uint8_t errCode;
  uint16_t cnt;

  %@SWI2C@'ModuleName'%.SelectSlave(%'ModuleName'%.DEV_ADDR);
  errCode=%@SWI2C@'ModuleName'%.SendChar(addr);
  if(errCode!=ERR_OK) {
    return errCode;
  }
  errCode=%@SWI2C@'ModuleName'%.RecvBlock(buf, (word) bufSize, &cnt);
  if(errCode!=ERR_OK) {
    return errCode;
  }
  return ERR_OK;
}

%endif %- ReadBlock
%-BW_METHOD_END ReadBlock
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteBlock
%ifdef WriteBlock
%define! Paraddr
%define! Parbuf
%define! ParbufSize
%define! RetVal
%include Common\MMA7455LWriteBlock.Inc
byte %'ModuleName'%.%WriteBlock(byte addr, byte *buf, byte bufSize)
{
  uint8_t i;
  uint8_t toSend[11];
  uint16_t cnt = 0;

  %@SWI2C@'ModuleName'%.SelectSlave(%'ModuleName'%.DEV_ADDR);
  if (bufSize>sizeof(toSend)-1) {
    return ERR_PARAM_HIGH_VALUE;
  }
  toSend[0] = addr;
  for(i=1; i<(bufSize+1); i++) {
    toSend[i] = buf[i-1];
  }
  return (%@SWI2C@'ModuleName'%.SendBlock(&toSend, (word)(bufSize+1), &cnt));
}

%endif %- WriteBlock
%-BW_METHOD_END WriteBlock
%-************************************************************************************************************
%-BW_METHOD_BEGIN CalibrateAxes
%ifdef CalibrateAxes
%define! RetVal
%include Common\MMA7455LCalibrateAxes.Inc
byte %'ModuleName'%.%CalibrateAxes(void)
{
  uint8_t accel[] = {0,0,0,0,0,0};                                  /* used for read and write to the sensor*/
  int16_t sum[] = {0,0,0};                                          /* sum of 8 measures for each axis*/
  int16_t lastsum[] = {0,0,0};                                      /* sum of previous calibration-procedure*/
  uint8_t i;                                                        /* index used in for-loops*/
  uint8_t j = 0;
  uint8_t errCode;
  int16_t firstZOffset;
  bool firstRun = TRUE;                                                /* calibration-procedure counter*/
  bool offset_OK = 0;                                               /* variable to brake up calibration routine*/
  uint16_t max_tolerance = 8*%'ModuleName'%.OFFSET_TOLERANCE;        /* max offset tolerance, average of 8*/

  /*First write zeros to the offset registers*/
  errCode = %'ModuleName'%.%WriteBlock(0x10,&accel[0], sizeof(accel));
  if(errCode != ERR_OK) {
    return errCode;         //error occurred!
  }
  /*Do the initialization of the offset-registers more than one time!
  *If you do it just ones you will have faults around 14 counts
  *in Z-direction! (impreciseness of the offset-registers)
  *The routine stops if the offset is smaller than OFFSET_TOLERANCE
  *or after 10 calibration-procedures
  */
  while(offset_OK!=1) {
    j++;
    %@Wait@'ModuleName'%.Waitms(50);
    /*For each calibration-procedure, take the average of 8*/
    for (i = 0; i < 8; i++) {
      uint8_t k;
      uint8_t statusByte=0;

      while((statusByte & 0x01) != 1) {
        errCode = %'ModuleName'%.%ReadByte(%'ModuleName'%.STATUS_REG, &statusByte);
        if(errCode != ERR_OK) {
          return errCode;
        }
        %@Wait@'ModuleName'%.Waitus(1);/*Wait till data is ready (DRDY)*/
      }
      /* read offset of all 3 axis*/
      errCode = %'ModuleName'%.%ReadBlock(0x00,&accel[0], sizeof(accel));
      if(errCode != ERR_OK) {
        return errCode;          /*error occurred!*/
      }
      /* convert offset to 16Bit signed*/
      for(k=0;k<3;k++) { /* sign extension*/
        if(accel[1+2*k]&0x02) {   /* H-Byte        L-Byte*/
          sum[k] += (int16_t) (((accel[1+2*k]|0xFC)<<8)+accel[0+2*k]);  /*negative value*/
        } else{                   /* H-Byte        L-Byte*/
          sum[k] += (int16_t) ((accel[1+2*k]<<8)+accel[0+2*k]);         /*positive value*/
        }
      }
    }
    /* check if a further calibration-procedure is necessary*/
    if((sum[2]<max_tolerance&&sum[2]>(max_tolerance*(-1))&&  /* Z-Offset OK?*/
        sum[1]<max_tolerance&&sum[1]>(max_tolerance*(-1))&&  /* Y-Offset OK?*/
        sum[0]<max_tolerance&&sum[0]>(max_tolerance*(-1))  ) /* X-Offset OK?*/
        ||  j>10) {                                          /* don't execute more than 10 calibration-procedures*/
                  offset_OK = 1;
    }
    /*..do for each axis*/
    for(i=0;i<3;i++) {
      /*add difference from last measurement*/
      sum[i] += ((lastsum[i]*(-1))<<(3-1));
      sum[i] *= (-1);
      /* 3: make average of 8 , -1: cause offset register has another resolution*/
      sum[i] >>= (3-1);
      /*actualize lastsum*/
      lastsum[i]=sum[i];
      /*write new difference into accel array*/
      accel[0+2*i] = (uint8_t)(sum[i] & 0xFF);                /*L-Byte*/
      accel[1+2*i] = (uint8_t)((sum[i] & 0x700)>>8);          /*H-Byte*/
      /*clear sum for next measurement*/
      sum[i]=0;
    }
    /*remember first accel of Z-Axis to calculate the offset fault factor*/
    if(firstRun) {
        firstZOffset=lastsum[2];
        firstRun = FALSE;
    }
    /*write new difference to the offset registers of all axes*/
    errCode = %'ModuleName'%.%WriteBlock(0x10,&accel[0],sizeof(accel));
    if(errCode != ERR_OK) {
      return errCode;        /*error occurred!*/
    }
  }
  /*add Z_OFFSET to the Z-offset register! (by using a offset fault factor)*/
  lastsum[2] += ((%'ModuleName'%.Z_OFFSET*lastsum[2]/firstZOffset)<<1);
  accel[4] = (uint8_t)(lastsum[2] & 0xFF);                /*L-Byte*/
  accel[5] = (uint8_t)((lastsum[2] & 0x700)>>8);          /*H-Byte*/
  errCode = %'ModuleName'%.%WriteBlock(0x14,&accel[4],2);
  if(errCode != ERR_OK) {
    return errCode;          /*error occurred!*/
  }
  return ERR_OK;
}

%endif %- CalibrateAxes
%-BW_METHOD_END CalibrateAxes
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetRawX
%ifdef GetRawX
%define! ParaccelX
%define! RetVal
%include Common\MMA7455LGetRawX.Inc
byte %'ModuleName'%.%GetRawX(signed char *accelX)
{
  return ReadAccel(%'ModuleName'%.X_AXIS_REG, accelX);
}

%endif %- GetRawX
%-BW_METHOD_END GetRawX
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetRawY
%ifdef GetRawY
%define! ParaccelY
%define! RetVal
%include Common\MMA7455LGetRawY.Inc
byte %'ModuleName'%.%GetRawY(signed char *accelY)
{
  return ReadAccel(%'ModuleName'%.Y_AXIS_REG, accelY);
}

%endif %- GetRawY
%-BW_METHOD_END GetRawY
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetRawZ
%ifdef GetRawZ
%define! ParaccelZ
%define! RetVal
%include Common\MMA7455LGetRawZ.Inc
byte %'ModuleName'%.%GetRawZ(signed char *accelZ)
{
  return ReadAccel(%'ModuleName'%.Z_AXIS_REG, accelZ);
}

%endif %- GetRawZ
%-BW_METHOD_END GetRawZ
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetXmg
%ifdef GetXmg
%define! ParaccelX
%define! RetVal
%include Common\MMA7455LGetXmg.Inc
byte %'ModuleName'%.%GetXmg(int16_t *accelX)
{
  uint8_t errCode;
  int8_t rawAccel;

  errCode = ReadAccel(%'ModuleName'%.X_AXIS_REG, &rawAccel);
  if(errCode != ERR_OK) {
    return errCode;
  }
  *accelX = (int16_t)(rawAccel*1000/64);
}

%endif %- GetXmg
%-BW_METHOD_END GetXmg
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetYmg
%ifdef GetYmg
%define! ParaccelY
%define! RetVal
%include Common\MMA7455LGetYmg.Inc
byte %'ModuleName'%.%GetYmg(int16_t *accelY)
{
  uint8_t errCode;
  int8_t rawAccel;

  errCode = ReadAccel(%'ModuleName'%.Y_AXIS_REG, &rawAccel);
  if(errCode != ERR_OK) {
    return errCode;
  }
  *accelY = (int16_t)(rawAccel*1000/64);
}

%endif %- GetYmg
%-BW_METHOD_END GetYmg
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetZmg
%ifdef GetZmg
%define! ParaccelZ
%define! RetVal
%include Common\MMA7455LGetZmg.Inc
byte %'ModuleName'%.%GetZmg(int16_t *accelZ)
{
  uint8_t errCode;
  int8_t rawAccel;

  errCode = ReadAccel(%'ModuleName'%.Z_AXIS_REG, &rawAccel);
  if(errCode != ERR_OK) {
    return errCode;
  }
  *accelZ = (int16_t)(rawAccel*1000/64);
}

%endif %- GetZmg
%-BW_METHOD_END GetZmg
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%define! RetVal
%include Common\MMA7455LInit.Inc
byte %'ModuleName'%.%Init(void)
{
  uint8_t modeCtrlVal = 0x05;

  %@CS@'ModuleName'%.PutVal(TRUE);
  %@IADDR0@'ModuleName'%.PutVal(TRUE);
  /*select measurement mode with 2g range*/
  return %'ModuleName'%.%WriteByte(%'ModuleName'%.MODE_CONTROLL_REGISTER, &modeCtrlVal);
}

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG ReadAccel
%define! Parreg_addr
%define! Paraccel
%define! RetVal
%include Common\GeneralInternalGlobal.inc (ReadAccel)
static byte ReadAccel(byte reg_addr, signed char *accel)
{
  uint8_t statusByte=0;
  uint8_t errCode=ERR_OK;

  %@SWI2C@'ModuleName'%.SelectSlave(%'ModuleName'%.DEV_ADDR);
  /*waiting till data is ready (DRDY-Bit)*/
  while((statusByte & 0x01) != 1) {
    errCode = %'ModuleName'%.%ReadByte(%'ModuleName'%.STATUS_REG, &statusByte);
    if(errCode != ERR_OK) {
      return errCode;
    }
    %@Wait@'ModuleName'%.Waitus(1);
  }
  /*Read accel value*/
  return (%'ModuleName'%.%ReadByte(reg_addr, (uint8_t*)accel));
}

%-INTERNAL_METHOD_END ReadAccel
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetXYZmg
%ifdef GetXYZmg
%define! Paraccel
%define! RetVal
%include Common\MMA7455LGetXYZmg.Inc
byte %'ModuleName'%.%GetXYZmg(int16_t *accel)
{
  uint8_t statusByte=0;
  uint8_t errCode;
  int8_t rawAccel[3];
  uint8_t i;

  %@SWI2C@'ModuleName'%.SelectSlave(%'ModuleName'%.DEV_ADDR);
  /*waiting till data is ready (DRDY-Bit)*/
  while((statusByte & 0x01) != 1) {
    errCode = %'ModuleName'%.%ReadByte(%'ModuleName'%.STATUS_REG, &statusByte);
    if(errCode != ERR_OK) {
      return errCode;
    }
    %@Wait@'ModuleName'%.Waitus(1);
  }
  /*Read accel values*/
  errCode = (%'ModuleName'%.%ReadBlock(%'ModuleName'%.X_AXIS_REG, (byte*)rawAccel, sizeof(rawAccel)));
  if(errCode != ERR_OK) {
    return errCode;
  }
  for(i=0;i<3;i++) {
    accel[i] = (int16_t)(rawAccel[i]*1000/64);
  }
  return errCode;
}

%endif %- GetXYZmg
%-BW_METHOD_END GetXYZmg
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
  /* Write code here ... */
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This component is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-

%-Driver generated by the Bean Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Bean Wizard
%- If you change these lines, Bean Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    27.12.2009
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%define! Description_GetCalibrationPoint 
%define! Description_FctElementTouched Iterator callback, returns TRUE if element has been touched.
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\TouchScreenSettings.Inc
%define! Abstract Common\TouchScreenAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"

typedef %@Display@'ModuleName'%.PixelDim   %'ModuleName'%.PixelDim;%>40/* type to hold a pixel coordinate */
typedef %@Display@'ModuleName'%.PixelColor %'ModuleName'%.PixelColor;%>40/* type to hold color information for a pixel */
typedef %@TouchScreenSensor@'ModuleName'%.TouchSensorValue %'ModuleName'%.TouchSensorValue;%>40/* type to hold a touch sensor value */
typedef enum {
  %'ModuleName'_TOUCHSCREEN_EVENT_TOUCH,                         %>40/* event called if the press of a touch pen has been detected */
  %'ModuleName'_TOUCHSCREEN_EVENT_MOVE,                          %>40/* event for moving a touched pen */
  %'ModuleName'_TOUCHSCREEN_EVENT_RELEASE                        %>40/* event for releasing a touch pen */
} %'ModuleName'%.TouchScreenEvent;

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
%-BW_CUSTOM_USERTYPE_END


%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetPosition
%ifdef GetPosition
bool %'ModuleName'%.%GetPosition(%'ModuleName'_PixelDim *TouchPositionX, %'ModuleName'_PixelDim *TouchPositionY);
%define! ParTouchPositionX
%define! ParTouchPositionY
%define! RetVal
%include Common\TouchScreenGetPosition.Inc

%endif %- GetPosition
%-BW_METHOD_END GetPosition
%-************************************************************************************************************
%-BW_METHOD_BEGIN Calibrate
%ifdef Calibrate
void %'ModuleName'%.%Calibrate(%'ModuleName'_PixelColor fgColor, %'ModuleName'_PixelColor bgColor);
%define! ParfgColor
%define! ParbgColor
%include Common\TouchScreenCalibrate.Inc

%endif %- Calibrate
%-BW_METHOD_END Calibrate
%-************************************************************************************************************
%-BW_METHOD_BEGIN Scan
%ifdef Scan
void %'ModuleName'%.%Scan(void);
%include Common\TouchScreenScan.Inc

%endif %- Scan
%-BW_METHOD_END Scan
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawCalibrationPoint
%ifdef DrawCalibrationPoint
void %'ModuleName'%.%DrawCalibrationPoint(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelColor color);
%define! Parx
%define! Pary
%define! Parcolor
%include Common\TouchScreenDrawCalibrationPoint.Inc

%endif %- DrawCalibrationPoint
%-BW_METHOD_END DrawCalibrationPoint
%-************************************************************************************************************
%-BW_METHOD_BEGIN isCalibrated
%ifdef isCalibrated
bool %'ModuleName'%.%isCalibrated(void);
%define! RetVal
%include Common\TouchScreenisCalibrated.Inc

%endif %- isCalibrated
%-BW_METHOD_END isCalibrated
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetCalibrationData
%ifdef GetCalibrationData
void %'ModuleName'%.%GetCalibrationData(byte **calibDataP, byte *nofBytes);
%define! ParcalibData
%define! ParnofBytes
%include Common\TouchScreenGetCalibrationData.Inc

%endif %- GetCalibrationData
%-BW_METHOD_END GetCalibrationData
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetCalibrationData
%ifdef SetCalibrationData
void %'ModuleName'%.%SetCalibrationData(byte *calibData, byte nofBytes);
%define! ParcalibData
%define! ParnofBytes
%include Common\TouchScreenSetCalibrationData.Inc

%endif %- SetCalibrationData
%-BW_METHOD_END SetCalibrationData
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
void %'ModuleName'%.%Init(void);
%include Common\TouchScreenInit.Inc

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetPositionRaw
%ifdef GetPositionRaw
bool %'ModuleName'%.%GetPositionRaw(%'ModuleName'_TouchSensorValue *RawTouchPositionX, %'ModuleName'_TouchSensorValue *RawTouchPositionY);
%define! ParRawTouchPositionX
%define! ParRawTouchPositionY
%define! RetVal
%include Common\TouchScreenGetPositionRaw.Inc

%endif %- GetPositionRaw
%-BW_METHOD_END GetPositionRaw
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_METHOD_BEGIN OnEvent
%ifdef OnEvent
%INTERFACE OnEvent
void %OnEvent(%'ModuleName'_TouchScreenEvent event, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y);
%define! Parevent
%define! Parx
%define! Pary
%include Common\TouchScreenOnEvent.Inc

%endif %- OnEvent
%-BW_METHOD_END OnEvent
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\TouchScreenSettings.Inc
%define! Abstract Common\TouchScreenAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;

typedef struct {
  bool ScreenCalibrated;
  %'ModuleName'_TouchSensorValue TouchScreenXoffset;
  %'ModuleName'_TouchSensorValue TouchScreenYoffset;
  word TouchScreenXBitsPerPixelx10;
  word TouchScreenYBitsPerPixelx10;
} %'ModuleName'%.TOUCHSCREEN_CALIB;

static %'ModuleName'%.TOUCHSCREEN_CALIB %'ModuleName'%.touchScreenCalib =
%if DefaultCalibrationEnabled='yes'
  {TRUE, %CalibrationXoffset, %CalibrationYoffset, %CalibrationXBitsPerPixelx10, %CalibrationYBitsPerPixelx10};
%else
  {FALSE, 0, 0, 0, 0};
%endif

#define %'ModuleName'_CALIB_CROSS_SIZE   %CrossHairSize          %>40/* size of crosshair */
#define %'ModuleName'_CALIB_CROSS_BORDER %CrossHairBorderDistance%>40/* distance of crosshair (border) and display border */
#define %'ModuleName'_CALIB_CROSS_OFFSET (%'ModuleName'_CALIB_CROSS_BORDER+%'ModuleName'_CALIB_CROSS_SIZE/2)%>40/* distance of crosshair center and display border */

%ifdef UI
typedef %@UI@'ModuleName'%.Screen  %'ModuleName'_Screen;
typedef %@UI@'ModuleName'%.Window  %'ModuleName'_Window;
typedef %@UI@'ModuleName'%.Element %'ModuleName'_Element;
%else
typedef int*  %'ModuleName'_Screen;
typedef int*  %'ModuleName'_Window;
typedef int*  %'ModuleName'_Element;
%endif
typedef void* %'ModuleName'_PVoid;

%-
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-UNLOCKED
/* Internal method prototypes */
%-INTERNAL_LOC_METHOD_BEG GetCalibrationPoint
static void GetCalibrationPoint(byte ix, %'ModuleName'_TouchSensorValue *X, %'ModuleName'_TouchSensorValue *Y, %'ModuleName'_PixelColor fgColor, %'ModuleName'_PixelColor bgColor);
%-INTERNAL_LOC_METHOD_END GetCalibrationPoint
%-INTERNAL_LOC_METHOD_BEG FctElementTouched
static bool FctElementTouched(%'ModuleName'_Screen *screen, %'ModuleName'_Window *window, %'ModuleName'_Element *element, %'ModuleName'_PVoid data);
%-INTERNAL_LOC_METHOD_END FctElementTouched
%-

%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetPositionRaw
%ifdef GetPositionRaw
%define! ParRawTouchPositionX
%define! ParRawTouchPositionY
%define! RetVal
%include Common\TouchScreenGetPositionRaw.Inc
bool %'ModuleName'%.%GetPositionRaw(%'ModuleName'_TouchSensorValue *RawTouchPositionX, %'ModuleName'_TouchSensorValue *RawTouchPositionY)
{
  /* Read raw touch position */
  return %@TouchScreenSensor@'ModuleName'%.GetPositionRaw(RawTouchPositionX, RawTouchPositionY);
}

%endif %- GetPositionRaw
%-BW_METHOD_END GetPositionRaw
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetPosition
%ifdef GetPosition
%define! ParTouchPositionX
%define! ParTouchPositionY
%define! RetVal
%include Common\TouchScreenGetPosition.Inc
bool %'ModuleName'%.%GetPosition(%'ModuleName'_PixelDim *TouchPositionX, %'ModuleName'_PixelDim *TouchPositionY)
{
  /* Declare and initialize local variables */
  bool ScreenTouch;
  %'ModuleName'_PixelDim Temp, x, y;
  %@TouchScreenSensor@'ModuleName'%.TouchSensorValue xVal, yVal;

  /* Read raw touch position into *TouchPositionX and *TouchPositionY */
  ScreenTouch = %@TouchScreenSensor@'ModuleName'%.GetPositionRaw(&xVal, &yVal);
  /* Has screen been touched? */
  if (ScreenTouch && %'ModuleName'%.touchScreenCalib.ScreenCalibrated) {
    /* Screen has been touched and calibrated. Is xVal offset > touch position? */
    if (%'ModuleName'%.touchScreenCalib.TouchScreenXoffset > xVal) {
      /* Offset > touch position. Force Touch position = offset */
      x = 0;
    } else {
      /* Adjust coordinates using screen calibration data */
      x = (%'ModuleName'_PixelDim)(((xVal-%'ModuleName'%.touchScreenCalib.TouchScreenXoffset)*10) /
           %'ModuleName'%.touchScreenCalib.TouchScreenXBitsPerPixelx10);
      /* Transform touch coordinates to display position  */
      if (x > %@Display@'ModuleName'%.GetLongerSide()) {
        x = %@Display@'ModuleName'%.GetLongerSide();
      }
    }
    /* Is yVal offset > touch position? */
    if (%'ModuleName'%.touchScreenCalib.TouchScreenYoffset > yVal) {
      /* Offset > touch position. Force Touch position = offset */
      y = 0;
    } else {
      /* Adjust coordinates using screen calibration data */
      y = (%'ModuleName'_PixelDim)(((yVal - %'ModuleName'%.touchScreenCalib.TouchScreenYoffset)*10) /
          %'ModuleName'%.touchScreenCalib.TouchScreenYBitsPerPixelx10);
      /* Transform touch coordinates to display position */
      if (y > %@Display@'ModuleName'%.GetShorterSide()) {
        y = %@Display@'ModuleName'%.GetShorterSide();
      }
    }
    /* convert coordinations to right orientation of LCD */
    switch(%@Display@'ModuleName'%.GetDisplayOrientation()) {
      case %@Display@'ModuleName'%.ORIENTATION_PORTRAIT:
        Temp = x;
        x = y;
        y = (%'ModuleName'_PixelDim)(%@Display@'ModuleName'%.GetLongerSide()-Temp);
        break;
      case %@Display@'ModuleName'%.ORIENTATION_PORTRAIT180:
        Temp = x;
        x = (%'ModuleName'_PixelDim)(%@Display@'ModuleName'%.GetShorterSide()-y);
        y = Temp;
        break;
      case %@Display@'ModuleName'%.ORIENTATION_LANDSCAPE:
        x = (%'ModuleName'_PixelDim)(%@Display@'ModuleName'%.GetLongerSide()-x);
        y = (%'ModuleName'_PixelDim)(%@Display@'ModuleName'%.GetShorterSide()-y);
        break;
      case %@Display@'ModuleName'%.ORIENTATION_LANDSCAPE180:
        /* nothing to do */
        break;
     }
     *TouchPositionX = x;
     *TouchPositionY = y;
    }
    /* Return flag to indicate if screen has been touched */
    return ScreenTouch;
}

%endif %- GetPosition
%-BW_METHOD_END GetPosition
%-************************************************************************************************************
%-BW_METHOD_BEGIN DrawCalibrationPoint
%ifdef DrawCalibrationPoint
%define! Parx
%define! Pary
%define! Parcolor
%include Common\TouchScreenDrawCalibrationPoint.Inc
void %'ModuleName'%.%DrawCalibrationPoint(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelColor color)
{
  %@Display@'ModuleName'%.DrawHLine(
    (%'ModuleName'_PixelDim)(x-(%'ModuleName'_CALIB_CROSS_SIZE/2)),
    y,
    %'ModuleName'_CALIB_CROSS_SIZE,
    color);
  %@Display@'ModuleName'%.DrawVLine(
    x,
    (%'ModuleName'_PixelDim)(y-(%'ModuleName'_CALIB_CROSS_SIZE/2)),
    %'ModuleName'_CALIB_CROSS_SIZE,
    color);
}

%endif %- DrawCalibrationPoint
%-BW_METHOD_END DrawCalibrationPoint
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG GetCalibrationPoint
%define! Parix
%define! ParX
%define! ParY
%define! ParfgColor
%define! ParbgColor
%include Common\GeneralInternalGlobal.inc (GetCalibrationPoint)
static void GetCalibrationPoint(byte ix, %'ModuleName'_TouchSensorValue *X, %'ModuleName'_TouchSensorValue *Y, %'ModuleName'_PixelColor fgColor, %'ModuleName'_PixelColor bgColor)
{
  %'ModuleName'_PixelDim tmp_x, tmp_y;

  tmp_x = %@Display@'ModuleName'%.GetWidth();
  tmp_y = %@Display@'ModuleName'%.GetHeight();
  switch(ix) {
    case 0:
      tmp_x = %'ModuleName'%.CALIB_CROSS_OFFSET;
      tmp_y = %'ModuleName'%.CALIB_CROSS_OFFSET;
      break;
    case 1:
      tmp_x /= 2;
      tmp_y /= 2;
      break;
    case 2:
      tmp_x -= %'ModuleName'%.CALIB_CROSS_OFFSET;
      tmp_y -= %'ModuleName'%.CALIB_CROSS_OFFSET;
      break;
  } /* switch */
  %'ModuleName'%.DrawCalibrationPoint(tmp_x, tmp_y, fgColor);    %>40/* draw calibration cross */
  while (!%@TouchScreenSensor@'ModuleName'%.GetPositionRaw(X, Y)) {
%if %useRTOSWait='yes'
      %@Wait@'ModuleName'%.WaitOSms(1);
%else
      %@Wait@'ModuleName'%.Waitms(1);
%endif
  }
  %'ModuleName'%.DrawCalibrationPoint(tmp_x, tmp_y, bgColor);    %>40/* remove calibration cross */
}

%-INTERNAL_METHOD_END GetCalibrationPoint
%-************************************************************************************************************
%-BW_METHOD_BEGIN Calibrate
%ifdef Calibrate
%define! ParfgColor
%define! ParbgColor
%include Common\TouchScreenCalibrate.Inc
void %'ModuleName'%.%Calibrate(%'ModuleName'_PixelColor fgColor, %'ModuleName'_PixelColor bgColor)
{
  #define %'ModuleName'_NOF_CALIBRATION  3  /* number of touch points for calibration */
  %'ModuleName'_TouchSensorValue X[%'ModuleName'_NOF_CALIBRATION], Y[%'ModuleName'_NOF_CALIBRATION];
  bool CalibrationComplete = FALSE;
  byte tmp_i;
%if CalibrationFontEnabled='yes'
  unsigned char str_touch[sizeof("X1:00000")];
  %@FontDisplay@'ModuleName'%.PixelDim xCursor, yCursor, charHeight, totalHeight;
  #define %'ModuleName'_NOF_TEXT_LINES  (1+%'ModuleName'_NOF_CALIBRATION)  /* one for the instruction text plus the calibration points */
%endif

  /* Set touchscreen calibrated flag to FALSE */
  %'ModuleName'_touchScreenCalib.ScreenCalibrated = FALSE;
  while (!%'ModuleName'_touchScreenCalib.ScreenCalibrated) {
  /* clear screen */
    %@Display@'ModuleName'%.DrawFilledBox(0, 0, %@Display@'ModuleName'%.GetWidth(), %@Display@'ModuleName'%.GetHeight(), bgColor);
%if CalibrationFontEnabled='yes'
    /* write instruction text for the user */
    %@FontDisplay@'ModuleName'%.GetFontHeight(%@CalibrationFont@'ModuleName'%.GetFont(), &charHeight, &totalHeight);
    xCursor = %'ModuleName'_CALIB_CROSS_BORDER;
    yCursor = (%@FontDisplay@'ModuleName'%.PixelDim)(%@Display@'ModuleName'%.GetHeight()-%'ModuleName'_NOF_TEXT_LINES*totalHeight-%'ModuleName'_CALIB_CROSS_BORDER);
    %@FontDisplay@'ModuleName'%.WriteString((unsigned char*)"%CalibrationTextMessage", fgColor, &xCursor, &yCursor, %@CalibrationFont@'ModuleName'%.GetFont());
%endif
    /* Capture input calibration points */
    for(tmp_i=0; tmp_i<%'ModuleName'_NOF_CALIBRATION; tmp_i++) {
      GetCalibrationPoint(tmp_i, &X[tmp_i], &Y[tmp_i], fgColor, bgColor);
%if CalibrationFontEnabled='yes'
      str_touch[0] = 'X';
      str_touch[1] = (char)('1' + tmp_i);
      str_touch[2] = ':';
      str_touch[3] = '\0';
      %@Utility@'ModuleName'%.strcatNum16sFormatted(str_touch, sizeof(str_touch), (int16_t)X[tmp_i], '0', 5);
      xCursor = %'ModuleName'_CALIB_CROSS_BORDER;
      yCursor = (%@FontDisplay@'ModuleName'%.PixelDim)(%@Display@'ModuleName'%.GetHeight()-(%'ModuleName'_NOF_CALIBRATION-tmp_i)*totalHeight-%'ModuleName'_CALIB_CROSS_BORDER);
      %@FontDisplay@'ModuleName'%.WriteString(str_touch, fgColor, &xCursor, &yCursor, %@CalibrationFont@'ModuleName'%.GetFont());
      str_touch[0] = 'Y';
      str_touch[1] = (char)('1' + tmp_i);
      str_touch[2] = ':';
      str_touch[3] = '\0';
      %@Utility@'ModuleName'%.strcatNum16sFormatted(str_touch, sizeof(str_touch), (int16_t)Y[tmp_i], '0', 5);
      xCursor += 5;
      %@FontDisplay@'ModuleName'%.WriteString(str_touch, fgColor, &xCursor, &yCursor, %@CalibrationFont@'ModuleName'%.GetFont());
%endif
%if %useRTOSWait='yes'
      %@Wait@'ModuleName'%.WaitOSms(500);                        %>40/* wait some time to debounce */
%else
      %@Wait@'ModuleName'%.Waitms(500);                          %>40/* wait some time to debounce */
%endif
    }
    /* convert captured values into Landscape orientation */
    switch(%@Display@'ModuleName'%.GetDisplayOrientation()) {
      %'ModuleName'_TouchSensorValue tmp_coor;

      case %@Display@'ModuleName'%.ORIENTATION_LANDSCAPE180:
        tmp_coor = X[0];
        X[0] = X[2];
        X[2] = tmp_coor;
        tmp_coor = Y[0];
        Y[0] = Y[2];
        Y[2] = tmp_coor;
        break;
      case %@Display@'ModuleName'%.ORIENTATION_PORTRAIT:
        tmp_coor = Y[0];
        Y[0] = Y[2];
        Y[2] = tmp_coor;
        break;
      case %@Display@'ModuleName'%.ORIENTATION_PORTRAIT180:
        tmp_coor = X[0];
        X[0] = X[2];
        X[2] = tmp_coor;
        break;
      case %@Display@'ModuleName'%.ORIENTATION_LANDSCAPE:
      default:
        break;
    } /* switch */
    /* Check X1 > X2 > X3 and Y1 > Y2 > Y3 */
    if ((X[0] > X[1]) && (X[1] > X[2]) && (Y[0] > Y[1]) && (Y[1] > Y[2])) {
      %'ModuleName'_TouchSensorValue dX, dY;

      /* Calculate ADC bits between X1 and X3 */
      dX = (%'ModuleName'_TouchSensorValue)(X[0]-X[2]);
      /* Calculate ADC bits between Y1 and Y3 */
      dY = (%'ModuleName'_TouchSensorValue)(Y[0]-Y[2]);
      /* Calculate number of (bits / pixel) * 10 for X */
      %'ModuleName'_touchScreenCalib.TouchScreenXBitsPerPixelx10 = (word)((dX * 10)/(%@Display@'ModuleName'%.GetLongerSide() - %'ModuleName'%.CALIB_CROSS_OFFSET * 2));
      /* Does number of ADC bits per pixel in X seem reasonable? */
      if (%'ModuleName'_touchScreenCalib.TouchScreenXBitsPerPixelx10 < ((10 * %@TouchScreenSensor@'ModuleName'%.FULL_SCALE) / %@Display@'ModuleName'%.GetLongerSide()))
      {
        /* Calculate number of (bits / pixel) * 10 for Y */
        %'ModuleName'_touchScreenCalib.TouchScreenYBitsPerPixelx10 = (word)((dY * 10)/(%@Display@'ModuleName'%.GetShorterSide() - %'ModuleName'%.CALIB_CROSS_OFFSET * 2));

        /* Does number of ADC bits per pixel in Y seem reasonable? */
        if (%'ModuleName'_touchScreenCalib.TouchScreenYBitsPerPixelx10 < ((10 * %@TouchScreenSensor@'ModuleName'%.FULL_SCALE) / %@Display@'ModuleName'%.GetShorterSide()))
        {
          /* Calculate LCD Y offset */
          %'ModuleName'_touchScreenCalib.TouchScreenYoffset = (%'ModuleName'_TouchSensorValue)((Y[2] * 10 - %'ModuleName'%.CALIB_CROSS_OFFSET * %'ModuleName'%.touchScreenCalib.TouchScreenYBitsPerPixelx10) / 10);
          /* Calculate LCD X offset */
          %'ModuleName'_touchScreenCalib.TouchScreenXoffset = (%'ModuleName'_TouchSensorValue)((X[2] * 10 - %'ModuleName'%.CALIB_CROSS_OFFSET * %'ModuleName'%.touchScreenCalib.TouchScreenXBitsPerPixelx10) / 10);
          /* Is screen offset in X and Y reasonable? */
          if (%'ModuleName'_touchScreenCalib.TouchScreenYoffset < %@TouchScreenSensor@'ModuleName'%.Y_TOUCH_OFFMAX && %'ModuleName'%.touchScreenCalib.TouchScreenXoffset < %@TouchScreenSensor@'ModuleName'%.X_TOUCH_OFFMAX)
          {
            /* Set flag to indicate touch screen calibrated */
            %'ModuleName'_touchScreenCalib.ScreenCalibrated = TRUE;
          }
        }
      }
    }
  }
}

%endif %- Calibrate
%-BW_METHOD_END Calibrate
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG FctElementTouched
%define! Parscreen
%define! Parwindow
%define! Parelement
%define! Pardata
%define! RetVal
%include Common\GeneralInternalGlobal.inc (FctElementTouched)
%if UserInterfaceEnabled='yes'
static bool FctElementTouched(%'ModuleName'_Screen *screen, %'ModuleName'_Window *window, %'ModuleName'_Element *element, %'ModuleName'_PVoid data)
{
  %@UI@'ModuleName'%.Coordinate *coord = (%@UI@'ModuleName'%.Coordinate*)data;
  (void)screen;                                                  %>40/* argument not used */

  return (   (element->prop.flags&%@UI@'ModuleName'%.FLAGS_CAN_SELECT)%>40/* can element be selected? */
          && coord->x>=%@UI@'ModuleName'%.GetElementPosX(window)
             && coord->x<=%@UI@'ModuleName'%.GetElementPosX(window)+%@UI@'ModuleName'%.GetElementWidth(window)%>40/* x inside window? */
          && coord->y>=%@UI@'ModuleName'%.GetElementPosY(window)
             && coord->y<=%@UI@'ModuleName'%.GetElementPosY(window)+%@UI@'ModuleName'%.GetElementHeight(window)%>40/* y inside window? */
          && coord->x>=%@UI@'ModuleName'%.GetElementPosX(window)+%@UI@'ModuleName'%.GetElementPosX(element)
          && coord->x<=%@UI@'ModuleName'%.GetElementPosX(window)+%@UI@'ModuleName'%.GetElementPosX(element)+%@UI@'ModuleName'%.GetElementWidth(element)%>40/* x inside element? */
          && coord->y>=%@UI@'ModuleName'%.GetElementPosY(window)+%@UI@'ModuleName'%.GetElementPosY(element)
          && coord->y<=%@UI@'ModuleName'%.GetElementPosY(window)+%@UI@'ModuleName'%.GetElementPosY(element)+%@UI@'ModuleName'%.GetElementHeight(element)%>40/* y inside element? */
          );
}
%endif %-UserInterfaceEnabled='yes'

%-INTERNAL_METHOD_END FctElementTouched
%-************************************************************************************************************
%-BW_METHOD_BEGIN Scan
%ifdef Scan
%include Common\TouchScreenScan.Inc
void %'ModuleName'%.%Scan(void)
{
%if UserInterfaceEnabled='no'
  typedef struct {                                               %>40/* x,y screen coordinates */
    word x, y;                                                   %>40/* x,y screen coordinates */
  } Coordinate;
%endif
  static struct {
    bool pressed;
%if UserInterfaceEnabled='yes'
    %@UI@'ModuleName'%.Coordinate coord;                         %>40/* x,y screen coordinates */
%else
    Coordinate coord;
%endif
  } prevState = {FALSE, 0, 0};                                   %>40/* previous state */
  bool pressed;
%if UserInterfaceEnabled='yes'
  %@UI@'ModuleName'%.Coordinate coord;                           %>40/* current screen coordinates */
  %@UI@'ModuleName'%.Coordinate winCoord;                        %>40/* current screen coordinates */
  %@UI@'ModuleName'%.Element *element;
  %@UI@'ModuleName'%.Window *window;
%else
  Coordinate coord;                                              %>40/* current screen coordinates */
%endif

  pressed = %'ModuleName'%.%GetPosition(&coord.x, &coord.y);
  if (pressed && !prevState.pressed) {
  %if defined(OnEvent)
    %OnEvent(%'ModuleName'_TOUCHSCREEN_EVENT_TOUCH, coord.x, coord.y);%>40/* call user event */
  %endif
  %if UserInterfaceEnabled='yes'
    if (%@UI@'ModuleName'%.FindElement(%@UI@'ModuleName'%.GetScreen(), &window, &element, FctElementTouched, (void*)&coord)) {
      winCoord.x = (%@UI@'ModuleName'%.PixelDim)(coord.x-%@UI@'ModuleName'%.GetElementPosX(window));%>40/* transform into window coordinates */
      winCoord.y = (%@UI@'ModuleName'%.PixelDim)(coord.y-%@UI@'ModuleName'%.GetElementPosY(window));%>40/* transform into window coordinates */
      %@UI@'ModuleName'%.ClickElement(%@UI@'ModuleName'%.GetScreen(), window, element, UI1_EVENT_CLICK, &winCoord);
    } else {
      %@UI@'ModuleName'%.ClickElement(%@UI@'ModuleName'%.GetScreen(), NULL, NULL, UI1_EVENT_CLICK, NULL);
    }
  %endif
    prevState.pressed = pressed;
    prevState.coord = coord;
  } else if (pressed && prevState.pressed && coord.x!=prevState.coord.x && coord.y!=prevState.coord.y) {
  %if defined(OnEvent)
    %OnEvent(%'ModuleName'_TOUCHSCREEN_EVENT_MOVE, coord.x, coord.y);
  %endif
  %if UserInterfaceEnabled='yes'
    if (%@UI@'ModuleName'%.FindElement(%@UI@'ModuleName'%.GetScreen(), &window, &element, FctElementTouched, (void*)&coord)) {
      winCoord.x = (%@UI@'ModuleName'%.PixelDim)(coord.x-%@UI@'ModuleName'%.GetElementPosX(window));%>40/* transform into window coordinates */
      winCoord.y = (%@UI@'ModuleName'%.PixelDim)(coord.y-%@UI@'ModuleName'%.GetElementPosY(window));%>40/* transform into window coordinates */
      %@UI@'ModuleName'%.ClickElement(%@UI@'ModuleName'%.GetScreen(), window, element, UI1_EVENT_CLICK_MOVE, (%@UI@'ModuleName'%.Pvoid)&winCoord);
    } else {
      %@UI@'ModuleName'%.ClickElement(%@UI@'ModuleName'%.GetScreen(), NULL, NULL, UI1_EVENT_CLICK_MOVE, NULL);
    }
  %endif
    prevState.pressed = pressed;
    prevState.coord = coord;
  } else if (!pressed && prevState.pressed) {
  %if defined(OnEvent)
    %OnEvent(%'ModuleName'_TOUCHSCREEN_EVENT_RELEASE, prevState.coord.x, prevState.coord.y);
  %endif
  %if UserInterfaceEnabled='yes'
    if (%@UI@'ModuleName'%.FindElement(%@UI@'ModuleName'%.GetScreen(), &window, &element, FctElementTouched, (void*)&prevState.coord)) {
      winCoord.x = (%@UI@'ModuleName'%.PixelDim)(prevState.coord.x-%@UI@'ModuleName'%.GetElementPosX(window));%>40/* transform into window coordinates */
      winCoord.y = (%@UI@'ModuleName'%.PixelDim)(prevState.coord.y-%@UI@'ModuleName'%.GetElementPosY(window));%>40/* transform into window coordinates */
      %@UI@'ModuleName'%.ClickElement(%@UI@'ModuleName'%.GetScreen(), window, element, UI1_EVENT_CLICK_RELEASE, &winCoord);
    } else {
      %@UI@'ModuleName'%.ClickElement(%@UI@'ModuleName'%.GetScreen(), NULL, NULL, UI1_EVENT_CLICK_RELEASE, NULL);
    }
  %endif
    prevState.pressed = FALSE;
    prevState.coord.x = 0;
    prevState.coord.y = 0;
  }
}

%endif %- Scan
%-BW_METHOD_END Scan
%-************************************************************************************************************
%-BW_METHOD_BEGIN isCalibrated
%ifdef isCalibrated
%define! RetVal
%include Common\TouchScreenisCalibrated.Inc
bool %'ModuleName'%.%isCalibrated(void)
{
  return %'ModuleName'_touchScreenCalib.ScreenCalibrated;        %>40/* return current calibration status */
}

%endif %- isCalibrated
%-BW_METHOD_END isCalibrated
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetCalibrationData
%ifdef GetCalibrationData
%define! ParcalibData
%define! ParnofBytes
%include Common\TouchScreenGetCalibrationData.Inc
void %'ModuleName'%.%GetCalibrationData(byte **calibDataP, byte *nofBytes)
{
  *calibDataP = (byte*)&%'ModuleName'%.touchScreenCalib;
  *nofBytes = sizeof(%'ModuleName'%.touchScreenCalib);
}

%endif %- GetCalibrationData
%-BW_METHOD_END GetCalibrationData
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetCalibrationData
%ifdef SetCalibrationData
%define! ParcalibData
%define! ParnofBytes
%include Common\TouchScreenSetCalibrationData.Inc
void %'ModuleName'%.%SetCalibrationData(byte *calibData, byte nofBytes)
{
  if (nofBytes == sizeof(%'ModuleName'%.touchScreenCalib)) {     %>40/* safety check... */
    %'ModuleName'%.touchScreenCalib = *((%'ModuleName'%.TOUCHSCREEN_CALIB*)calibData);
  }
}

%endif %- SetCalibrationData
%-BW_METHOD_END SetCalibrationData
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%include Common\TouchScreenInit.Inc
void %'ModuleName'%.%Init(void)
{
  %@TouchScreenSensor@'ModuleName'%.Init(); /* initialize sensor */
}

%endif %- Init
%-BW_METHOD_END Init
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_METHOD_BEGIN OnEvent
%ifdef OnEvent
%IMPLEMENTATION OnEvent
%define! Parevent
%define! Parx
%define! Pary
%include Common\TouchScreenOnEvent.Inc
void %OnEvent(%'ModuleName'_TouchScreenEvent event, %'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y)
{
  /* Write your code here ... */
}

%endif %- OnEvent
%-BW_METHOD_END OnEvent
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
%if InitializeOnInit='yes'
  %'ModuleName'%.%Init();
%endif
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This bean is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-

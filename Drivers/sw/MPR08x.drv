%-Driver generated by the Bean Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Bean Wizard
%- If you change these lines, Bean Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    08.10.2008
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%define! Description_WriteRegister 
%define! Description_ReadRegister Reads a register value from the device
%define! Description_Init Device initialization routine.
%ifdef IRQ
  %ifdef @IRQ@OnInterrupt
    %define! Description_%@IRQ@OnInterrupt This event is called when an active signal edge/level has occurred. The event services the event of the inherited component and eventually invokes other events.
  %endif %- @IRQ@OnInterrupt
%endif %- IRQ
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\MPR08xSettings.Inc
%define! Abstract Common\MPR08xAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"

%ifdef @IRQ@OnInterrupt
#define %'ModuleName'%.INTERRUPTS_ENABLED  1 /* Device generates interrupts and %'ModuleName'%.%ProcessTouch() is called automatically by the ISR. */
%else
#define %'ModuleName'%.INTERRUPTS_ENABLED  0 /* Device does not generate interrupts. You need to call %'ModuleName'%.%ProcessTouch() from your application to poll sensor data. */
%endif

%if %MPRDeviceType = 'MPR083'
/* MPR083 registers */
#define FIFO_REGISTER                              0x00
#define FAULT_REGISTER                             0x01
#define PAD_STATUS_REGISTER                        0x02
#define PAD_CONFIGURATION_REGISTER                 0x03
#define SENSITIVITY_REGISTER                       0x04
#define MASTER_TICK_COUNTER_REGISTER               0x05
#define TOUCH_ACQUISITION_SAMPLE_PERIOD_REGISTER   0x06
#define SOUNDER_CONFIGURATION_REGISTER             0x07
#define LOW_POWER_CONFIGURATION_REGISTER           0x08
#define STUCK_KEY_TIMEOUT_REGISTER                 0x09
#define CONFIGURATION_REGISTER                     0x0A
#define SENSOR_INFORMATION_REGISTER                0x0B
%elif %MPRDeviceType = 'MPR084'
/* MPR084 registers */
#define FIFO_REGISTER                              0x00
#define FAULT_REGISTER                             0x01
#define PAD_STATUS_REGISTER                        0x02
#define PAD_CONFIGURATION_REGISTER                 0x03
#define SENSITIVITY_1_REGISTER                     0x04
#define SENSITIVITY_2_REGISTER                     0x05
#define SENSITIVITY_3_REGISTER                     0x06
#define SENSITIVITY_4_REGISTER                     0x07
#define SENSITIVITY_5_REGISTER                     0x08
#define SENSITIVITY_6_REGISTER                     0x09
#define SENSITIVITY_7_REGISTER                     0x0A
#define SENSITIVITY_8_REGISTER                     0x0B
#define ELECTRODE_CHANNEL_ENABLE_REGISTER          0x0C
#define MAX_NOF_TOUCH_POSITION_REGISTER            0x0D
#define MASTER_TICK_COUNTER_REGISTER               0x0E
#define TOUCH_ACQUISITION_SAMPLE_PERIOD_REGISTER   0x0F
#define SOUNDER_CONFIGURATION_REGISTER             0x10
#define LOW_POWER_CONFIGURATION_REGISTER           0x11
#define STUCK_KEY_TIMEOUT_REGISTER                 0x12
#define CONFIGURATION_REGISTER                     0x13
#define SENSOR_INFORMATION_REGISTER                0x14
%endif

/* various defines to make access to the register bits easier: */
/* --- CONFIGURATION_REGISTER --- */
#define CONFIGURATION_REG_RUNE    0x01 /* Run Mode Enable - The Run Mode Enable bit enables or disables scanning of the
                                             electrodes for touch detection. This bit is active high.
                                             0 Electrode Scanning Disabled (Stop modes)
                                             1 Electrode Scanning Enabled (Run modes) */
#define CONFIGURATION_REG_IRQEN   0x02 /* Interrupt Enable - The Interrupt Enable bit enables or disables the IRQ
                                             Functionality.
                                             0 IRQ Disabled
                                             1 IRQ Enabled */
#define CONFIGURATION_REG_DCE_NOT 0x04 /* Duty Cycle Enable - The Duty Cycle Enable bit enables or disables duty cycling on
                                             the sensor. This bit is active low.
                                             0 Duty Cycle Enabled (2 modes)
                                             1 Duty Cycle Disabled (1 modes) */
#define CONFIGURATION_REG_RST_NOT 0x10 /* Reset - Asserts a global reset of the sensor controller.
                                             0 Reset Asserted
                                             1 Reset Not Asserted */
/* --- SOUNDER_CONFIGURATION_REGISTER --- */
#define SOUNDER_FREQ_1kHZ   0  /* value for 1 kHz frequency for sounder */
#define SOUNDER_FREQ_2kHZ   1  /* value for 2 kHz frequency for sounder */
#define SOUNDER_CLICK_10ms  0  /* value for a 10 ms click period for sounder */
#define SOUNDER_CLICK_20ms  1  /* value for a 20 ms click period for sounder */

/* error code for 'OnFault' event */
#define ON_MPR08x_FAULT_NONE            0       /* Reserved for no fault */
#define ON_MPR08x_FAULT_SHORT_VSS       (1<<0)  /* Short to VSS detected (Fault register) */
#define ON_MPR08x_FAULT_SHORT_VDD       (1<<1)  /* Short to VDD detected (Fault register) */
#define ON_MPR08x_I2C_MAX_KEYS_ERROR    (1<<2)  /* MNKE: Maximum number of keys exceeded, only for MPR084 */
#define ON_MPR08x_FAULT_FIFO_OVL        5       /* FIFO Overflow (FIFO register) */
#define ON_MPR08x_I2C_SEND_ERROR        6       /* I2C Fatal error during sending */
#define ON_MPR08x_I2C_RECEIVE_ERROR     7       /* I2C Fatal error during receiving */
#define ON_MPR08x_I2C_SELECT_ERROR      8       /* I2C Fatal error during slave select */

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
%-BW_CUSTOM_USERTYPE_END


%-BW_DEFINITION_START
%-************************************************************************************************************
%-************************************************************************************************************
%-************************************************************************************************************
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetSensitivity
%ifdef SetSensitivity
byte %'ModuleName'%.%SetSensitivity(byte sensitivity);
%define! Parsensitivity
%define! RetVal
%include Common\MPR08xSetSensitivity.Inc

%endif %- SetSensitivity
%-BW_METHOD_END SetSensitivity
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetSounder
%ifdef SetSounder
byte %'ModuleName'%.%SetSounder(bool enable, byte clickPeriod, byte frequency);
%define! Parenable
%define! ParclickPeriod
%define! Parfrequency
%define! RetVal
%include Common\MPR08xSetSounder.Inc

%endif %- SetSounder
%-BW_METHOD_END SetSounder
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetSensorInformation
%ifdef GetSensorInformation
byte %'ModuleName'%.%GetSensorInformation(byte *buf, byte bufSize);
%define! Parbuf
%define! ParbufSize
%define! RetVal
%include Common\MPR08xGetSensorInformation.Inc

%endif %- GetSensorInformation
%-BW_METHOD_END GetSensorInformation
%-************************************************************************************************************
%-BW_METHOD_BEGIN ProcessTouch
%ifdef ProcessTouch
void %'ModuleName'%.%ProcessTouch(void);
%include Common\MPR08xProcessTouch.Inc

%endif %- ProcessTouch
%-BW_METHOD_END ProcessTouch
%-INHERITED_EVENT_BEGIN IRQ OnInterrupt
%ifdef @IRQ@OnInterrupt
void %@IRQ@OnInterrupt(void);

%endif %- @IRQ@OnInterrupt
%-INHERITED_EVENT_END IRQ OnInterrupt
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG Init
void %'ModuleName'%.Init(void);
%include Common\GeneralInternal.inc (Init)

%-INTERNAL_METHOD_END Init
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_METHOD_BEGIN OnPress
%ifdef OnPress
%INTERFACE OnPress
void %OnPress(byte button);
%define! Parbutton
%include Common\MPR08xOnPress.Inc

%endif %- OnPress
%-BW_METHOD_END OnPress
%-BW_METHOD_BEGIN OnFault
%ifdef OnFault
%INTERFACE OnFault
void %OnFault(byte reason);
%define! Parreason
%include Common\MPR08xOnFault.Inc

%endif %- OnFault
%-BW_METHOD_END OnFault
%-BW_METHOD_BEGIN OnRelease
%ifdef OnRelease
%INTERFACE OnRelease
void %OnRelease(byte button);
%define! Parbutton
%include Common\MPR08xOnRelease.Inc

%endif %- OnRelease
%-BW_METHOD_END OnRelease
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\MPR08xSettings.Inc
%define! Abstract Common\MPR08xAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%-
%- %if (%RunMode = '1') | (%RunMode = '0') %- needed for Stop2 and Run2 modes of the sensor */
#define TOGGLE_ATTN()   {%@ATTNPin@'ModuleName'%.SetVal();%@Wait@'ModuleName'%.Waitms(20);%@ATTNPin@'ModuleName'%.ClrVal();%@Wait@'ModuleName'%.Waitms(20);%@ATTNPin@'ModuleName'%.SetVal();} /* ATTN pin toggle */
#define CONFIGURATION_REGISTER_SETTINGS    (((%InterruptRate-1)<<5) /* IRQR: Interrupt Request Rate */ \
                                         | CONFIGURATION_REG_RST_NOT /* RST: do not reset device */ \
                                        %if %IRQEnabled = 'yes'
                                         | CONFIGURATION_REG_IRQEN /* IRQEN: enable interrupts */ \
                                        %endif
                                         | %RunMode /* DCE and RUNE */)
%- %endif
/* I2C device address, defined with the AD0 pin of the device: */
%if %MPRDeviceType = 'MPR083' & %AD0low='yes'
#define %'ModuleName'%.I2C_ADDR   0x4C  /* 7bit I2C address of the MPR083 with AD0 pin low */
%elif %MPRDeviceType='MPR083' & %AD0low='no'
#define %'ModuleName'%.I2C_ADDR   0x4D  /* 7bit I2C address of the MPR083 with AD0 pin high */
%elif %MPRDeviceType='MPR084' & %AD0low='yes'
#define %'ModuleName'%.I2C_ADDR   0x5C  /* 7bit I2C address of the MPR084 with AD0 pin low */
%elif %MPRDeviceType='MPR084' & %AD0low='no'
#define %'ModuleName'%.I2C_ADDR   0x5D  /* 7bit I2C address of the MPR084 with AD0 pin high */
%else
  %error unknown device!
%endif

%- %if %UseI2Cinterrupts='yes'
%- static volatile byte OnTransmitDataFlag = 0;
%- static volatile byte OnReceiveDataFlag = 0;
%- %endif
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-UNLOCKED
/* Internal method prototypes */
%-INTERNAL_LOC_METHOD_BEG WriteRegister
static void WriteRegister(byte address, byte data);
%-INTERNAL_LOC_METHOD_END WriteRegister
%-INTERNAL_LOC_METHOD_BEG ReadRegister
static byte ReadRegister(byte address);
%-INTERNAL_LOC_METHOD_END ReadRegister
%-

%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG ReadRegister
%define! Paraddress
%define! RetVal
%include Common\GeneralInternalGlobal.inc (ReadRegister)
static byte ReadRegister(byte address)
{
  byte data, err;

%-  while(%@IC2Interface@'ModuleName'%.CheckBus()==%@IC2Interface@'ModuleName'%.BUSY) {} /* wait until device is ready */
  err = %@IC2Interface@'ModuleName'%.SelectSlave(%'ModuleName'%.I2C_ADDR); /* Set slave address */
  if (err == ERR_DISABLED) { /* hmm, this should not be necessary? */
    (void)%@IC2Interface@'ModuleName'%.Enable();
    err = %@IC2Interface@'ModuleName'%.SelectSlave(%'ModuleName'%.I2C_ADDR);
  }
%if defined(OnFault)
  if (err != ERR_OK) {
    %OnFault(ON_MPR08x_I2C_SELECT_ERROR);
  }
%endif
%- %if %UseI2Cinterrupts='yes'
%-  OnTransmitDataFlag = 0;
%- %endif
  err = %@IC2Interface@'ModuleName'%.SendChar(address); /* send address byte */
%if defined(OnFault)
  if (err != ERR_OK) {
    %OnFault(ON_MPR08x_I2C_SEND_ERROR);
  }
%endif
%-  while(%@IC2Interface@'ModuleName'%.CheckBus()==%@IC2Interface@'ModuleName'%.BUSY) {} /* wait until device is ready */
%-%if %UseI2Cinterrupts='yes'
%-  while(!OnTransmitDataFlag){}
%-  OnReceiveDataFlag = 0;
%-%endif
  err = %@IC2Interface@'ModuleName'%.RecvChar(&data); /* Receive bytes in master mode */
%if defined(OnFault)
  if (err != ERR_OK) {
    %OnFault(ON_MPR08x_I2C_RECEIVE_ERROR);
  }
%endif
%-  while(%@IC2Interface@'ModuleName'%.CheckBus()==%@IC2Interface@'ModuleName'%.BUSY) {} /* wait until device is ready */
%-%if %UseI2Cinterrupts='yes'
%-  while(!OnReceiveDataFlag){}
%-  OnReceiveDataFlag = 0;
%- %endif
  /* Now Data field contains received values */
  return data;
}

%-INTERNAL_METHOD_END ReadRegister
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG WriteRegister
%define! Paraddress
%define! Pardata
%include Common\GeneralInternalGlobal.inc (WriteRegister)
static void WriteRegister(byte address, byte data)
{
  /* send data to slave */
  byte msg[2], err;
  word ret;

%-  while(%@IC2Interface@'ModuleName'%.CheckBus()==%@IC2Interface@'ModuleName'%.BUSY) {} /* wait until device is ready */
  err = %@IC2Interface@'ModuleName'%.SelectSlave(%'ModuleName'%.I2C_ADDR); /* Set slave address */
  if (err == ERR_DISABLED) { /* hmm, this should not be necessary? */
    (void)%@IC2Interface@'ModuleName'%.Enable();
    err = %@IC2Interface@'ModuleName'%.SelectSlave(%'ModuleName'%.I2C_ADDR);
  }
%if defined(OnFault)
  if (err != ERR_OK) {
    %OnFault(ON_MPR08x_I2C_SELECT_ERROR);
  }
%endif
  /* Send bytes in master mode */
  msg[0] = address;
  msg[1] = data;
%-%if %UseI2Cinterrupts='yes'
%-  OnTransmitDataFlag = 0;
%-%endif
%if defined(OnFault)
  err = %@IC2Interface@'ModuleName'%.SendBlock(&msg, sizeof(msg), &ret);
  if (err != ERR_OK) {
    %OnFault(ON_MPR08x_I2C_SEND_ERROR);
  }
%else
  (void)%@IC2Interface@'ModuleName'%.SendBlock(&msg, sizeof(msg), &ret);
%endif
%-  while(%@IC2Interface@'ModuleName'%.CheckBus()==%@IC2Interface@'ModuleName'%.BUSY) {} /* wait until device is ready */
%- %if %UseI2Cinterrupts='yes'
%-  while(!OnTransmitDataFlag){}
%-  OnTransmitDataFlag = 0;
%- %endif
}

%-INTERNAL_METHOD_END WriteRegister
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG Init
%include Common\GeneralInternal.inc (Init)
void %'ModuleName'%.Init(void)
{
  %@Wait@'ModuleName'%.Waitms(50); /* wait some time to ensure device is powered up */
%if %StopI2C = 'yes'
  (void)%@IC2Interface@'ModuleName'%.Enable(); /* turn on I2C Clock */
%endif
  TOGGLE_ATTN(); /* Ensure device is awake */
  WriteRegister(CONFIGURATION_REGISTER, CONFIGURATION_REG_DCE_NOT); /* make a global device reset */
  TOGGLE_ATTN(); /* Ensure device is awake */
  WriteRegister(CONFIGURATION_REGISTER, CONFIGURATION_REG_RST_NOT|CONFIGURATION_REG_DCE_NOT); /* Put in Stop 1 Mode for initial Config */
%if %MPRDeviceType = 'MPR083'
  %if %Sensitivity != '1'  %- only if not power up value
  WriteRegister(SENSITIVITY_REGISTER, %Sensitivity-1); /* Set Sensitivity Threshold */
  %endif
%elif %MPRDeviceType = 'MPR084'
  %if %Sensitivity1 != '1'  %- only if not power up value
  WriteRegister(SENSITIVITY_1_REGISTER, %Sensitivity1-1); /* Set Sensitivity Threshold for button 1 */
  %endif
  %if %Sensitivity2 != '1'  %- only if not power up value
  WriteRegister(SENSITIVITY_2_REGISTER, %Sensitivity2-1); /* Set Sensitivity Threshold for button 2 */
  %endif
  %if %Sensitivity3 != '1'  %- only if not power up value
  WriteRegister(SENSITIVITY_3_REGISTER, %Sensitivity3-1); /* Set Sensitivity Threshold for button 3 */
  %endif
  %if %Sensitivity4 != '1'  %- only if not power up value
  WriteRegister(SENSITIVITY_4_REGISTER, %Sensitivity4-1); /* Set Sensitivity Threshold for button 4 */
  %endif
  %if %Sensitivity5 != '1'  %- only if not power up value
  WriteRegister(SENSITIVITY_5_REGISTER, %Sensitivity5-1); /* Set Sensitivity Threshold for button 5 */
  %endif
  %if %Sensitivity6 != '1'  %- only if not power up value
  WriteRegister(SENSITIVITY_6_REGISTER, %Sensitivity6-1); /* Set Sensitivity Threshold for button 6 */
  %endif
  %if %Sensitivity7 != '1'  %- only if not power up value
  WriteRegister(SENSITIVITY_7_REGISTER, %Sensitivity7-1); /* Set Sensitivity Threshold for button 7 */
  %endif
  %if %Sensitivity8 != '1'  %- only if not power up value
  WriteRegister(SENSITIVITY_8_REGISTER, %Sensitivity8-1); /* Set Sensitivity Threshold for button 8 */
  %endif
%endif
%if %SounderClickPeriod != '0' | %SounderFrequency != '0' | %SounderEnable != 'yes'
  WriteRegister(SOUNDER_CONFIGURATION_REGISTER,
     (%SounderClickPeriod<<2) | /* CP: Sounder Click Period */
     (%SounderFrequency<<1) | /* FREQ: Sounder Frequency */
    %if %SounderEnable='yes'
     0x01 /* SEN: Sounder Enable: enabled */
    %else
     0 /* SEN: Sounder Enable bit: disabled */
    %endif
    );
%endif
  %if %MasterTickPeriod != '10' %- only if not power up value
  WriteRegister(MASTER_TICK_COUNTER_REGISTER, %MasterTickPeriod-5); /* Set Master Clock (ms) */
  %endif
  %if %TouchAcquisitionSampleFactor != '2'  %- only if not power up value
  WriteRegister(TOUCH_ACQUISITION_SAMPLE_PERIOD_REGISTER, %TouchAcquisitionSampleFactor-1); /* TASP Multiplier */
  %endif
  %if %IdleTimeoutPeriod != '0' | %SleepCycleDuration != '0'  %- only if not power up value
  WriteRegister(LOW_POWER_CONFIGURATION_REGISTER, (%IdleTimeoutPeriod<<5)/*ITP*/|%SleepCycleDuration/*SCD*/);
  %endif
  WriteRegister(PAD_CONFIGURATION_REGISTER,
   %if %SounderEnable = 'yes'
      0x80 | /* sounder enable */
   %endif
   %if %MPRDeviceType = 'MPR084' & %BestKeyAlgorithm='yes'
      0x20 | /* best key algorithm */
   %endif
   %if %AutoCalibrationEnable = 'yes'
      0x10 | /* auto calibration enable */
   %endif
   %if %FIFOReleaseBufferEnable = 'yes'
      0x08 | /* FIFO release button buffer enable */
   %endif
   %if %FIFOTouchBufferEnable = 'yes'
      0x04 | /* FIFO touch button buffer enable */
   %endif
   %if %SensorEnabled = 'yes'
      0x01  /* touch buttons enable */
   %else
      0x0   /* touch buttons disable */
   %endif
     );
%if %MPRDeviceType = 'MPR084'
  %if %Electrode8='no' | %Electrode7='no' | %Electrode6='no' | %Electrode5='no' | %Electrode4='no' | %Electrode3='no' | %Electrode2='no' | %Electrode1='no'
  /* Configure which electrodes shall be enabled */
  WriteRegister(ELECTRODE_CHANNEL_ENABLE_REGISTER,
  %if %Electrode8='yes'
     0x80 | /* Electrode 8 enabled */
  %endif
  %if %Electrode7='yes'
     0x40 | /* Electrode 7 enabled */
  %endif
  %if %Electrode6='yes'
     0x20 | /* Electrode 6 enabled */
  %endif
  %if %Electrode5='yes'
     0x10 | /* Electrode 5 enabled */
  %endif
  %if %Electrode4='yes'
     0x8  | /* Electrode 4 enabled */
  %endif
  %if %Electrode3='yes'
     0x4  | /* Electrode 3 enabled */
  %endif
  %if %Electrode2='yes'
     0x2  | /* Electrode 2 enabled */
  %endif
  %if %Electrode1='yes'
     0x1    /* Electrode 1 enabled */
  %else
     0x0    /* Electrode 1 disabled */
  %endif
  );
  %endif
  %if %MaxNumTouchedPositions != '4' %- only if not power up value
  WriteRegister(MAX_NOF_TOUCH_POSITION_REGISTER, %MaxNumTouchedPositions);
  %endif
%endif
  %if %StuckKeyTimeout != '0' %- only if not power up value
  WriteRegister(STUCK_KEY_TIMEOUT_REGISTER, %StuckKeyTimeout);
  %endif
  /* configure with choosen Run Mode */
  WriteRegister(CONFIGURATION_REGISTER, CONFIGURATION_REGISTER_SETTINGS);
%if %StopI2C = 'yes'
  (void)%@IC2Interface@'ModuleName'%.Disable(); /* Turn off I2C Clock */
%endif
%if %IRQEnabled = 'yes'
  %@IRQ@'ModuleName'%.Enable(); /* enable IRQ events from device */
%endif
}

%-INTERNAL_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetSensitivity
%ifdef SetSensitivity
%define! Parsensitivity
%define! RetVal
%include Common\MPR08xSetSensitivity.Inc
byte %'ModuleName'%.%SetSensitivity(byte sensitivity)
{
%if %StopI2C = 'yes'
  byte err;

%endif
  if (sensitivity == 0 || sensitivity > 64) { /* value shall be in the range 1..64 */
    return ERR_RANGE;
  }
%if %StopI2C = 'yes'
  err = %@IC2Interface@'ModuleName'%.Enable(); /* enable I2C */
  if (err != ERR_OK) { return err; }
%endif
%- %if (%RunMode = '1') | (%RunMode = '0')
  TOGGLE_ATTN(); /* Ensure device is awake. Needed for Stop2 and Run2 mode */
%- %endif
  /* Set Sensitivity Threshold */
%if %MPRDeviceType = 'MPR083'
  WriteRegister(SENSITIVITY_REGISTER, (byte)(sensitivity-1)); /* Set Sensitivity Threshold */
%elif %MPRDeviceType = 'MPR084'
  WriteRegister(SENSITIVITY_1_REGISTER, (byte)(sensitivity-1)); /* Set Sensitivity Threshold for button 1 */
  WriteRegister(SENSITIVITY_2_REGISTER, (byte)(sensitivity-1)); /* Set Sensitivity Threshold for button 2 */
  WriteRegister(SENSITIVITY_3_REGISTER, (byte)(sensitivity-1)); /* Set Sensitivity Threshold for button 3 */
  WriteRegister(SENSITIVITY_4_REGISTER, (byte)(sensitivity-1)); /* Set Sensitivity Threshold for button 4 */
  WriteRegister(SENSITIVITY_5_REGISTER, (byte)(sensitivity-1)); /* Set Sensitivity Threshold for button 5 */
  WriteRegister(SENSITIVITY_6_REGISTER, (byte)(sensitivity-1)); /* Set Sensitivity Threshold for button 6 */
  WriteRegister(SENSITIVITY_7_REGISTER, (byte)(sensitivity-1)); /* Set Sensitivity Threshold for button 7 */
  WriteRegister(SENSITIVITY_8_REGISTER, (byte)(sensitivity-1)); /* Set Sensitivity Threshold for button 8 */
%endif
%if %StopI2C = 'yes'
  return %@IC2Interface@'ModuleName'%.Disable(); /* disable I2C */
%else
  return ERR_OK;
%endif
}

%endif %- SetSensitivity
%-BW_METHOD_END SetSensitivity
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetSounder
%ifdef SetSounder
%define! Parenable
%define! ParclickPeriod
%define! Parfrequency
%define! RetVal
%include Common\MPR08xSetSounder.Inc
byte %'ModuleName'%.%SetSounder(bool enable, byte clickPeriod, byte frequency)
{
%if %StopI2C = 'yes'
  byte err;
%endif

  if (enable && (clickPeriod > 1 || frequency > 1)) { /* clickperiod and frequency can be 0 or 1 */
    return ERR_RANGE;
  }
%if %StopI2C = 'yes'
  err = %@IC2Interface@'ModuleName'%.Enable(); /* enable I2C */
  if (err != ERR_OK) { return err; }
%endif
%- %if (%RunMode = '1') | (%RunMode = '0')
  TOGGLE_ATTN(); /* Ensure device is awake. Needed for Stop2 and Run2 mode */
%- %endif
  /* Enter Stop 1 Mode in order to write registers */
  WriteRegister(CONFIGURATION_REGISTER, CONFIGURATION_REG_RST_NOT|CONFIGURATION_REG_DCE_NOT);
  if (enable) {
    WriteRegister(SOUNDER_CONFIGURATION_REGISTER, (byte)((clickPeriod<<2)/*CP*/ | (frequency<<1)/*FREQ*/ | 0x01/*SEN*/));
  } else {
    WriteRegister(SOUNDER_CONFIGURATION_REGISTER, 0x00); /* disable sounder */
  }
  /* put device back to previous Run Mode */
  WriteRegister(CONFIGURATION_REGISTER, CONFIGURATION_REGISTER_SETTINGS);
%if %StopI2C = 'yes'
  return %@IC2Interface@'ModuleName'%.Disable(); /* disable I2C */
%else
  return ERR_OK;
%endif
}

%endif %- SetSounder
%-BW_METHOD_END SetSounder
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetSensorInformation
%ifdef GetSensorInformation
%define! Parbuf
%define! ParbufSize
%define! RetVal
%include Common\MPR08xGetSensorInformation.Inc
byte %'ModuleName'%.%GetSensorInformation(byte *buf, byte bufSize)
{
  byte ch;
%if %StopI2C = 'yes'
  byte err;
%endif

%if %StopI2C = 'yes'
  err = %@IC2Interface@'ModuleName'%.Enable(); /* enable I2C */
  if (err != ERR_OK) { return err; }
%endif
%- %if (%RunMode = '1') | (%RunMode = '0')
  TOGGLE_ATTN(); /* Ensure device is awake. Needed for Stop2 and Run2 mode */
%- %endif
  while (bufSize > 1) {
    ch = ReadRegister(SENSOR_INFORMATION_REGISTER);
    if (ch =='\0') { /* last byte received */
      break;
    }
    *buf = ch; buf++;
    bufSize--;
  }
  *buf = '\0';
%if %StopI2C = 'yes'
  return %@IC2Interface@'ModuleName'%.Disable(); /* disable I2C */
%else
  return ERR_OK;
%endif
}

%endif %- GetSensorInformation
%-BW_METHOD_END GetSensorInformation
%-************************************************************************************************************
%-BW_METHOD_BEGIN ProcessTouch
%ifdef ProcessTouch
%include Common\MPR08xProcessTouch.Inc
void %'ModuleName'%.%ProcessTouch(void)
{
  byte faultReg, pad;
%if %FIFOenabled='yes'
  byte fifoReg;
%elif %MPRDeviceType = 'MPR084'
  byte padNr=0;
%endif

%if %StopI2C = 'yes'
  (void)%@IC2Interface@'ModuleName'%.Enable(); /* enable I2C */
%endif
%- %if (%RunMode = '1') | (%RunMode = '0')
  TOGGLE_ATTN(); /* Ensure device is awake. Needed for Stop2 and Run2 mode */
%- %endif
  /* Enter Stop1 Mode in order not to receive more interrupts */
  WriteRegister(CONFIGURATION_REGISTER, CONFIGURATION_REG_RST_NOT|CONFIGURATION_REG_DCE_NOT|CONFIGURATION_REG_RUNE);
%if %MPRDeviceType = 'MPR083'
  faultReg = (byte)(ReadRegister(FAULT_REGISTER)&0x3); /* Read Fault Register */
%elif %MPRDeviceType = 'MPR084'
  faultReg = (byte)(ReadRegister(FAULT_REGISTER)&0x7); /* Read Fault Register */
%endif
  if (faultReg != 0) { /* There was a fault! */
    WriteRegister(FAULT_REGISTER, 0); /* write to the fault register in stop mode will clear it */
%if defined(OnFault)
    %OnFault((byte)(faultReg)); /* call fault handler event: 1 is Short to VSS deteced, 2 is Short to VDD detected, 4 (only for MPR083) maximum number of keys detected */
%endif
  }
%if %FIFOenabled='yes'
  /* use FIFO to get data */
  for(;;) {
    fifoReg = ReadRegister(FIFO_REGISTER);
    if (fifoReg&0x20 /* OF */) { /* Overflow Flag */
      /* The Overflow Flag shows whether or not an overflow has occurred. If this flag is high then the most current data was lost. */
%if defined(OnFault)
      %OnFault(ON_MPR08x_FAULT_FIFO_OVL); /* call fault handler event */
%endif
      break;
    }
    if (fifoReg&0x40) {  /* NDF: No data flag: there is currently no data in the buffer. */
      break;
    }
    pad = (byte)(fifoReg&0x1F);
    if(pad&0x10) { /* TRF: Touch Release Flag: 1 if pad is touched */
%if defined(OnPress)
      %OnPress((byte)(pad&0x0F)); /* e.g. 0 for button 3, etc */
%endif
%if defined(OnRelease)
    } else { /* else pad is released */
      %OnRelease((byte)(pad&0x0F)); /* call handler for button release. */
%endif
    }
  } /* for */
%else
  /* read instantaneous data (not using FIFO) */
  pad = ReadRegister(PAD_STATUS_REGISTER);
  %if %MPRDeviceType = 'MPR083'
  if(pad&0x10 /* TRF */) { /* touch release flag: 0 pad is released, 1 pad is touched */
%if defined(OnPress)
    %OnPress((byte)(pad&0x0F)); /* e.g. 0 for electrode 1, 1 for electrode 2, ...,  7 for electrode 8 */
%endif
%if defined(OnRelease)
  } else { /* else if no button is touched */
    %OnRelease((byte)(pad&0x0F)); /* call handler for button release. */
%endif
  }
  %elif %MPRDeviceType = 'MPR084'
%if defined(OnPress)
  while(pad != 0) {
    if (pad&1) { /* report number of electrode touched */
      %OnPress(padNr); /* e.g. 0 for electrode 1, 1 for electrode 2, ...,  7 for electrode 8 */
    }
    pad >>= 1; padNr++;
  }
%endif
  %endif
%endif
%if %FIFOenabled='yes' | defined(@IRQ@OnInterrupt)
  /* If having FIFO enabled or using interrupt mode: need to clear FIFO. In case of interrupts mode because of spurious interrupts which can happen during initalization. */
  WriteRegister(FIFO_REGISTER, 0); /* writing to the FIFO register clears it */
  (void)ReadRegister(FIFO_REGISTER); /* need to read back at least the NO DATA flag from FIFO, otherwise we are stuck! */
%endif
  /* Put the device back previous mode */
  WriteRegister(CONFIGURATION_REGISTER, CONFIGURATION_REGISTER_SETTINGS);
%if %StopI2C = 'yes'
  (void)%@IC2Interface@'ModuleName'%.Disable(); /* disable I2C */
%endif
}

%endif %- ProcessTouch
%-BW_METHOD_END ProcessTouch
%-INHERITED_EVENT_BEGIN IRQ OnInterrupt
%ifdef @IRQ@OnInterrupt
%include Common\GeneralInternal.inc (OnInterrupt)
void %@IRQ@OnInterrupt(void)
{
  %'ModuleName'%.%ProcessTouch();
}

%endif %- @IRQ@OnInterrupt
%-INHERITED_EVENT_END IRQ OnInterrupt
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_METHOD_BEGIN OnPress
%ifdef OnPress
%IMPLEMENTATION OnPress
%define! Parbutton
%include Common\MPR08xOnPress.Inc
void %OnPress(byte button)
{
  (void)button; /* only to avoid compiler warning about unused variable */
  /* Write your code here ... */
}

%endif %- OnPress
%-BW_METHOD_END OnPress
%-BW_METHOD_BEGIN OnFault
%ifdef OnFault
%IMPLEMENTATION OnFault
%define! Parreason
%include Common\MPR08xOnFault.Inc
void %OnFault(byte reason)
{
  (void)reason; /* only to avoid compiler warning about unused variable */
  /* Write your code here ... */
}

%endif %- OnFault
%-BW_METHOD_END OnFault
%-BW_METHOD_BEGIN OnRelease
%ifdef OnRelease
%IMPLEMENTATION OnRelease
%define! Parbutton
%include Common\MPR08xOnRelease.Inc
void %OnRelease(byte button)
{
  (void)button; /* only to avoid compiler warning about unused variable */
  /* Write your code here ... */
}

%endif %- OnRelease
%-BW_METHOD_END OnRelease
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
%CODE_END
  %'ModuleName'%.Init();
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This bean is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
